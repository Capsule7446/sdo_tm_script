// ==UserScript==
// @name       愛哭包專用 - 盛趣腳本
// @namespace  sdo.chd
// @version    2.2.0
// @author     爱哭包
// @icon       https://cdn-icons-png.flaticon.com/512/3712/3712589.png
// @match      https://chdact2.web.sdo.com/project/ChdGrade/*
// @match      https://chdact2.web.sdo.com/project/kwl_*
// @match      https://chdact2.web.sdo.com/project/120629lz/home.asp
// @match      https://chdact2.web.sdo.com/project/Chicas/*
// @require    https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js
// @require    https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js
// ==/UserScript==

(function (React, ReactDOM__default) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
  const ReactDOM__default__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM__default);

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a.prototype = f2.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k2) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a, k2, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$2 = React, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
  function q$2(c2, a, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a.key && (e2 = "" + a.key);
    void 0 !== a.ref && (h2 = a.ref);
    for (b2 in a)
      m$3.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a = c2.defaultProps, a)
        void 0 === d2[b2] && (d2[b2] = a[b2]);
    return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
  }
  reactJsxRuntime_production_min.Fragment = l$2;
  reactJsxRuntime_production_min.jsx = q$2;
  reactJsxRuntime_production_min.jsxs = q$2;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  var client = {};
  var m$2 = ReactDOM__default;
  {
    client.createRoot = m$2.createRoot;
    client.hydrateRoot = m$2.hydrateRoot;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var propTypes = { exports: {} };
  var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    propTypes.exports = factoryWithThrowingShims();
  }
  var propTypesExports = propTypes.exports;
  const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
  function r$1(e2) {
    var t2, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2)
      n2 += e2;
    else if ("object" == typeof e2)
      if (Array.isArray(e2))
        for (t2 = 0; t2 < e2.length; t2++)
          e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
      else
        for (t2 in e2)
          e2[t2] && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
      (e2 = arguments[f2++]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  function chainPropTypes(propType1, propType2) {
    {
      return () => null;
    }
  }
  function isPlainObject$1(item) {
    return item !== null && typeof item === "object" && item.constructor === Object;
  }
  function deepClone$1(source) {
    if (!isPlainObject$1(source)) {
      return source;
    }
    const output = {};
    Object.keys(source).forEach((key) => {
      output[key] = deepClone$1(source[key]);
    });
    return output;
  }
  function deepmerge(target, source, options = {
    clone: true
  }) {
    const output = options.clone ? _extends({}, target) : target;
    if (isPlainObject$1(target) && isPlainObject$1(source)) {
      Object.keys(source).forEach((key) => {
        if (key === "__proto__") {
          return;
        }
        if (isPlainObject$1(source[key]) && key in target && isPlainObject$1(target[key])) {
          output[key] = deepmerge(target[key], source[key], options);
        } else if (options.clone) {
          output[key] = isPlainObject$1(source[key]) ? deepClone$1(source[key]) : source[key];
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }
  function formatMuiErrorMessage(code) {
    let url = "https://mui.com/production-error/?code=" + code;
    for (let i = 1; i < arguments.length; i += 1) {
      url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
  }
  function capitalize(string) {
    if (typeof string !== "string") {
      throw new Error(formatMuiErrorMessage(7));
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  function createChainedFunction(...funcs) {
    return funcs.reduce((acc, func) => {
      if (func == null) {
        return acc;
      }
      return function chainedFunction(...args) {
        acc.apply(this, args);
        func.apply(this, args);
      };
    }, () => {
    });
  }
  function debounce$1(func, wait = 166) {
    let timeout;
    function debounced(...args) {
      const later = () => {
        func.apply(this, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    }
    debounced.clear = () => {
      clearTimeout(timeout);
    };
    return debounced;
  }
  function deprecatedPropType(validator2, reason) {
    {
      return () => null;
    }
  }
  function isMuiElement(element, muiNames) {
    return /* @__PURE__ */ React__namespace.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
  }
  function ownerDocument(node2) {
    return node2 && node2.ownerDocument || document;
  }
  function ownerWindow(node2) {
    const doc = ownerDocument(node2);
    return doc.defaultView || window;
  }
  function requirePropFactory(componentNameInError, Component) {
    {
      return () => null;
    }
  }
  function setRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }
  const useEnhancedEffect = typeof window !== "undefined" ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  const useEnhancedEffect$1 = useEnhancedEffect;
  let globalId$1 = 0;
  function useGlobalId(idOverride) {
    const [defaultId, setDefaultId] = React__namespace.useState(idOverride);
    const id = idOverride || defaultId;
    React__namespace.useEffect(() => {
      if (defaultId == null) {
        globalId$1 += 1;
        setDefaultId(`mui-${globalId$1}`);
      }
    }, [defaultId]);
    return id;
  }
  const maybeReactUseId = React__namespace["useId".toString()];
  function useId(idOverride) {
    if (maybeReactUseId !== void 0) {
      const reactId = maybeReactUseId();
      return idOverride != null ? idOverride : reactId;
    }
    return useGlobalId(idOverride);
  }
  function unsupportedProp(props, propName, componentName, location, propFullName) {
    {
      return null;
    }
  }
  function useControlled({
    controlled,
    default: defaultProp,
    name,
    state = "value"
  }) {
    const {
      current: isControlled
    } = React__namespace.useRef(controlled !== void 0);
    const [valueState, setValue] = React__namespace.useState(defaultProp);
    const value = isControlled ? controlled : valueState;
    const setValueIfUncontrolled = React__namespace.useCallback((newValue) => {
      if (!isControlled) {
        setValue(newValue);
      }
    }, []);
    return [value, setValueIfUncontrolled];
  }
  function useEventCallback(fn2) {
    const ref = React__namespace.useRef(fn2);
    useEnhancedEffect$1(() => {
      ref.current = fn2;
    });
    return React__namespace.useCallback((...args) => (
      // @ts-expect-error hide `this`
      // tslint:disable-next-line:ban-comma-operator
      (0, ref.current)(...args)
    ), []);
  }
  function useForkRef(...refs) {
    return React__namespace.useMemo(() => {
      if (refs.every((ref) => ref == null)) {
        return null;
      }
      return (instance) => {
        refs.forEach((ref) => {
          setRef(ref, instance);
        });
      };
    }, refs);
  }
  let hadKeyboardEvent = true;
  let hadFocusVisibleRecently = false;
  let hadFocusVisibleRecentlyTimeout;
  const inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    "datetime-local": true
  };
  function focusTriggersKeyboardModality(node2) {
    const {
      type,
      tagName
    } = node2;
    if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
      return true;
    }
    if (tagName === "TEXTAREA" && !node2.readOnly) {
      return true;
    }
    if (node2.isContentEditable) {
      return true;
    }
    return false;
  }
  function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }
    hadKeyboardEvent = true;
  }
  function handlePointerDown() {
    hadKeyboardEvent = false;
  }
  function handleVisibilityChange() {
    if (this.visibilityState === "hidden") {
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
    }
  }
  function prepare(doc) {
    doc.addEventListener("keydown", handleKeyDown, true);
    doc.addEventListener("mousedown", handlePointerDown, true);
    doc.addEventListener("pointerdown", handlePointerDown, true);
    doc.addEventListener("touchstart", handlePointerDown, true);
    doc.addEventListener("visibilitychange", handleVisibilityChange, true);
  }
  function isFocusVisible(event) {
    const {
      target
    } = event;
    try {
      return target.matches(":focus-visible");
    } catch (error) {
    }
    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
  }
  function useIsFocusVisible() {
    const ref = React__namespace.useCallback((node2) => {
      if (node2 != null) {
        prepare(node2.ownerDocument);
      }
    }, []);
    const isFocusVisibleRef = React__namespace.useRef(false);
    function handleBlurVisible() {
      if (isFocusVisibleRef.current) {
        hadFocusVisibleRecently = true;
        window.clearTimeout(hadFocusVisibleRecentlyTimeout);
        hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
          hadFocusVisibleRecently = false;
        }, 100);
        isFocusVisibleRef.current = false;
        return true;
      }
      return false;
    }
    function handleFocusVisible(event) {
      if (isFocusVisible(event)) {
        isFocusVisibleRef.current = true;
        return true;
      }
      return false;
    }
    return {
      isFocusVisibleRef,
      onFocus: handleFocusVisible,
      onBlur: handleBlurVisible,
      ref
    };
  }
  function getScrollbarSize(doc) {
    const documentWidth = doc.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  const usePreviousProps = (value) => {
    const ref = React__namespace.useRef({});
    React__namespace.useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  };
  const usePreviousProps$1 = usePreviousProps;
  function resolveProps(defaultProps2, props) {
    const output = _extends({}, props);
    Object.keys(defaultProps2).forEach((propName) => {
      if (propName.toString().match(/^(components|slots)$/)) {
        output[propName] = _extends({}, defaultProps2[propName], output[propName]);
      } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
        const defaultSlotProps = defaultProps2[propName] || {};
        const slotProps = props[propName];
        output[propName] = {};
        if (!slotProps || !Object.keys(slotProps)) {
          output[propName] = defaultSlotProps;
        } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
          output[propName] = slotProps;
        } else {
          output[propName] = _extends({}, slotProps);
          Object.keys(defaultSlotProps).forEach((slotPropName) => {
            output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
          });
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    });
    return output;
  }
  function composeClasses(slots, getUtilityClass, classes = void 0) {
    const output = {};
    Object.keys(slots).forEach(
      // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
      // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
      (slot) => {
        output[slot] = slots[slot].reduce((acc, key) => {
          if (key) {
            const utilityClass = getUtilityClass(key);
            if (utilityClass !== "") {
              acc.push(utilityClass);
            }
            if (classes && classes[key]) {
              acc.push(classes[key]);
            }
          }
          return acc;
        }, []).join(" ");
      }
    );
    return output;
  }
  const defaultGenerator = (componentName) => componentName;
  const createClassNameGenerator = () => {
    let generate = defaultGenerator;
    return {
      configure(generator) {
        generate = generator;
      },
      generate(componentName) {
        return generate(componentName);
      },
      reset() {
        generate = defaultGenerator;
      }
    };
  };
  const ClassNameGenerator = createClassNameGenerator();
  const ClassNameGenerator$1 = ClassNameGenerator;
  const globalStateClassesMapping = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
    const globalStateClass = globalStateClassesMapping[slot];
    return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
  }
  function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
    const result = {};
    slots.forEach((slot) => {
      result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
    });
    return result;
  }
  function memoize$1(fn2) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache[arg] === void 0)
        cache[arg] = fn2(arg);
      return cache[arg];
    };
  }
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize$1(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e2) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush() {
      this.tags.forEach(function(tag) {
        return tag.parentNode && tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash$2(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim$1(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root, props) {
    return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        case type:
          return position;
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset2:
              if (ampersand == -1)
                characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference2 = ruleset(characters2, root, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                  }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index, offset2, rules, points, type, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index; ++i)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size; ++x2)
        if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z2;
    return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length)
          break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent)
        return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k2 = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k2++) {
        element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash$2(value, length2)) {
      case 5103:
        return WEBKIT + "print-" + value + value;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6)
          switch (charat(value, length2 + 1)) {
            case 109:
              if (charat(value, length2 + 4) !== 45)
                break;
            case 102:
              return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
            case 115:
              return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
          }
        break;
      case 4949:
        if (charat(value, length2 + 1) !== 115)
          break;
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      case 5936:
        switch (charat(value, length2 + 11)) {
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"])
        switch (element.type) {
          case DECLARATION:
            element["return"] = prefix(element.value, element.length);
            break;
          case KEYFRAMES:
            return serialize([copy(element, {
              value: replace(element.value, "@", "@" + WEBKIT)
            })], callback);
          case RULESET:
            if (element.length)
              return combine(element.props, function(value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  case ":read-only":
                  case ":read-write":
                    return serialize([copy(element, {
                      props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                    })], callback);
                  case "::placeholder":
                    return serialize([copy(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                    })], callback);
                }
                return "";
              });
        }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles2) {
        return serialize(compile(styles2), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }
    var cache = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };
  var reactIs$1 = { exports: {} };
  var reactIs_production_min = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u2 = a.$$typeof;
      switch (u2) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;
                default:
                  return u2;
              }
          }
        case d:
          return u2;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  {
    reactIs$1.exports = reactIs_production_min;
  }
  var reactIsExports = reactIs$1.exports;
  var reactIs = reactIsExports;
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag2 === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
    registerStyles(cache, serialized, isStringTag2);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2(str) {
    var h2 = 0;
    var k2, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    if (interpolation.__emotion_styles !== void 0) {
      return interpolation;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }
        if (interpolation.styles !== void 0) {
          var next2 = interpolation.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles2 = interpolation.styles + ";";
          return styles2;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    if (registered == null) {
      return interpolation;
    }
    var cached = registered[interpolation];
    return cached !== void 0 ? cached : interpolation;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var _key in obj) {
        var value = obj[_key];
        if (typeof value !== "object") {
          if (registered != null && registered[value] !== void 0) {
            string += _key + "{" + registered[value] + "}";
          } else if (isProcessableValue(value)) {
            string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
          }
        } else {
          if (_key === "NO_COMPONENT_SELECTOR" && false) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (_key) {
              case "animation":
              case "animationName": {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += _key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
  var cursor;
  var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
      styles2 += strings[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles2 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        styles2 += strings[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles2)) !== null) {
      identifierName += "-" + // $FlowFixMe we know it's not null
      match2[1];
    }
    var name = murmur2(styles2) + identifierName;
    return {
      name,
      styles: styles2,
      next: cursor
    };
  };
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect || React__namespace.useLayoutEffect;
  var EmotionCacheContext = /* @__PURE__ */ React__namespace.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ React.forwardRef(function(props, ref) {
      var cache = React.useContext(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };
  var ThemeContext = /* @__PURE__ */ React__namespace.createContext({});
  var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
    var styles2 = props.styles;
    var serialized = serializeStyles([styles2], void 0, React__namespace.useContext(ThemeContext));
    var sheetRef = React__namespace.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache.key + "-global";
      var sheet = new cache.sheet.constructor({
        key,
        nonce: cache.sheet.nonce,
        container: cache.sheet.container,
        speedy: cache.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache.sheet.tags.length) {
        sheet.before = cache.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache.insert("", serialized, sheet, false);
    }, [cache, serialized.name]);
    return null;
  });
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  var keyframes = function keyframes2() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString3() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  };
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp2;
    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
      shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
  };
  var Insertion = function Insertion2(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag2);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag2);
    });
    return null;
  };
  var createStyled$1 = function createStyled2(tag, options) {
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles2.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles2.push.apply(styles2, args);
      } else {
        styles2.push(args[0][0]);
        var len = args.length;
        var i = 1;
        for (; i < len; i++) {
          styles2.push(args[i], args[0][i]);
        }
      }
      var Styled = withEmotionCache(function(props, cache, ref) {
        var FinalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = React__namespace.useContext(ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
        className += cache.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as")
            continue;
          if (
            // $FlowFixMe
            finalShouldForwardProp(_key)
          ) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        newProps.ref = ref;
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Insertion, {
          cache,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }), /* @__PURE__ */ React__namespace.createElement(FinalTag, newProps));
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles2;
      Styled.__emotion_forwardProp = shouldForwardProp2;
      Object.defineProperty(Styled, "toString", {
        value: function value() {
          if (targetClassName === void 0 && false) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        return createStyled2(nextTag, _extends({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles2);
      };
      return Styled;
    };
  };
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = createStyled$1.bind();
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });
  function isEmpty$4(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0;
  }
  function GlobalStyles$2(props) {
    const {
      styles: styles2,
      defaultTheme: defaultTheme2 = {}
    } = props;
    const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
      styles: globalStyles
    });
  }
  /**
   * @mui/styled-engine v5.14.6
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function styled$4(tag, options) {
    const stylesFactory = newStyled(tag, options);
    return stylesFactory;
  }
  const internal_processStyles = (tag, processor) => {
    if (Array.isArray(tag.__emotion_styles)) {
      tag.__emotion_styles = processor(tag.__emotion_styles);
    }
  };
  const _excluded$1V = ["values", "unit", "step"];
  const sortBreakpointsValues = (values2) => {
    const breakpointsAsArray = Object.keys(values2).map((key) => ({
      key,
      val: values2[key]
    })) || [];
    breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
    return breakpointsAsArray.reduce((acc, obj) => {
      return _extends({}, acc, {
        [obj.key]: obj.val
      });
    }, {});
  };
  function createBreakpoints(breakpoints) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: values2 = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit = "px",
      step = 5
    } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded$1V);
    const sortedValues = sortBreakpointsValues(values2);
    const keys = Object.keys(sortedValues);
    function up(key) {
      const value = typeof values2[key] === "number" ? values2[key] : key;
      return `@media (min-width:${value}${unit})`;
    }
    function down(key) {
      const value = typeof values2[key] === "number" ? values2[key] : key;
      return `@media (max-width:${value - step / 100}${unit})`;
    }
    function between(start2, end2) {
      const endIndex = keys.indexOf(end2);
      return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
    }
    function only(key) {
      if (keys.indexOf(key) + 1 < keys.length) {
        return between(key, keys[keys.indexOf(key) + 1]);
      }
      return up(key);
    }
    function not(key) {
      const keyIndex = keys.indexOf(key);
      if (keyIndex === 0) {
        return up(keys[1]);
      }
      if (keyIndex === keys.length - 1) {
        return down(keys[keyIndex]);
      }
      return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
    }
    return _extends({
      keys,
      values: sortedValues,
      up,
      down,
      between,
      only,
      not,
      unit
    }, other);
  }
  const shape = {
    borderRadius: 4
  };
  const shape$1 = shape;
  function merge$1(acc, item) {
    if (!item) {
      return acc;
    }
    return deepmerge(acc, item, {
      clone: false
      // No need to clone deep, it's way faster.
    });
  }
  const values$1 = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  };
  const defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (key) => `@media (min-width:${values$1[key]}px)`
  };
  function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return propValue.reduce((acc, item, index) => {
        acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
        return acc;
      }, {});
    }
    if (typeof propValue === "object") {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return Object.keys(propValue).reduce((acc, breakpoint) => {
        if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
          const mediaKey = themeBreakpoints.up(breakpoint);
          acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        } else {
          const cssKey = breakpoint;
          acc[cssKey] = propValue[cssKey];
        }
        return acc;
      }, {});
    }
    const output = styleFromPropValue(propValue);
    return output;
  }
  function createEmptyBreakpointObject(breakpointsInput = {}) {
    var _breakpointsInput$key;
    const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
      const breakpointStyleKey = breakpointsInput.up(key);
      acc[breakpointStyleKey] = {};
      return acc;
    }, {});
    return breakpointsInOrder || {};
  }
  function removeUnusedBreakpoints(breakpointKeys, style2) {
    return breakpointKeys.reduce((acc, key) => {
      const breakpointOutput = acc[key];
      const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
      if (isBreakpointUnused) {
        delete acc[key];
      }
      return acc;
    }, style2);
  }
  function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
    const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
    const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
    return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
  }
  function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
    if (typeof breakpointValues !== "object") {
      return {};
    }
    const base = {};
    const breakpointsKeys = Object.keys(themeBreakpoints);
    if (Array.isArray(breakpointValues)) {
      breakpointsKeys.forEach((breakpoint, i) => {
        if (i < breakpointValues.length) {
          base[breakpoint] = true;
        }
      });
    } else {
      breakpointsKeys.forEach((breakpoint) => {
        if (breakpointValues[breakpoint] != null) {
          base[breakpoint] = true;
        }
      });
    }
    return base;
  }
  function resolveBreakpointValues({
    values: breakpointValues,
    breakpoints: themeBreakpoints,
    base: customBase
  }) {
    const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
    const keys = Object.keys(base);
    if (keys.length === 0) {
      return breakpointValues;
    }
    let previous;
    return keys.reduce((acc, breakpoint, i) => {
      if (Array.isArray(breakpointValues)) {
        acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
        previous = i;
      } else if (typeof breakpointValues === "object") {
        acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
        previous = breakpoint;
      } else {
        acc[breakpoint] = breakpointValues;
      }
      return acc;
    }, {});
  }
  function getPath(obj, path, checkVars = true) {
    if (!path || typeof path !== "string") {
      return null;
    }
    if (obj && obj.vars && checkVars) {
      const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
      if (val != null) {
        return val;
      }
    }
    return path.split(".").reduce((acc, item) => {
      if (acc && acc[item] != null) {
        return acc[item];
      }
      return null;
    }, obj);
  }
  function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
    let value;
    if (typeof themeMapping === "function") {
      value = themeMapping(propValueFinal);
    } else if (Array.isArray(themeMapping)) {
      value = themeMapping[propValueFinal] || userValue;
    } else {
      value = getPath(themeMapping, propValueFinal) || userValue;
    }
    if (transform) {
      value = transform(value, userValue, themeMapping);
    }
    return value;
  }
  function style$2(options) {
    const {
      prop,
      cssProperty = options.prop,
      themeKey,
      transform
    } = options;
    const fn2 = (props) => {
      if (props[prop] == null) {
        return null;
      }
      const propValue = props[prop];
      const theme = props.theme;
      const themeMapping = getPath(theme, themeKey) || {};
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue$1(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, propValue, styleFromPropValue);
    };
    fn2.propTypes = {};
    fn2.filterProps = [prop];
    return fn2;
  }
  function memoize(fn2) {
    const cache = {};
    return (arg) => {
      if (cache[arg] === void 0) {
        cache[arg] = fn2(arg);
      }
      return cache[arg];
    };
  }
  const properties = {
    m: "margin",
    p: "padding"
  };
  const directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  };
  const aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  };
  const getCssProperties = memoize((prop) => {
    if (prop.length > 2) {
      if (aliases[prop]) {
        prop = aliases[prop];
      } else {
        return [prop];
      }
    }
    const [a, b2] = prop.split("");
    const property = properties[a];
    const direction = directions[b2] || "";
    return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
  });
  const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
  const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  [...marginKeys, ...paddingKeys];
  function createUnaryUnit(theme, themeKey, defaultValue, propName) {
    var _getPath;
    const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
    if (typeof themeSpacing === "number") {
      return (abs2) => {
        if (typeof abs2 === "string") {
          return abs2;
        }
        return themeSpacing * abs2;
      };
    }
    if (Array.isArray(themeSpacing)) {
      return (abs2) => {
        if (typeof abs2 === "string") {
          return abs2;
        }
        return themeSpacing[abs2];
      };
    }
    if (typeof themeSpacing === "function") {
      return themeSpacing;
    }
    return () => void 0;
  }
  function createUnarySpacing(theme) {
    return createUnaryUnit(theme, "spacing", 8);
  }
  function getValue(transformer, propValue) {
    if (typeof propValue === "string" || propValue == null) {
      return propValue;
    }
    const abs2 = Math.abs(propValue);
    const transformed = transformer(abs2);
    if (propValue >= 0) {
      return transformed;
    }
    if (typeof transformed === "number") {
      return -transformed;
    }
    return `-${transformed}`;
  }
  function getStyleFromPropValue(cssProperties, transformer) {
    return (propValue) => cssProperties.reduce((acc, cssProperty) => {
      acc[cssProperty] = getValue(transformer, propValue);
      return acc;
    }, {});
  }
  function resolveCssProperty(props, keys, prop, transformer) {
    if (keys.indexOf(prop) === -1) {
      return null;
    }
    const cssProperties = getCssProperties(prop);
    const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
    const propValue = props[prop];
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }
  function style$1(props, keys) {
    const transformer = createUnarySpacing(props.theme);
    return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$1, {});
  }
  function margin(props) {
    return style$1(props, marginKeys);
  }
  margin.propTypes = {};
  margin.filterProps = marginKeys;
  function padding(props) {
    return style$1(props, paddingKeys);
  }
  padding.propTypes = {};
  padding.filterProps = paddingKeys;
  function createSpacing(spacingInput = 8) {
    if (spacingInput.mui) {
      return spacingInput;
    }
    const transform = createUnarySpacing({
      spacing: spacingInput
    });
    const spacing = (...argsInput) => {
      const args = argsInput.length === 0 ? [1] : argsInput;
      return args.map((argument) => {
        const output = transform(argument);
        return typeof output === "number" ? `${output}px` : output;
      }).join(" ");
    };
    spacing.mui = true;
    return spacing;
  }
  function compose(...styles2) {
    const handlers = styles2.reduce((acc, style2) => {
      style2.filterProps.forEach((prop) => {
        acc[prop] = style2;
      });
      return acc;
    }, {});
    const fn2 = (props) => {
      return Object.keys(props).reduce((acc, prop) => {
        if (handlers[prop]) {
          return merge$1(acc, handlers[prop](props));
        }
        return acc;
      }, {});
    };
    fn2.propTypes = {};
    fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
    return fn2;
  }
  function borderTransform(value) {
    if (typeof value !== "number") {
      return value;
    }
    return `${value}px solid`;
  }
  const border = style$2({
    prop: "border",
    themeKey: "borders",
    transform: borderTransform
  });
  const borderTop = style$2({
    prop: "borderTop",
    themeKey: "borders",
    transform: borderTransform
  });
  const borderRight = style$2({
    prop: "borderRight",
    themeKey: "borders",
    transform: borderTransform
  });
  const borderBottom = style$2({
    prop: "borderBottom",
    themeKey: "borders",
    transform: borderTransform
  });
  const borderLeft = style$2({
    prop: "borderLeft",
    themeKey: "borders",
    transform: borderTransform
  });
  const borderColor = style$2({
    prop: "borderColor",
    themeKey: "palette"
  });
  const borderTopColor = style$2({
    prop: "borderTopColor",
    themeKey: "palette"
  });
  const borderRightColor = style$2({
    prop: "borderRightColor",
    themeKey: "palette"
  });
  const borderBottomColor = style$2({
    prop: "borderBottomColor",
    themeKey: "palette"
  });
  const borderLeftColor = style$2({
    prop: "borderLeftColor",
    themeKey: "palette"
  });
  const borderRadius = (props) => {
    if (props.borderRadius !== void 0 && props.borderRadius !== null) {
      const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
      const styleFromPropValue = (propValue) => ({
        borderRadius: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
    }
    return null;
  };
  borderRadius.propTypes = {};
  borderRadius.filterProps = ["borderRadius"];
  compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
  const gap = (props) => {
    if (props.gap !== void 0 && props.gap !== null) {
      const transformer = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        gap: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.gap, styleFromPropValue);
    }
    return null;
  };
  gap.propTypes = {};
  gap.filterProps = ["gap"];
  const columnGap = (props) => {
    if (props.columnGap !== void 0 && props.columnGap !== null) {
      const transformer = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        columnGap: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.columnGap, styleFromPropValue);
    }
    return null;
  };
  columnGap.propTypes = {};
  columnGap.filterProps = ["columnGap"];
  const rowGap = (props) => {
    if (props.rowGap !== void 0 && props.rowGap !== null) {
      const transformer = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        rowGap: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.rowGap, styleFromPropValue);
    }
    return null;
  };
  rowGap.propTypes = {};
  rowGap.filterProps = ["rowGap"];
  const gridColumn = style$2({
    prop: "gridColumn"
  });
  const gridRow = style$2({
    prop: "gridRow"
  });
  const gridAutoFlow = style$2({
    prop: "gridAutoFlow"
  });
  const gridAutoColumns = style$2({
    prop: "gridAutoColumns"
  });
  const gridAutoRows = style$2({
    prop: "gridAutoRows"
  });
  const gridTemplateColumns = style$2({
    prop: "gridTemplateColumns"
  });
  const gridTemplateRows = style$2({
    prop: "gridTemplateRows"
  });
  const gridTemplateAreas = style$2({
    prop: "gridTemplateAreas"
  });
  const gridArea = style$2({
    prop: "gridArea"
  });
  compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
  function paletteTransform(value, userValue) {
    if (userValue === "grey") {
      return userValue;
    }
    return value;
  }
  const color = style$2({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform
  });
  const bgcolor = style$2({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  const backgroundColor = style$2({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  compose(color, bgcolor, backgroundColor);
  function sizingTransform(value) {
    return value <= 1 && value !== 0 ? `${value * 100}%` : value;
  }
  const width = style$2({
    prop: "width",
    transform: sizingTransform
  });
  const maxWidth = (props) => {
    if (props.maxWidth !== void 0 && props.maxWidth !== null) {
      const styleFromPropValue = (propValue) => {
        var _props$theme;
        const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
        return {
          maxWidth: breakpoint || sizingTransform(propValue)
        };
      };
      return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
    }
    return null;
  };
  maxWidth.filterProps = ["maxWidth"];
  const minWidth = style$2({
    prop: "minWidth",
    transform: sizingTransform
  });
  const height = style$2({
    prop: "height",
    transform: sizingTransform
  });
  const maxHeight = style$2({
    prop: "maxHeight",
    transform: sizingTransform
  });
  const minHeight = style$2({
    prop: "minHeight",
    transform: sizingTransform
  });
  style$2({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
  });
  style$2({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
  });
  const boxSizing = style$2({
    prop: "boxSizing"
  });
  compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
  const defaultSxConfig = {
    // borders
    border: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderTop: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderRight: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderBottom: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderLeft: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: borderRadius
    },
    // palette
    color: {
      themeKey: "palette",
      transform: paletteTransform
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: paletteTransform
    },
    backgroundColor: {
      themeKey: "palette",
      transform: paletteTransform
    },
    // spacing
    p: {
      style: padding
    },
    pt: {
      style: padding
    },
    pr: {
      style: padding
    },
    pb: {
      style: padding
    },
    pl: {
      style: padding
    },
    px: {
      style: padding
    },
    py: {
      style: padding
    },
    padding: {
      style: padding
    },
    paddingTop: {
      style: padding
    },
    paddingRight: {
      style: padding
    },
    paddingBottom: {
      style: padding
    },
    paddingLeft: {
      style: padding
    },
    paddingX: {
      style: padding
    },
    paddingY: {
      style: padding
    },
    paddingInline: {
      style: padding
    },
    paddingInlineStart: {
      style: padding
    },
    paddingInlineEnd: {
      style: padding
    },
    paddingBlock: {
      style: padding
    },
    paddingBlockStart: {
      style: padding
    },
    paddingBlockEnd: {
      style: padding
    },
    m: {
      style: margin
    },
    mt: {
      style: margin
    },
    mr: {
      style: margin
    },
    mb: {
      style: margin
    },
    ml: {
      style: margin
    },
    mx: {
      style: margin
    },
    my: {
      style: margin
    },
    margin: {
      style: margin
    },
    marginTop: {
      style: margin
    },
    marginRight: {
      style: margin
    },
    marginBottom: {
      style: margin
    },
    marginLeft: {
      style: margin
    },
    marginX: {
      style: margin
    },
    marginY: {
      style: margin
    },
    marginInline: {
      style: margin
    },
    marginInlineStart: {
      style: margin
    },
    marginInlineEnd: {
      style: margin
    },
    marginBlock: {
      style: margin
    },
    marginBlockStart: {
      style: margin
    },
    marginBlockEnd: {
      style: margin
    },
    // display
    displayPrint: {
      cssProperty: false,
      transform: (value) => ({
        "@media print": {
          display: value
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: gap
    },
    rowGap: {
      style: rowGap
    },
    columnGap: {
      style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: sizingTransform
    },
    maxWidth: {
      style: maxWidth
    },
    minWidth: {
      transform: sizingTransform
    },
    height: {
      transform: sizingTransform
    },
    maxHeight: {
      transform: sizingTransform
    },
    minHeight: {
      transform: sizingTransform
    },
    boxSizing: {},
    // typography
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: false,
      themeKey: "typography"
    }
  };
  const defaultSxConfig$1 = defaultSxConfig;
  function objectsHaveSameKeys(...objects) {
    const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
    const union = new Set(allKeys);
    return objects.every((object) => union.size === Object.keys(object).length);
  }
  function callIfFn(maybeFn, arg) {
    return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
  }
  function unstable_createStyleFunctionSx() {
    function getThemeValue(prop, val, theme, config2) {
      const props = {
        [prop]: val,
        theme
      };
      const options = config2[prop];
      if (!options) {
        return {
          [prop]: val
        };
      }
      const {
        cssProperty = prop,
        themeKey,
        transform,
        style: style2
      } = options;
      if (val == null) {
        return null;
      }
      if (themeKey === "typography" && val === "inherit") {
        return {
          [prop]: val
        };
      }
      const themeMapping = getPath(theme, themeKey) || {};
      if (style2) {
        return style2(props);
      }
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue$1(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, val, styleFromPropValue);
    }
    function styleFunctionSx2(props) {
      var _theme$unstable_sxCon;
      const {
        sx,
        theme = {}
      } = props || {};
      if (!sx) {
        return null;
      }
      const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
      function traverse(sxInput) {
        let sxObject = sxInput;
        if (typeof sxInput === "function") {
          sxObject = sxInput(theme);
        } else if (typeof sxInput !== "object") {
          return sxInput;
        }
        if (!sxObject) {
          return null;
        }
        const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
        const breakpointsKeys = Object.keys(emptyBreakpoints);
        let css2 = emptyBreakpoints;
        Object.keys(sxObject).forEach((styleKey) => {
          const value = callIfFn(sxObject[styleKey], theme);
          if (value !== null && value !== void 0) {
            if (typeof value === "object") {
              if (config2[styleKey]) {
                css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
              } else {
                const breakpointsValues = handleBreakpoints({
                  theme
                }, value, (x2) => ({
                  [styleKey]: x2
                }));
                if (objectsHaveSameKeys(breakpointsValues, value)) {
                  css2[styleKey] = styleFunctionSx2({
                    sx: value,
                    theme
                  });
                } else {
                  css2 = merge$1(css2, breakpointsValues);
                }
              }
            } else {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
            }
          }
        });
        return removeUnusedBreakpoints(breakpointsKeys, css2);
      }
      return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
    }
    return styleFunctionSx2;
  }
  const styleFunctionSx = unstable_createStyleFunctionSx();
  styleFunctionSx.filterProps = ["sx"];
  const styleFunctionSx$1 = styleFunctionSx;
  const _excluded$1U = ["breakpoints", "palette", "spacing", "shape"];
  function createTheme$1(options = {}, ...args) {
    const {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {}
    } = options, other = _objectWithoutPropertiesLoose(options, _excluded$1U);
    const breakpoints = createBreakpoints(breakpointsInput);
    const spacing = createSpacing(spacingInput);
    let muiTheme = deepmerge({
      breakpoints,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: _extends({
        mode: "light"
      }, paletteInput),
      spacing,
      shape: _extends({}, shape$1, shapeInput)
    }, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx$1({
        sx: props,
        theme: this
      });
    };
    return muiTheme;
  }
  function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
  }
  function useTheme$2(defaultTheme2 = null) {
    const contextTheme = React__namespace.useContext(ThemeContext);
    return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
  }
  const systemDefaultTheme$1 = createTheme$1();
  function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
    return useTheme$2(defaultTheme2);
  }
  function GlobalStyles$1({
    styles: styles2,
    themeId,
    defaultTheme: defaultTheme2 = {}
  }) {
    const upperTheme = useTheme$1(defaultTheme2);
    const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
      styles: globalStyles
    });
  }
  const _excluded$1T = ["sx"];
  const splitProps = (props) => {
    var _props$theme$unstable, _props$theme;
    const result = {
      systemProps: {},
      otherProps: {}
    };
    const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
    Object.keys(props).forEach((prop) => {
      if (config2[prop]) {
        result.systemProps[prop] = props[prop];
      } else {
        result.otherProps[prop] = props[prop];
      }
    });
    return result;
  };
  function extendSxProp(props) {
    const {
      sx: inSx
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1T);
    const {
      systemProps,
      otherProps
    } = splitProps(other);
    let finalSx;
    if (Array.isArray(inSx)) {
      finalSx = [systemProps, ...inSx];
    } else if (typeof inSx === "function") {
      finalSx = (...args) => {
        const result = inSx(...args);
        if (!isPlainObject$1(result)) {
          return systemProps;
        }
        return _extends({}, systemProps, result);
      };
    } else {
      finalSx = _extends({}, systemProps, inSx);
    }
    return _extends({}, otherProps, {
      sx: finalSx
    });
  }
  const _excluded$1S = ["className", "component"];
  function createBox(options = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme2,
      defaultClassName = "MuiBox-root",
      generateClassName
    } = options;
    const BoxRoot = styled$4("div", {
      shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
    })(styleFunctionSx$1);
    const Box2 = /* @__PURE__ */ React__namespace.forwardRef(function Box3(inProps, ref) {
      const theme = useTheme$1(defaultTheme2);
      const _extendSxProp = extendSxProp(inProps), {
        className,
        component = "div"
      } = _extendSxProp, other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded$1S);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends({
        as: component,
        ref,
        className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
        theme: themeId ? theme[themeId] || theme : theme
      }, other));
    });
    return Box2;
  }
  const _excluded$1R = ["variant"];
  function isEmpty$3(string) {
    return string.length === 0;
  }
  function propsToClassKey(props) {
    const {
      variant
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1R);
    let classKey = variant || "";
    Object.keys(other).sort().forEach((key) => {
      if (key === "color") {
        classKey += isEmpty$3(classKey) ? props[key] : capitalize(props[key]);
      } else {
        classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
      }
    });
    return classKey;
  }
  const _excluded$1Q = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function isEmpty$2(obj) {
    return Object.keys(obj).length === 0;
  }
  function isStringTag(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96;
  }
  const getStyleOverrides = (name, theme) => {
    if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
      return theme.components[name].styleOverrides;
    }
    return null;
  };
  const getVariantStyles = (name, theme) => {
    let variants = [];
    if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
      variants = theme.components[name].variants;
    }
    const variantsStyles = {};
    variants.forEach((definition) => {
      const key = propsToClassKey(definition.props);
      variantsStyles[key] = definition.style;
    });
    return variantsStyles;
  };
  const variantsResolver = (props, styles2, theme, name) => {
    var _theme$components;
    const {
      ownerState = {}
    } = props;
    const variantsStyles = [];
    const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[name]) == null ? void 0 : _theme$components.variants;
    if (themeVariants) {
      themeVariants.forEach((themeVariant) => {
        let isMatch = true;
        Object.keys(themeVariant.props).forEach((key) => {
          if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
            isMatch = false;
          }
        });
        if (isMatch) {
          variantsStyles.push(styles2[propsToClassKey(themeVariant.props)]);
        }
      });
    }
    return variantsStyles;
  };
  function shouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  const systemDefaultTheme = createTheme$1();
  const lowercaseFirstLetter = (string) => {
    if (!string) {
      return string;
    }
    return string.charAt(0).toLowerCase() + string.slice(1);
  };
  function resolveTheme({
    defaultTheme: defaultTheme2,
    theme,
    themeId
  }) {
    return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
  }
  function defaultOverridesResolver(slot) {
    if (!slot) {
      return null;
    }
    return (props, styles2) => styles2[slot];
  }
  function createStyled(input = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme2 = systemDefaultTheme,
      rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
      slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
    } = input;
    const systemSx = (props) => {
      return styleFunctionSx$1(_extends({}, props, {
        theme: resolveTheme(_extends({}, props, {
          defaultTheme: defaultTheme2,
          themeId
        }))
      }));
    };
    systemSx.__mui_systemSx = true;
    return (tag, inputOptions = {}) => {
      internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
      const {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
      } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded$1Q);
      const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
      );
      const skipSx = inputSkipSx || false;
      let label;
      let shouldForwardPropOption = shouldForwardProp;
      if (componentSlot === "Root" || componentSlot === "root") {
        shouldForwardPropOption = rootShouldForwardProp2;
      } else if (componentSlot) {
        shouldForwardPropOption = slotShouldForwardProp2;
      } else if (isStringTag(tag)) {
        shouldForwardPropOption = void 0;
      }
      const defaultStyledResolver = styled$4(tag, _extends({
        shouldForwardProp: shouldForwardPropOption,
        label
      }, options));
      const muiStyledResolver = (styleArg, ...expressions) => {
        const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
          return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (props) => {
            return stylesArg(_extends({}, props, {
              theme: resolveTheme(_extends({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }))
            }));
          } : stylesArg;
        }) : [];
        let transformedStyleArg = styleArg;
        if (componentName && overridesResolver2) {
          expressionsWithDefaultTheme.push((props) => {
            const theme = resolveTheme(_extends({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }));
            const styleOverrides = getStyleOverrides(componentName, theme);
            if (styleOverrides) {
              const resolvedStyleOverrides = {};
              Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends({}, props, {
                  theme
                })) : slotStyle;
              });
              return overridesResolver2(props, resolvedStyleOverrides);
            }
            return null;
          });
        }
        if (componentName && !skipVariantsResolver) {
          expressionsWithDefaultTheme.push((props) => {
            const theme = resolveTheme(_extends({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }));
            return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
          });
        }
        if (!skipSx) {
          expressionsWithDefaultTheme.push(systemSx);
        }
        const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
        if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
          const placeholders = new Array(numOfCustomFnsApplied).fill("");
          transformedStyleArg = [...styleArg, ...placeholders];
          transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
        } else if (typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        styleArg.__emotion_real !== styleArg) {
          transformedStyleArg = (props) => styleArg(_extends({}, props, {
            theme: resolveTheme(_extends({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }))
          }));
        }
        const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
        if (tag.muiName) {
          Component.muiName = tag.muiName;
        }
        return Component;
      };
      if (defaultStyledResolver.withConfig) {
        muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
      }
      return muiStyledResolver;
    };
  }
  const styled$2 = createStyled();
  const styled$3 = styled$2;
  function getThemeProps(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
      return props;
    }
    return resolveProps(theme.components[name].defaultProps, props);
  }
  function useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme2,
    themeId
  }) {
    let theme = useTheme$1(defaultTheme2);
    if (themeId) {
      theme = theme[themeId] || theme;
    }
    const mergedProps = getThemeProps({
      theme,
      name,
      props
    });
    return mergedProps;
  }
  function clamp$1(value, min2 = 0, max2 = 1) {
    return Math.min(Math.max(min2, value), max2);
  }
  function hexToRgb(color2) {
    color2 = color2.slice(1);
    const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
    let colors = color2.match(re);
    if (colors && colors[0].length === 1) {
      colors = colors.map((n2) => n2 + n2);
    }
    return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
    return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
  }
  function decomposeColor(color2) {
    if (color2.type) {
      return color2;
    }
    if (color2.charAt(0) === "#") {
      return decomposeColor(hexToRgb(color2));
    }
    const marker = color2.indexOf("(");
    const type = color2.substring(0, marker);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
      throw new Error(formatMuiErrorMessage(9, color2));
    }
    let values2 = color2.substring(marker + 1, color2.length - 1);
    let colorSpace;
    if (type === "color") {
      values2 = values2.split(" ");
      colorSpace = values2.shift();
      if (values2.length === 4 && values2[3].charAt(0) === "/") {
        values2[3] = values2[3].slice(1);
      }
      if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
        throw new Error(formatMuiErrorMessage(10, colorSpace));
      }
    } else {
      values2 = values2.split(",");
    }
    values2 = values2.map((value) => parseFloat(value));
    return {
      type,
      values: values2,
      colorSpace
    };
  }
  function recomposeColor(color2) {
    const {
      type,
      colorSpace
    } = color2;
    let {
      values: values2
    } = color2;
    if (type.indexOf("rgb") !== -1) {
      values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
    } else if (type.indexOf("hsl") !== -1) {
      values2[1] = `${values2[1]}%`;
      values2[2] = `${values2[2]}%`;
    }
    if (type.indexOf("color") !== -1) {
      values2 = `${colorSpace} ${values2.join(" ")}`;
    } else {
      values2 = `${values2.join(", ")}`;
    }
    return `${type}(${values2})`;
  }
  function hslToRgb(color2) {
    color2 = decomposeColor(color2);
    const {
      values: values2
    } = color2;
    const h2 = values2[0];
    const s = values2[1] / 100;
    const l2 = values2[2] / 100;
    const a = s * Math.min(l2, 1 - l2);
    const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
    let type = "rgb";
    const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
    if (color2.type === "hsla") {
      type += "a";
      rgb.push(values2[3]);
    }
    return recomposeColor({
      type,
      values: rgb
    });
  }
  function getLuminance(color2) {
    color2 = decomposeColor(color2);
    let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
    rgb = rgb.map((val) => {
      if (color2.type !== "color") {
        val /= 255;
      }
      return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  function alpha(color2, value) {
    color2 = decomposeColor(color2);
    value = clamp$1(value);
    if (color2.type === "rgb" || color2.type === "hsl") {
      color2.type += "a";
    }
    if (color2.type === "color") {
      color2.values[3] = `/${value}`;
    } else {
      color2.values[3] = value;
    }
    return recomposeColor(color2);
  }
  function darken(color2, coefficient) {
    color2 = decomposeColor(color2);
    coefficient = clamp$1(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
      color2.values[2] *= 1 - coefficient;
    } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor(color2);
  }
  function lighten(color2, coefficient) {
    color2 = decomposeColor(color2);
    coefficient = clamp$1(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
      color2.values[2] += (100 - color2.values[2]) * coefficient;
    } else if (color2.type.indexOf("rgb") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (255 - color2.values[i]) * coefficient;
      }
    } else if (color2.type.indexOf("color") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (1 - color2.values[i]) * coefficient;
      }
    }
    return recomposeColor(color2);
  }
  const _excluded$1P = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
  const defaultTheme$3 = createTheme$1();
  const defaultCreateStyledComponent = styled$3("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  });
  function useThemePropsDefault(props) {
    return useThemeProps$1({
      props,
      name: "MuiStack",
      defaultTheme: defaultTheme$3
    });
  }
  function joinChildren(children, separator) {
    const childrenArray = React__namespace.Children.toArray(children).filter(Boolean);
    return childrenArray.reduce((output, child, index) => {
      output.push(child);
      if (index < childrenArray.length - 1) {
        output.push(/* @__PURE__ */ React__namespace.cloneElement(separator, {
          key: `separator-${index}`
        }));
      }
      return output;
    }, []);
  }
  const getSideFromDirection = (direction) => {
    return {
      row: "Left",
      "row-reverse": "Right",
      column: "Top",
      "column-reverse": "Bottom"
    }[direction];
  };
  const style = ({
    ownerState,
    theme
  }) => {
    let styles2 = _extends({
      display: "flex",
      flexDirection: "column"
    }, handleBreakpoints({
      theme
    }, resolveBreakpointValues({
      values: ownerState.direction,
      breakpoints: theme.breakpoints.values
    }), (propValue) => ({
      flexDirection: propValue
    })));
    if (ownerState.spacing) {
      const transformer = createUnarySpacing(theme);
      const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
        if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
          acc[breakpoint] = true;
        }
        return acc;
      }, {});
      const directionValues = resolveBreakpointValues({
        values: ownerState.direction,
        base
      });
      const spacingValues = resolveBreakpointValues({
        values: ownerState.spacing,
        base
      });
      if (typeof directionValues === "object") {
        Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
          const directionValue = directionValues[breakpoint];
          if (!directionValue) {
            const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
            directionValues[breakpoint] = previousDirectionValue;
          }
        });
      }
      const styleFromPropValue = (propValue, breakpoint) => {
        if (ownerState.useFlexGap) {
          return {
            gap: getValue(transformer, propValue)
          };
        }
        return {
          // The useFlexGap={false} implement relies on each child to give up control of the margin.
          // We need to reset the margin to avoid double spacing.
          "& > :not(style):not(style)": {
            margin: 0
          },
          "& > :not(style) ~ :not(style)": {
            [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
          }
        };
      };
      styles2 = deepmerge(styles2, handleBreakpoints({
        theme
      }, spacingValues, styleFromPropValue));
    }
    styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
    return styles2;
  };
  function createStack(options = {}) {
    const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent = defaultCreateStyledComponent,
      useThemeProps: useThemeProps2 = useThemePropsDefault,
      componentName = "MuiStack"
    } = options;
    const useUtilityClasses2 = () => {
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
    };
    const StackRoot = createStyledComponent(style);
    const Stack2 = /* @__PURE__ */ React__namespace.forwardRef(function Grid(inProps, ref) {
      const themeProps = useThemeProps2(inProps);
      const props = extendSxProp(themeProps);
      const {
        component = "div",
        direction = "column",
        spacing = 0,
        divider,
        children,
        className,
        useFlexGap = false
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1P);
      const ownerState = {
        direction,
        spacing,
        useFlexGap
      };
      const classes = useUtilityClasses2();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, _extends({
        as: component,
        ownerState,
        ref,
        className: clsx(classes.root, className)
      }, other, {
        children: divider ? joinChildren(children, divider) : children
      }));
    });
    return Stack2;
  }
  function createMixins(breakpoints, mixins) {
    return _extends({
      toolbar: {
        minHeight: 56,
        [breakpoints.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [breakpoints.up("sm")]: {
          minHeight: 64
        }
      }
    }, mixins);
  }
  const common = {
    black: "#000",
    white: "#fff"
  };
  const common$1 = common;
  const grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  };
  const grey$1 = grey;
  const purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
  };
  const purple$1 = purple;
  const red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  };
  const red$1 = red;
  const orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
  };
  const orange$1 = orange;
  const blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
  };
  const blue$1 = blue;
  const lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  };
  const lightBlue$1 = lightBlue;
  const green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
  };
  const green$1 = green;
  const _excluded$1O = ["mode", "contrastThreshold", "tonalOffset"];
  const light = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common$1.white,
      default: common$1.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
  const dark = {
    text: {
      primary: common$1.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common$1.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
  function addLightOrDark(intent, direction, shade, tonalOffset) {
    const tonalOffsetLight = tonalOffset.light || tonalOffset;
    const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === "light") {
        intent.light = lighten(intent.main, tonalOffsetLight);
      } else if (direction === "dark") {
        intent.dark = darken(intent.main, tonalOffsetDark);
      }
    }
  }
  function getDefaultPrimary(mode = "light") {
    if (mode === "dark") {
      return {
        main: blue$1[200],
        light: blue$1[50],
        dark: blue$1[400]
      };
    }
    return {
      main: blue$1[700],
      light: blue$1[400],
      dark: blue$1[800]
    };
  }
  function getDefaultSecondary(mode = "light") {
    if (mode === "dark") {
      return {
        main: purple$1[200],
        light: purple$1[50],
        dark: purple$1[400]
      };
    }
    return {
      main: purple$1[500],
      light: purple$1[300],
      dark: purple$1[700]
    };
  }
  function getDefaultError(mode = "light") {
    if (mode === "dark") {
      return {
        main: red$1[500],
        light: red$1[300],
        dark: red$1[700]
      };
    }
    return {
      main: red$1[700],
      light: red$1[400],
      dark: red$1[800]
    };
  }
  function getDefaultInfo(mode = "light") {
    if (mode === "dark") {
      return {
        main: lightBlue$1[400],
        light: lightBlue$1[300],
        dark: lightBlue$1[700]
      };
    }
    return {
      main: lightBlue$1[700],
      light: lightBlue$1[500],
      dark: lightBlue$1[900]
    };
  }
  function getDefaultSuccess(mode = "light") {
    if (mode === "dark") {
      return {
        main: green$1[400],
        light: green$1[300],
        dark: green$1[700]
      };
    }
    return {
      main: green$1[800],
      light: green$1[500],
      dark: green$1[900]
    };
  }
  function getDefaultWarning(mode = "light") {
    if (mode === "dark") {
      return {
        main: orange$1[400],
        light: orange$1[300],
        dark: orange$1[700]
      };
    }
    return {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: orange$1[500],
      dark: orange$1[900]
    };
  }
  function createPalette(palette) {
    const {
      mode = "light",
      contrastThreshold = 3,
      tonalOffset = 0.2
    } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded$1O);
    const primary = palette.primary || getDefaultPrimary(mode);
    const secondary = palette.secondary || getDefaultSecondary(mode);
    const error = palette.error || getDefaultError(mode);
    const info = palette.info || getDefaultInfo(mode);
    const success = palette.success || getDefaultSuccess(mode);
    const warning = palette.warning || getDefaultWarning(mode);
    function getContrastText(background) {
      const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
      return contrastText;
    }
    const augmentColor = ({
      color: color2,
      name,
      mainShade = 500,
      lightShade = 300,
      darkShade = 700
    }) => {
      color2 = _extends({}, color2);
      if (!color2.main && color2[mainShade]) {
        color2.main = color2[mainShade];
      }
      if (!color2.hasOwnProperty("main")) {
        throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
      }
      if (typeof color2.main !== "string") {
        throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
      }
      addLightOrDark(color2, "light", lightShade, tonalOffset);
      addLightOrDark(color2, "dark", darkShade, tonalOffset);
      if (!color2.contrastText) {
        color2.contrastText = getContrastText(color2.main);
      }
      return color2;
    };
    const modes = {
      dark,
      light
    };
    const paletteOutput = deepmerge(_extends({
      // A collection of common colors.
      common: _extends({}, common$1),
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor({
        color: primary,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor({
        color: secondary,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor({
        color: error,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor({
        color: warning,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor({
        color: info,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor({
        color: success,
        name: "success"
      }),
      // The grey colors.
      grey: grey$1,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText,
      // Generate a rich color object.
      augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset
    }, modes[mode]), other);
    return paletteOutput;
  }
  const _excluded$1N = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
  function round$2(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  const caseAllCaps = {
    textTransform: "uppercase"
  };
  const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  function createTypography(palette, typography) {
    const _ref = typeof typography === "function" ? typography(palette) : typography, {
      fontFamily = defaultFontFamily,
      // The default font size of the Material Specification.
      fontSize = 14,
      // px
      fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize = 16,
      // Apply the CSS properties to all the variants.
      allVariants,
      pxToRem: pxToRem2
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$1N);
    const coef = fontSize / 14;
    const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
    const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
      fontFamily,
      fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight
    }, fontFamily === defaultFontFamily ? {
      letterSpacing: `${round$2(letterSpacing / size)}em`
    } : {}, casing, allVariants);
    const variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return deepmerge(_extends({
      htmlFontSize,
      pxToRem,
      fontFamily,
      fontSize,
      fontWeightLight,
      fontWeightRegular,
      fontWeightMedium,
      fontWeightBold
    }, variants), other, {
      clone: false
      // No need to clone deep
    });
  }
  const shadowKeyUmbraOpacity = 0.2;
  const shadowKeyPenumbraOpacity = 0.14;
  const shadowAmbientShadowOpacity = 0.12;
  function createShadow(...px) {
    return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
  }
  const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  const shadows$1 = shadows;
  const _excluded$1M = ["duration", "easing", "delay"];
  const easing = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  };
  const duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function formatMs(milliseconds) {
    return `${Math.round(milliseconds)}ms`;
  }
  function getAutoHeightDuration(height2) {
    if (!height2) {
      return 0;
    }
    const constant = height2 / 36;
    return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
  }
  function createTransitions(inputTransitions) {
    const mergedEasing = _extends({}, easing, inputTransitions.easing);
    const mergedDuration = _extends({}, duration, inputTransitions.duration);
    const create = (props = ["all"], options = {}) => {
      const {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = options;
      _objectWithoutPropertiesLoose(options, _excluded$1M);
      return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
    };
    return _extends({
      getAutoHeightDuration,
      create
    }, inputTransitions, {
      easing: mergedEasing,
      duration: mergedDuration
    });
  }
  const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  const zIndex$1 = zIndex;
  const _excluded$1L = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
  function createTheme(options = {}, ...args) {
    const {
      mixins: mixinsInput = {},
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {}
    } = options, other = _objectWithoutPropertiesLoose(options, _excluded$1L);
    if (options.vars) {
      throw new Error(formatMuiErrorMessage(18));
    }
    const palette = createPalette(paletteInput);
    const systemTheme = createTheme$1(options);
    let muiTheme = deepmerge(systemTheme, {
      mixins: createMixins(systemTheme.breakpoints, mixinsInput),
      palette,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: shadows$1.slice(),
      typography: createTypography(palette, typographyInput),
      transitions: createTransitions(transitionsInput),
      zIndex: _extends({}, zIndex$1)
    });
    muiTheme = deepmerge(muiTheme, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx$1({
        sx: props,
        theme: this
      });
    };
    return muiTheme;
  }
  const defaultTheme$1 = createTheme();
  const defaultTheme$2 = defaultTheme$1;
  const THEME_ID = "$$material";
  const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
  const slotShouldForwardProp = shouldForwardProp;
  const styled = createStyled({
    themeId: THEME_ID,
    defaultTheme: defaultTheme$2,
    rootShouldForwardProp
  });
  const styled$1 = styled;
  function useThemeProps({
    props,
    name
  }) {
    return useThemeProps$1({
      props,
      name,
      defaultTheme: defaultTheme$2,
      themeId: THEME_ID
    });
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  const config = {
    disabled: false
  };
  const TransitionGroupContext = React.createContext(null);
  var forceReflow = function forceReflow2(node2) {
    return node2.scrollTop;
  };
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;
      if (timeout != null && typeof timeout !== "number") {
        exit = timeout.exit;
        enter = timeout.enter;
        appear = timeout.appear !== void 0 ? timeout.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this);
            if (node2)
              forceReflow(node2);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
      if (!mounting && !enter || config.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : ReactDOM__default.findDOMNode(this);
      if (!exit || config.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
      if (!node2 || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(React.Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {};
  function noop$2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  const Transition$1 = Transition;
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function getChildMapping(children, mapFn) {
    var mapper = function mapper2(child) {
      return mapFn && React.isValidElement(child) ? mapFn(child) : child;
    };
    var result = /* @__PURE__ */ Object.create(null);
    if (children)
      React.Children.map(children, function(c2) {
        return c2;
      }).forEach(function(child) {
        result[child.key] = mapper(child);
      });
    return result;
  }
  function mergeChildMappings(prev2, next2) {
    prev2 = prev2 || {};
    next2 = next2 || {};
    function getValueForKey(key) {
      return key in next2 ? next2[key] : prev2[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev2) {
      if (prevKey in next2) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i;
    var childMapping = {};
    for (var nextKey in next2) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
      return React.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, "appear", props),
        enter: getProp(child, "enter", props),
        exit: getProp(child, "exit", props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
      var child = children[key];
      if (!React.isValidElement(child))
        return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = React.isValidElement(prevChild) && !prevChild.props.in;
      if (hasNext && (!hasPrev || isLeaving)) {
        children[key] = React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        children[key] = React.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && React.isValidElement(prevChild)) {
        children[key] = React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      }
    });
    return children;
  }
  var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k2) {
      return obj[k2];
    });
  };
  var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
  };
  var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node2) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping)
        return;
      if (child.props.onExited) {
        child.props.onExited(node2);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children = _extends({}, state.children);
          delete children[child.key];
          return {
            children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory2);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component === null) {
        return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ React.createElement(Component, props, children));
    };
    return TransitionGroup2;
  }(React.Component);
  TransitionGroup.propTypes = {};
  TransitionGroup.defaultProps = defaultProps;
  const TransitionGroup$1 = TransitionGroup;
  function Ripple(props) {
    const {
      className,
      classes,
      pulsate = false,
      rippleX,
      rippleY,
      rippleSize,
      in: inProp,
      onExited,
      timeout
    } = props;
    const [leaving, setLeaving] = React__namespace.useState(false);
    const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    if (!inProp && !leaving) {
      setLeaving(true);
    }
    React__namespace.useEffect(() => {
      if (!inProp && onExited != null) {
        const timeoutId = setTimeout(onExited, timeout);
        return () => {
          clearTimeout(timeoutId);
        };
      }
      return void 0;
    }, [onExited, inProp, timeout]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: rippleClassName,
      style: rippleStyles,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: childClassName
      })
    });
  }
  const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
  const touchRippleClasses$1 = touchRippleClasses;
  const _excluded$1K = ["center", "classes", "className"];
  let _$2 = (t2) => t2, _t$2, _t2$2, _t3$2, _t4$2;
  const DURATION = 550;
  const DELAY_RIPPLE = 80;
  const enterKeyframe = keyframes(_t$2 || (_t$2 = _$2`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
  const exitKeyframe = keyframes(_t2$2 || (_t2$2 = _$2`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
  const pulsateKeyframe = keyframes(_t3$2 || (_t3$2 = _$2`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
  const TouchRippleRoot = styled$1("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  });
  const TouchRippleRipple = styled$1(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })(_t4$2 || (_t4$2 = _$2`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
    theme
  }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
    theme
  }) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
    theme
  }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
    theme
  }) => theme.transitions.easing.easeInOut);
  const TouchRipple = /* @__PURE__ */ React__namespace.forwardRef(function TouchRipple2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTouchRipple"
    });
    const {
      center: centerProp = false,
      classes = {},
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1K);
    const [ripples, setRipples] = React__namespace.useState([]);
    const nextKey = React__namespace.useRef(0);
    const rippleCallback = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]);
    const ignoringMouseDown = React__namespace.useRef(false);
    const startTimer = React__namespace.useRef(0);
    const startTimerCommit = React__namespace.useRef(null);
    const container = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
      return () => {
        if (startTimer.current) {
          clearTimeout(startTimer.current);
        }
      };
    }, []);
    const startCommit = React__namespace.useCallback((params) => {
      const {
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      } = params;
      setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
        classes: {
          ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
          rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
          ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
          child: clsx(classes.child, touchRippleClasses$1.child),
          childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
          childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
        },
        timeout: DURATION,
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize
      }, nextKey.current)]);
      nextKey.current += 1;
      rippleCallback.current = cb;
    }, [classes]);
    const start2 = React__namespace.useCallback((event = {}, options = {}, cb = () => {
    }) => {
      const {
        pulsate: pulsate2 = false,
        center = centerProp || options.pulsate,
        fakeElement = false
        // For test purposes
      } = options;
      if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }
      if ((event == null ? void 0 : event.type) === "touchstart") {
        ignoringMouseDown.current = true;
      }
      const element = fakeElement ? null : container.current;
      const rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let rippleX;
      let rippleY;
      let rippleSize;
      if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        const {
          clientX,
          clientY
        } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }
      if (center) {
        rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
      }
      if (event != null && event.touches) {
        if (startTimerCommit.current === null) {
          startTimerCommit.current = () => {
            startCommit({
              pulsate: pulsate2,
              rippleX,
              rippleY,
              rippleSize,
              cb
            });
          };
          startTimer.current = setTimeout(() => {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          }, DELAY_RIPPLE);
        }
      } else {
        startCommit({
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb
        });
      }
    }, [centerProp, startCommit]);
    const pulsate = React__namespace.useCallback(() => {
      start2({}, {
        pulsate: true
      });
    }, [start2]);
    const stop = React__namespace.useCallback((event, cb) => {
      clearTimeout(startTimer.current);
      if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.current = setTimeout(() => {
          stop(event, cb);
        });
        return;
      }
      startTimerCommit.current = null;
      setRipples((oldRipples) => {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }
        return oldRipples;
      });
      rippleCallback.current = cb;
    }, []);
    React__namespace.useImperativeHandle(ref, () => ({
      pulsate,
      start: start2,
      stop
    }), [pulsate, start2, stop]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends({
      className: clsx(touchRippleClasses$1.root, classes.root, className),
      ref: container
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
        component: null,
        exit: true,
        children: ripples
      })
    }));
  });
  const TouchRipple$1 = TouchRipple;
  function getButtonBaseUtilityClass(slot) {
    return generateUtilityClass("MuiButtonBase", slot);
  }
  const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
  const buttonBaseClasses$1 = buttonBaseClasses;
  const _excluded$1J = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
  const useUtilityClasses$1i = (ownerState) => {
    const {
      disabled,
      focusVisible,
      focusVisibleClassName,
      classes
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
    };
    const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
    if (focusVisible && focusVisibleClassName) {
      composedClasses.root += ` ${focusVisibleClassName}`;
    }
    return composedClasses;
  };
  const ButtonBaseRoot = styled$1("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${buttonBaseClasses$1.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  });
  const ButtonBase = /* @__PURE__ */ React__namespace.forwardRef(function ButtonBase2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiButtonBase"
    });
    const {
      action,
      centerRipple = false,
      children,
      className,
      component = "button",
      disabled = false,
      disableRipple = false,
      disableTouchRipple = false,
      focusRipple = false,
      LinkComponent = "a",
      onBlur,
      onClick,
      onContextMenu,
      onDragLeave,
      onFocus,
      onFocusVisible,
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseLeave,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      tabIndex = 0,
      TouchRippleProps,
      touchRippleRef,
      type
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1J);
    const buttonRef = React__namespace.useRef(null);
    const rippleRef = React__namespace.useRef(null);
    const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
    const {
      isFocusVisibleRef,
      onFocus: handleFocusVisible,
      onBlur: handleBlurVisible,
      ref: focusVisibleRef
    } = useIsFocusVisible();
    const [focusVisible, setFocusVisible] = React__namespace.useState(false);
    if (disabled && focusVisible) {
      setFocusVisible(false);
    }
    React__namespace.useImperativeHandle(action, () => ({
      focusVisible: () => {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    }), []);
    const [mountedState, setMountedState] = React__namespace.useState(false);
    React__namespace.useEffect(() => {
      setMountedState(true);
    }, []);
    const enableTouchRipple = mountedState && !disableRipple && !disabled;
    React__namespace.useEffect(() => {
      if (focusVisible && focusRipple && !disableRipple && mountedState) {
        rippleRef.current.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible, mountedState]);
    function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
      return useEventCallback((event) => {
        if (eventCallback) {
          eventCallback(event);
        }
        const ignore = skipRippleAction;
        if (!ignore && rippleRef.current) {
          rippleRef.current[rippleAction](event);
        }
        return true;
      });
    }
    const handleMouseDown = useRippleHandler("start", onMouseDown);
    const handleContextMenu = useRippleHandler("stop", onContextMenu);
    const handleDragLeave = useRippleHandler("stop", onDragLeave);
    const handleMouseUp = useRippleHandler("stop", onMouseUp);
    const handleMouseLeave = useRippleHandler("stop", (event) => {
      if (focusVisible) {
        event.preventDefault();
      }
      if (onMouseLeave) {
        onMouseLeave(event);
      }
    });
    const handleTouchStart = useRippleHandler("start", onTouchStart);
    const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
    const handleTouchMove = useRippleHandler("stop", onTouchMove);
    const handleBlur = useRippleHandler("stop", (event) => {
      handleBlurVisible(event);
      if (isFocusVisibleRef.current === false) {
        setFocusVisible(false);
      }
      if (onBlur) {
        onBlur(event);
      }
    }, false);
    const handleFocus = useEventCallback((event) => {
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }
      handleFocusVisible(event);
      if (isFocusVisibleRef.current === true) {
        setFocusVisible(true);
        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }
      if (onFocus) {
        onFocus(event);
      }
    });
    const isNonNativeButton = () => {
      const button = buttonRef.current;
      return component && component !== "button" && !(button.tagName === "A" && button.href);
    };
    const keydownRef = React__namespace.useRef(false);
    const handleKeyDown2 = useEventCallback((event) => {
      if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
        keydownRef.current = true;
        rippleRef.current.stop(event, () => {
          rippleRef.current.start(event);
        });
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
        event.preventDefault();
        if (onClick) {
          onClick(event);
        }
      }
    });
    const handleKeyUp = useEventCallback((event) => {
      if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
        keydownRef.current = false;
        rippleRef.current.stop(event, () => {
          rippleRef.current.pulsate(event);
        });
      }
      if (onKeyUp) {
        onKeyUp(event);
      }
      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
        onClick(event);
      }
    });
    let ComponentProp = component;
    if (ComponentProp === "button" && (other.href || other.to)) {
      ComponentProp = LinkComponent;
    }
    const buttonProps = {};
    if (ComponentProp === "button") {
      buttonProps.type = type === void 0 ? "button" : type;
      buttonProps.disabled = disabled;
    } else {
      if (!other.href && !other.to) {
        buttonProps.role = "button";
      }
      if (disabled) {
        buttonProps["aria-disabled"] = disabled;
      }
    }
    const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
    const ownerState = _extends({}, props, {
      centerRipple,
      component,
      disabled,
      disableRipple,
      disableTouchRipple,
      focusRipple,
      tabIndex,
      focusVisible
    });
    const classes = useUtilityClasses$1i(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends({
      as: ComponentProp,
      className: clsx(classes.root, className),
      ownerState,
      onBlur: handleBlur,
      onClick,
      onContextMenu: handleContextMenu,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown2,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex,
      type
    }, buttonProps, other, {
      children: [children, enableTouchRipple ? (
        /* TouchRipple is only needed client-side, x2 boost on the server. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends({
          ref: handleRippleRef,
          center: centerRipple
        }, TouchRippleProps))
      ) : null]
    }));
  });
  const ButtonBase$1 = ButtonBase;
  function getFabUtilityClass(slot) {
    return generateUtilityClass("MuiFab", slot);
  }
  const fabClasses = generateUtilityClasses("MuiFab", ["root", "primary", "secondary", "extended", "circular", "focusVisible", "disabled", "colorInherit", "sizeSmall", "sizeMedium", "sizeLarge", "info", "error", "warning", "success"]);
  const fabClasses$1 = fabClasses;
  const _excluded$1I = ["children", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"];
  const useUtilityClasses$1h = (ownerState) => {
    const {
      color: color2,
      variant,
      classes,
      size
    } = ownerState;
    const slots = {
      root: ["root", variant, `size${capitalize(size)}`, color2 === "inherit" ? "colorInherit" : color2]
    };
    const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const FabRoot = styled$1(ButtonBase$1, {
    name: "MuiFab",
    slot: "Root",
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, styles2[capitalize(ownerState.size)], styles2[ownerState.color]];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$palette$getCon, _theme$palette;
    return _extends({}, theme.typography.button, {
      minHeight: 36,
      transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
        duration: theme.transitions.duration.short
      }),
      borderRadius: "50%",
      padding: 0,
      minWidth: 0,
      width: 56,
      height: 56,
      zIndex: (theme.vars || theme).zIndex.fab,
      boxShadow: (theme.vars || theme).shadows[6],
      "&:active": {
        boxShadow: (theme.vars || theme).shadows[12]
      },
      color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
      backgroundColor: (theme.vars || theme).palette.grey[300],
      "&:hover": {
        backgroundColor: (theme.vars || theme).palette.grey.A100,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette.grey[300]
        },
        textDecoration: "none"
      },
      [`&.${fabClasses$1.focusVisible}`]: {
        boxShadow: (theme.vars || theme).shadows[6]
      }
    }, ownerState.size === "small" && {
      width: 40,
      height: 40
    }, ownerState.size === "medium" && {
      width: 48,
      height: 48
    }, ownerState.variant === "extended" && {
      borderRadius: 48 / 2,
      padding: "0 16px",
      width: "auto",
      minHeight: "auto",
      minWidth: 48,
      height: 48
    }, ownerState.variant === "extended" && ownerState.size === "small" && {
      width: "auto",
      padding: "0 8px",
      borderRadius: 34 / 2,
      minWidth: 34,
      height: 34
    }, ownerState.variant === "extended" && ownerState.size === "medium" && {
      width: "auto",
      padding: "0 16px",
      borderRadius: 40 / 2,
      minWidth: 40,
      height: 40
    }, ownerState.color === "inherit" && {
      color: "inherit"
    });
  }, ({
    theme,
    ownerState
  }) => _extends({}, ownerState.color !== "inherit" && ownerState.color !== "default" && (theme.vars || theme).palette[ownerState.color] != null && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
    "&:hover": {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }
  }), ({
    theme
  }) => ({
    [`&.${fabClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    }
  }));
  const Fab = /* @__PURE__ */ React__namespace.forwardRef(function Fab2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiFab"
    });
    const {
      children,
      className,
      color: color2 = "default",
      component = "button",
      disabled = false,
      disableFocusRipple = false,
      focusVisibleClassName,
      size = "large",
      variant = "circular"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1I);
    const ownerState = _extends({}, props, {
      color: color2,
      component,
      disabled,
      disableFocusRipple,
      size,
      variant
    });
    const classes = useUtilityClasses$1h(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FabRoot, _extends({
      className: clsx(classes.root, className),
      component,
      disabled,
      focusRipple: !disableFocusRipple,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ownerState,
      ref
    }, other, {
      classes,
      children
    }));
  });
  const Fab$1 = Fab;
  var ListRounded = {};
  var interopRequireDefault = { exports: {} };
  (function(module) {
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(interopRequireDefault);
  var interopRequireDefaultExports = interopRequireDefault.exports;
  var createSvgIcon$1 = {};
  function getSvgIconUtilityClass(slot) {
    return generateUtilityClass("MuiSvgIcon", slot);
  }
  generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const _excluded$1H = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
  const useUtilityClasses$1g = (ownerState) => {
    const {
      color: color2,
      fontSize,
      classes
    } = ownerState;
    const slots = {
      root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
    };
    return composeClasses(slots, getSvgIconUtilityClass, classes);
  };
  const SvgIconRoot = styled$1("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      // the <svg> will define the property that has `currentColor`
      // e.g. heroicons uses fill="none" and stroke="currentColor"
      fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
        duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
      }),
      fontSize: {
        inherit: "inherit",
        small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
        medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
        large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
      }[ownerState.fontSize],
      // TODO v5 deprecate, v6 remove for sx
      color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
        action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
        disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
        inherit: void 0
      }[ownerState.color]
    };
  });
  const SvgIcon = /* @__PURE__ */ React__namespace.forwardRef(function SvgIcon2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiSvgIcon"
    });
    const {
      children,
      className,
      color: color2 = "inherit",
      component = "svg",
      fontSize = "medium",
      htmlColor,
      inheritViewBox = false,
      titleAccess,
      viewBox = "0 0 24 24"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1H);
    const hasSvgAsChild = /* @__PURE__ */ React__namespace.isValidElement(children) && children.type === "svg";
    const ownerState = _extends({}, props, {
      color: color2,
      component,
      fontSize,
      instanceFontSize: inProps.fontSize,
      inheritViewBox,
      viewBox,
      hasSvgAsChild
    });
    const more = {};
    if (!inheritViewBox) {
      more.viewBox = viewBox;
    }
    const classes = useUtilityClasses$1g(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends({
      as: component,
      className: clsx(classes.root, className),
      focusable: "false",
      color: htmlColor,
      "aria-hidden": titleAccess ? void 0 : true,
      role: titleAccess ? "img" : void 0,
      ref
    }, more, other, hasSvgAsChild && children.props, {
      ownerState,
      children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
        children: titleAccess
      }) : null]
    }));
  });
  SvgIcon.muiName = "SvgIcon";
  const SvgIcon$1 = SvgIcon;
  function createSvgIcon(path, displayName) {
    function Component(props, ref) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon$1, _extends({
        "data-testid": `${displayName}Icon`,
        ref
      }, props, {
        children: path
      }));
    }
    Component.muiName = SvgIcon$1.muiName;
    return /* @__PURE__ */ React__namespace.memo(/* @__PURE__ */ React__namespace.forwardRef(Component));
  }
  const unstable_ClassNameGenerator = {
    configure: (generator) => {
      ClassNameGenerator$1.configure(generator);
    }
  };
  const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    capitalize,
    createChainedFunction,
    createSvgIcon,
    debounce: debounce$1,
    deprecatedPropType,
    isMuiElement,
    ownerDocument,
    ownerWindow,
    requirePropFactory,
    setRef,
    unstable_ClassNameGenerator,
    unstable_useEnhancedEffect: useEnhancedEffect$1,
    unstable_useId: useId,
    unsupportedProp,
    useControlled,
    useEventCallback,
    useForkRef,
    useIsFocusVisible
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils$1);
  var hasRequiredCreateSvgIcon;
  function requireCreateSvgIcon() {
    if (hasRequiredCreateSvgIcon)
      return createSvgIcon$1;
    hasRequiredCreateSvgIcon = 1;
    (function(exports) {
      "use client";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function() {
          return _utils.createSvgIcon;
        }
      });
      var _utils = require$$0;
    })(createSvgIcon$1);
    return createSvgIcon$1;
  }
  var _interopRequireDefault = interopRequireDefaultExports;
  Object.defineProperty(ListRounded, "__esModule", {
    value: true
  });
  var default_1 = ListRounded.default = void 0;
  var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
  var _jsxRuntime = jsxRuntimeExports;
  var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
    d: "M4 13c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-8c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm4 4h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm0 4h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zM7 8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1zm-3 5c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-8c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm4 4h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm0 4h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zM7 8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1z"
  }), "ListRounded");
  default_1 = ListRounded.default = _default;
  function getUnit(input) {
    return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
  }
  function toUnitless(length2) {
    return parseFloat(length2);
  }
  function useTheme() {
    const theme = useTheme$1(defaultTheme$2);
    return theme[THEME_ID] || theme;
  }
  const getOverlayAlpha = (elevation) => {
    let alphaValue;
    if (elevation < 1) {
      alphaValue = 5.11916 * elevation ** 2;
    } else {
      alphaValue = 4.5 * Math.log(elevation + 1) + 2;
    }
    return (alphaValue / 100).toFixed(2);
  };
  const getOverlayAlpha$1 = getOverlayAlpha;
  const defaultTheme = createTheme();
  const Box = createBox({
    themeId: THEME_ID,
    defaultTheme,
    defaultClassName: "MuiBox-root",
    generateClassName: ClassNameGenerator$1.generate
  });
  const Box$1 = Box;
  function isHostComponent(element) {
    return typeof element === "string";
  }
  function appendOwnerState(elementType, otherProps, ownerState) {
    if (elementType === void 0 || isHostComponent(elementType)) {
      return otherProps;
    }
    return _extends({}, otherProps, {
      ownerState: _extends({}, otherProps.ownerState, ownerState)
    });
  }
  const defaultContextValue = {
    disableDefaultClasses: false
  };
  const ClassNameConfiguratorContext = /* @__PURE__ */ React__namespace.createContext(defaultContextValue);
  function useClassNamesOverride(generateUtilityClass2) {
    const {
      disableDefaultClasses
    } = React__namespace.useContext(ClassNameConfiguratorContext);
    return (slot) => {
      if (disableDefaultClasses) {
        return "";
      }
      return generateUtilityClass2(slot);
    };
  }
  function extractEventHandlers(object, excludeKeys = []) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  function resolveComponentProps(componentProps, ownerState, slotState) {
    if (typeof componentProps === "function") {
      return componentProps(ownerState, slotState);
    }
    return componentProps;
  }
  function omitEventHandlers(object) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  function mergeSlotProps(parameters) {
    const {
      getSlotProps,
      additionalProps,
      externalSlotProps,
      externalForwardedProps,
      className
    } = parameters;
    if (!getSlotProps) {
      const joinedClasses2 = clsx(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
      const mergedStyle2 = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props2 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
      if (joinedClasses2.length > 0) {
        props2.className = joinedClasses2;
      }
      if (Object.keys(mergedStyle2).length > 0) {
        props2.style = mergedStyle2;
      }
      return {
        props: props2,
        internalRef: void 0
      };
    }
    const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
    const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
    const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
    const internalSlotProps = getSlotProps(eventHandlers);
    const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: internalSlotProps.ref
    };
  }
  const _excluded$1G = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
  function useSlotProps(parameters) {
    var _parameters$additiona;
    const {
      elementType,
      externalSlotProps,
      ownerState,
      skipResolvingSlotProps = false
    } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$1G);
    const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
    const {
      props: mergedProps,
      internalRef
    } = mergeSlotProps(_extends({}, rest, {
      externalSlotProps: resolvedComponentsProps
    }));
    const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
    const props = appendOwnerState(elementType, _extends({}, mergedProps, {
      ref
    }), ownerState);
    return props;
  }
  function isOverflowing(container) {
    const doc = ownerDocument(container);
    if (doc.body === container) {
      return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
    }
    return container.scrollHeight > container.clientHeight;
  }
  function ariaHidden(element, show) {
    if (show) {
      element.setAttribute("aria-hidden", "true");
    } else {
      element.removeAttribute("aria-hidden");
    }
  }
  function getPaddingRight(element) {
    return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
  }
  function isAriaHiddenForbiddenOnElement(element) {
    const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
    const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
    const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
    return isForbiddenTagName || isInputHidden;
  }
  function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
    const blacklist = [mountElement, currentElement, ...elementsToExclude];
    [].forEach.call(container.children, (element) => {
      const isNotExcludedElement = blacklist.indexOf(element) === -1;
      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
      if (isNotExcludedElement && isNotForbiddenElement) {
        ariaHidden(element, show);
      }
    });
  }
  function findIndexOf(items2, callback) {
    let idx = -1;
    items2.some((item, index) => {
      if (callback(item)) {
        idx = index;
        return true;
      }
      return false;
    });
    return idx;
  }
  function handleContainer(containerInfo, props) {
    const restoreStyle = [];
    const container = containerInfo.container;
    if (!props.disableScrollLock) {
      if (isOverflowing(container)) {
        const scrollbarSize = getScrollbarSize(ownerDocument(container));
        restoreStyle.push({
          value: container.style.paddingRight,
          property: "padding-right",
          el: container
        });
        container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
        const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
        [].forEach.call(fixedElements2, (element) => {
          restoreStyle.push({
            value: element.style.paddingRight,
            property: "padding-right",
            el: element
          });
          element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
        });
      }
      let scrollContainer;
      if (container.parentNode instanceof DocumentFragment) {
        scrollContainer = ownerDocument(container).body;
      } else {
        const parent = container.parentElement;
        const containerWindow = ownerWindow(container);
        scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
      }
      restoreStyle.push({
        value: scrollContainer.style.overflow,
        property: "overflow",
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowX,
        property: "overflow-x",
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowY,
        property: "overflow-y",
        el: scrollContainer
      });
      scrollContainer.style.overflow = "hidden";
    }
    const restore = () => {
      restoreStyle.forEach(({
        value,
        el,
        property
      }) => {
        if (value) {
          el.style.setProperty(property, value);
        } else {
          el.style.removeProperty(property);
        }
      });
    };
    return restore;
  }
  function getHiddenSiblings(container) {
    const hiddenSiblings = [];
    [].forEach.call(container.children, (element) => {
      if (element.getAttribute("aria-hidden") === "true") {
        hiddenSiblings.push(element);
      }
    });
    return hiddenSiblings;
  }
  class ModalManager {
    constructor() {
      this.containers = void 0;
      this.modals = void 0;
      this.modals = [];
      this.containers = [];
    }
    add(modal, container) {
      let modalIndex = this.modals.indexOf(modal);
      if (modalIndex !== -1) {
        return modalIndex;
      }
      modalIndex = this.modals.length;
      this.modals.push(modal);
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }
      const hiddenSiblings = getHiddenSiblings(container);
      ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
      const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }
      this.containers.push({
        modals: [modal],
        container,
        restore: null,
        hiddenSiblings
      });
      return modalIndex;
    }
    mount(modal, props) {
      const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
      const containerInfo = this.containers[containerIndex];
      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }
    remove(modal, ariaHiddenState = true) {
      const modalIndex = this.modals.indexOf(modal);
      if (modalIndex === -1) {
        return modalIndex;
      }
      const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
      const containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1);
      if (containerInfo.modals.length === 0) {
        if (containerInfo.restore) {
          containerInfo.restore();
        }
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, ariaHiddenState);
        }
        ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
        this.containers.splice(containerIndex, 1);
      } else {
        const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }
      return modalIndex;
    }
    isTopModal(modal) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }
  }
  function getContainer$1(container) {
    return typeof container === "function" ? container() : container;
  }
  function getHasTransition(children) {
    return children ? children.props.hasOwnProperty("in") : false;
  }
  const defaultManager = new ModalManager();
  function useModal(parameters) {
    const {
      container,
      disableEscapeKeyDown = false,
      disableScrollLock = false,
      // @ts-ignore internal logic - Base UI supports the manager as a prop too
      manager = defaultManager,
      closeAfterTransition = false,
      onTransitionEnter,
      onTransitionExited,
      children,
      onClose,
      open,
      rootRef
    } = parameters;
    const modal = React__namespace.useRef({});
    const mountNodeRef = React__namespace.useRef(null);
    const modalRef = React__namespace.useRef(null);
    const handleRef = useForkRef(modalRef, rootRef);
    const [exited, setExited] = React__namespace.useState(!open);
    const hasTransition = getHasTransition(children);
    let ariaHiddenProp = true;
    if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
      ariaHiddenProp = false;
    }
    const getDoc = () => ownerDocument(mountNodeRef.current);
    const getModal = () => {
      modal.current.modalRef = modalRef.current;
      modal.current.mount = mountNodeRef.current;
      return modal.current;
    };
    const handleMounted = () => {
      manager.mount(getModal(), {
        disableScrollLock
      });
      if (modalRef.current) {
        modalRef.current.scrollTop = 0;
      }
    };
    const handleOpen = useEventCallback(() => {
      const resolvedContainer = getContainer$1(container) || getDoc().body;
      manager.add(getModal(), resolvedContainer);
      if (modalRef.current) {
        handleMounted();
      }
    });
    const isTopModal = React__namespace.useCallback(() => manager.isTopModal(getModal()), [manager]);
    const handlePortalRef = useEventCallback((node2) => {
      mountNodeRef.current = node2;
      if (!node2) {
        return;
      }
      if (open && isTopModal()) {
        handleMounted();
      } else if (modalRef.current) {
        ariaHidden(modalRef.current, ariaHiddenProp);
      }
    });
    const handleClose = React__namespace.useCallback(() => {
      manager.remove(getModal(), ariaHiddenProp);
    }, [ariaHiddenProp, manager]);
    React__namespace.useEffect(() => {
      return () => {
        handleClose();
      };
    }, [handleClose]);
    React__namespace.useEffect(() => {
      if (open) {
        handleOpen();
      } else if (!hasTransition || !closeAfterTransition) {
        handleClose();
      }
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
    const createHandleKeyDown = (otherHandlers) => (event) => {
      var _otherHandlers$onKeyD;
      (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
      if (event.key !== "Escape" || !isTopModal()) {
        return;
      }
      if (!disableEscapeKeyDown) {
        event.stopPropagation();
        if (onClose) {
          onClose(event, "escapeKeyDown");
        }
      }
    };
    const createHandleBackdropClick = (otherHandlers) => (event) => {
      var _otherHandlers$onClic;
      (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
      if (event.target !== event.currentTarget) {
        return;
      }
      if (onClose) {
        onClose(event, "backdropClick");
      }
    };
    const getRootProps = (otherHandlers = {}) => {
      const propsEventHandlers = extractEventHandlers(parameters);
      delete propsEventHandlers.onTransitionEnter;
      delete propsEventHandlers.onTransitionExited;
      const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
      return _extends({
        role: "presentation"
      }, externalEventHandlers, {
        onKeyDown: createHandleKeyDown(externalEventHandlers),
        ref: handleRef
      });
    };
    const getBackdropProps = (otherHandlers = {}) => {
      const externalEventHandlers = otherHandlers;
      return _extends({
        "aria-hidden": true
      }, externalEventHandlers, {
        onClick: createHandleBackdropClick(externalEventHandlers),
        open
      });
    };
    const getTransitionProps2 = () => {
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      return {
        onEnter: createChainedFunction(handleEnter, children.props.onEnter),
        onExited: createChainedFunction(handleExited, children.props.onExited)
      };
    };
    return {
      getRootProps,
      getBackdropProps,
      getTransitionProps: getTransitionProps2,
      rootRef: handleRef,
      portalRef: handlePortalRef,
      isTopModal,
      exited,
      hasTransition
    };
  }
  function useBadge(parameters) {
    const {
      badgeContent: badgeContentProp,
      invisible: invisibleProp = false,
      max: maxProp = 99,
      showZero = false
    } = parameters;
    const prevProps = usePreviousProps$1({
      badgeContent: badgeContentProp,
      max: maxProp
    });
    let invisible = invisibleProp;
    if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
      invisible = true;
    }
    const {
      badgeContent,
      max: max2 = maxProp
    } = invisible ? prevProps : parameters;
    const displayValue = badgeContent && Number(badgeContent) > max2 ? `${max2}+` : badgeContent;
    return {
      badgeContent,
      invisible,
      max: max2,
      displayValue
    };
  }
  function mapEventPropToEvent(eventProp) {
    return eventProp.substring(2).toLowerCase();
  }
  function clickedRootScrollbar(event, doc) {
    return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
  }
  function ClickAwayListener(props) {
    const {
      children,
      disableReactTree = false,
      mouseEvent = "onClick",
      onClickAway,
      touchEvent = "onTouchEnd"
    } = props;
    const movedRef = React__namespace.useRef(false);
    const nodeRef = React__namespace.useRef(null);
    const activatedRef = React__namespace.useRef(false);
    const syntheticEventRef = React__namespace.useRef(false);
    React__namespace.useEffect(() => {
      setTimeout(() => {
        activatedRef.current = true;
      }, 0);
      return () => {
        activatedRef.current = false;
      };
    }, []);
    const handleRef = useForkRef(
      // @ts-expect-error TODO upstream fix
      children.ref,
      nodeRef
    );
    const handleClickAway = useEventCallback((event) => {
      const insideReactTree = syntheticEventRef.current;
      syntheticEventRef.current = false;
      const doc = ownerDocument(nodeRef.current);
      if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
        return;
      }
      if (movedRef.current) {
        movedRef.current = false;
        return;
      }
      let insideDOM;
      if (event.composedPath) {
        insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
      } else {
        insideDOM = !doc.documentElement.contains(
          // @ts-expect-error returns `false` as intended when not dispatched from a Node
          event.target
        ) || nodeRef.current.contains(
          // @ts-expect-error returns `false` as intended when not dispatched from a Node
          event.target
        );
      }
      if (!insideDOM && (disableReactTree || !insideReactTree)) {
        onClickAway(event);
      }
    });
    const createHandleSynthetic = (handlerName) => (event) => {
      syntheticEventRef.current = true;
      const childrenPropsHandler = children.props[handlerName];
      if (childrenPropsHandler) {
        childrenPropsHandler(event);
      }
    };
    const childrenProps = {
      ref: handleRef
    };
    if (touchEvent !== false) {
      childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
    }
    React__namespace.useEffect(() => {
      if (touchEvent !== false) {
        const mappedTouchEvent = mapEventPropToEvent(touchEvent);
        const doc = ownerDocument(nodeRef.current);
        const handleTouchMove = () => {
          movedRef.current = true;
        };
        doc.addEventListener(mappedTouchEvent, handleClickAway);
        doc.addEventListener("touchmove", handleTouchMove);
        return () => {
          doc.removeEventListener(mappedTouchEvent, handleClickAway);
          doc.removeEventListener("touchmove", handleTouchMove);
        };
      }
      return void 0;
    }, [handleClickAway, touchEvent]);
    if (mouseEvent !== false) {
      childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
    }
    React__namespace.useEffect(() => {
      if (mouseEvent !== false) {
        const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
        const doc = ownerDocument(nodeRef.current);
        doc.addEventListener(mappedMouseEvent, handleClickAway);
        return () => {
          doc.removeEventListener(mappedMouseEvent, handleClickAway);
        };
      }
      return void 0;
    }, [handleClickAway, mouseEvent]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React__namespace.Fragment, {
      children: /* @__PURE__ */ React__namespace.cloneElement(children, childrenProps)
    });
  }
  const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
  function getTabIndex(node2) {
    const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
    if (!Number.isNaN(tabindexAttr)) {
      return tabindexAttr;
    }
    if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
      return 0;
    }
    return node2.tabIndex;
  }
  function isNonTabbableRadio(node2) {
    if (node2.tagName !== "INPUT" || node2.type !== "radio") {
      return false;
    }
    if (!node2.name) {
      return false;
    }
    const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
    let roving = getRadio(`[name="${node2.name}"]:checked`);
    if (!roving) {
      roving = getRadio(`[name="${node2.name}"]`);
    }
    return roving !== node2;
  }
  function isNodeMatchingSelectorFocusable(node2) {
    if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
      return false;
    }
    return true;
  }
  function defaultGetTabbable(root) {
    const regularTabNodes = [];
    const orderedTabNodes = [];
    Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
      const nodeTabIndex = getTabIndex(node2);
      if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
        return;
      }
      if (nodeTabIndex === 0) {
        regularTabNodes.push(node2);
      } else {
        orderedTabNodes.push({
          documentOrder: i,
          tabIndex: nodeTabIndex,
          node: node2
        });
      }
    });
    return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
  }
  function defaultIsEnabled() {
    return true;
  }
  function FocusTrap(props) {
    const {
      children,
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableRestoreFocus = false,
      getTabbable = defaultGetTabbable,
      isEnabled: isEnabled2 = defaultIsEnabled,
      open
    } = props;
    const ignoreNextEnforceFocus = React__namespace.useRef(false);
    const sentinelStart = React__namespace.useRef(null);
    const sentinelEnd = React__namespace.useRef(null);
    const nodeToRestore = React__namespace.useRef(null);
    const reactFocusEventTarget = React__namespace.useRef(null);
    const activated = React__namespace.useRef(false);
    const rootRef = React__namespace.useRef(null);
    const handleRef = useForkRef(children.ref, rootRef);
    const lastKeydown = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      activated.current = !disableAutoFocus;
    }, [disableAutoFocus, open]);
    React__namespace.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      const doc = ownerDocument(rootRef.current);
      if (!rootRef.current.contains(doc.activeElement)) {
        if (!rootRef.current.hasAttribute("tabIndex")) {
          rootRef.current.setAttribute("tabIndex", "-1");
        }
        if (activated.current) {
          rootRef.current.focus();
        }
      }
      return () => {
        if (!disableRestoreFocus) {
          if (nodeToRestore.current && nodeToRestore.current.focus) {
            ignoreNextEnforceFocus.current = true;
            nodeToRestore.current.focus();
          }
          nodeToRestore.current = null;
        }
      };
    }, [open]);
    React__namespace.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      const doc = ownerDocument(rootRef.current);
      const contain = (nativeEvent) => {
        const {
          current: rootElement
        } = rootRef;
        if (rootElement === null) {
          return;
        }
        if (!doc.hasFocus() || disableEnforceFocus || !isEnabled2() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = false;
          return;
        }
        if (!rootElement.contains(doc.activeElement)) {
          if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
            reactFocusEventTarget.current = null;
          } else if (reactFocusEventTarget.current !== null) {
            return;
          }
          if (!activated.current) {
            return;
          }
          let tabbable = [];
          if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
            tabbable = getTabbable(rootRef.current);
          }
          if (tabbable.length > 0) {
            var _lastKeydown$current, _lastKeydown$current2;
            const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
            const focusNext = tabbable[0];
            const focusPrevious = tabbable[tabbable.length - 1];
            if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
              if (isShiftTab) {
                focusPrevious.focus();
              } else {
                focusNext.focus();
              }
            }
          } else {
            rootElement.focus();
          }
        }
      };
      const loopFocus = (nativeEvent) => {
        lastKeydown.current = nativeEvent;
        if (disableEnforceFocus || !isEnabled2() || nativeEvent.key !== "Tab") {
          return;
        }
        if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
          ignoreNextEnforceFocus.current = true;
          if (sentinelEnd.current) {
            sentinelEnd.current.focus();
          }
        }
      };
      doc.addEventListener("focusin", contain);
      doc.addEventListener("keydown", loopFocus, true);
      const interval = setInterval(() => {
        if (doc.activeElement && doc.activeElement.tagName === "BODY") {
          contain(null);
        }
      }, 50);
      return () => {
        clearInterval(interval);
        doc.removeEventListener("focusin", contain);
        doc.removeEventListener("keydown", loopFocus, true);
      };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled2, open, getTabbable]);
    const onFocus = (event) => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }
      activated.current = true;
      reactFocusEventTarget.current = event.target;
      const childrenPropsHandler = children.props.onFocus;
      if (childrenPropsHandler) {
        childrenPropsHandler(event);
      }
    };
    const handleFocusSentinel = (event) => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }
      activated.current = true;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        tabIndex: open ? 0 : -1,
        onFocus: handleFocusSentinel,
        ref: sentinelStart,
        "data-testid": "sentinelStart"
      }), /* @__PURE__ */ React__namespace.cloneElement(children, {
        ref: handleRef,
        onFocus
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        tabIndex: open ? 0 : -1,
        onFocus: handleFocusSentinel,
        ref: sentinelEnd,
        "data-testid": "sentinelEnd"
      })]
    });
  }
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getWindow(node2) {
    if (node2 == null) {
      return window;
    }
    if (node2.toString() !== "[object Window]") {
      var ownerDocument2 = node2.ownerDocument;
      return ownerDocument2 ? ownerDocument2.defaultView || window : window;
    }
    return node2;
  }
  function isElement(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
  }
  function isHTMLElement$1(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
  }
  function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
  }
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement$1(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  const applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"]
  };
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  var max = Math.max;
  var min = Math.min;
  var round$1 = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement$1(element)) {
      scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
      width: width2,
      height: height2,
      top: y2,
      right: x2 + width2,
      bottom: y2 + height2,
      left: x2,
      x: x2,
      y: y2
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
      height2 = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height: height2
    };
  }
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next2 = child;
      do {
        if (next2 && parent.isSameNode(next2)) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      } while (next2);
    }
    return false;
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement$1(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css2 = getComputedStyle(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min2, value, max2) {
    var v2 = within(min2, value, max2);
    return v2 > max2 ? max2 : v2;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  var toPaddingObject = function toPaddingObject2(padding2, state) {
    padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding2;
    return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect$1(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  const arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x2 = _ref.x, y2 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round$1(x2 * dpr) / dpr || 0,
      y: round$1(y2 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x2,
      y: y2
    }) : {
      x: x2,
      y: y2
    };
    x2 = _ref3.x;
    y2 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y2 -= offsetY - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x2 -= offsetX - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position2
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x2,
      y: y2
    }, getWindow(popper2)) : {
      x: x2,
      y: y2
    };
    x2 = _ref4.x;
    y2 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  const computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  const eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash$1[matched];
    });
  }
  var hash = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash[matched];
    });
  }
  function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width2 = html.clientWidth;
    var height2 = html.clientHeight;
    var x2 = 0;
    var y2 = 0;
    if (visualViewport) {
      width2 = visualViewport.width;
      height2 = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width: width2,
      height: height2,
      x: x2 + getWindowScrollBarX(element),
      y: y2
    };
  }
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") {
      x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
    }
    return {
      width: width2,
      height: height2,
      x: x2,
      y: y2
    };
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getScrollParent(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
      return node2.ownerDocument.body;
    }
    if (isHTMLElement$1(node2) && isScrollParent(node2)) {
      return node2;
    }
    return getScrollParent(getParentNode(node2));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b2) {
      return overflows[a] - overflows[b2];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding: padding2
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  const flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  const hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  const offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  const popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding: padding2,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min$1 = offset2 + overflow[mainSide];
      var max$1 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  const preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
      return getWindowScroll(node2);
    } else {
      return getHTMLElementScroll(node2);
    }
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round$1(rect.width) / element.offsetWidth || 1;
    var scaleY = round$1(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement$1(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
          if (typeof effect2 === "function") {
            var cleanupFn = effect2({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  function getContainer(container) {
    return typeof container === "function" ? container() : container;
  }
  const Portal = /* @__PURE__ */ React__namespace.forwardRef(function Portal2(props, forwardedRef) {
    const {
      children,
      container,
      disablePortal = false
    } = props;
    const [mountNode, setMountNode] = React__namespace.useState(null);
    const handleRef = useForkRef(/* @__PURE__ */ React__namespace.isValidElement(children) ? children.ref : null, forwardedRef);
    useEnhancedEffect$1(() => {
      if (!disablePortal) {
        setMountNode(getContainer(container) || document.body);
      }
    }, [container, disablePortal]);
    useEnhancedEffect$1(() => {
      if (mountNode && !disablePortal) {
        setRef(forwardedRef, mountNode);
        return () => {
          setRef(forwardedRef, null);
        };
      }
      return void 0;
    }, [forwardedRef, mountNode, disablePortal]);
    if (disablePortal) {
      if (/* @__PURE__ */ React__namespace.isValidElement(children)) {
        const newProps = {
          ref: handleRef
        };
        return /* @__PURE__ */ React__namespace.cloneElement(children, newProps);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(React__namespace.Fragment, {
        children
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React__namespace.Fragment, {
      children: mountNode ? /* @__PURE__ */ ReactDOM__default__namespace.createPortal(children, mountNode) : mountNode
    });
  });
  function getPopperUtilityClass(slot) {
    return generateUtilityClass("MuiPopper", slot);
  }
  generateUtilityClasses("MuiPopper", ["root"]);
  const _excluded$1F = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], _excluded2$a = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
  function flipPlacement(placement, direction) {
    if (direction === "ltr") {
      return placement;
    }
    switch (placement) {
      case "bottom-end":
        return "bottom-start";
      case "bottom-start":
        return "bottom-end";
      case "top-end":
        return "top-start";
      case "top-start":
        return "top-end";
      default:
        return placement;
    }
  }
  function resolveAnchorEl$1(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
  }
  function isHTMLElement(element) {
    return element.nodeType !== void 0;
  }
  const useUtilityClasses$1f = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, useClassNamesOverride(getPopperUtilityClass));
  };
  const defaultPopperOptions = {};
  const PopperTooltip = /* @__PURE__ */ React__namespace.forwardRef(function PopperTooltip2(props, forwardedRef) {
    var _slots$root;
    const {
      anchorEl,
      children,
      direction,
      disablePortal,
      modifiers,
      open,
      placement: initialPlacement,
      popperOptions,
      popperRef: popperRefProp,
      slotProps = {},
      slots = {},
      TransitionProps
      // @ts-ignore internal logic
      // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1F);
    const tooltipRef = React__namespace.useRef(null);
    const ownRef = useForkRef(tooltipRef, forwardedRef);
    const popperRef = React__namespace.useRef(null);
    const handlePopperRef = useForkRef(popperRef, popperRefProp);
    const handlePopperRefRef = React__namespace.useRef(handlePopperRef);
    useEnhancedEffect$1(() => {
      handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    React__namespace.useImperativeHandle(popperRefProp, () => popperRef.current, []);
    const rtlPlacement = flipPlacement(initialPlacement, direction);
    const [placement, setPlacement] = React__namespace.useState(rtlPlacement);
    const [resolvedAnchorElement, setResolvedAnchorElement] = React__namespace.useState(resolveAnchorEl$1(anchorEl));
    React__namespace.useEffect(() => {
      if (popperRef.current) {
        popperRef.current.forceUpdate();
      }
    });
    React__namespace.useEffect(() => {
      if (anchorEl) {
        setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
      }
    }, [anchorEl]);
    useEnhancedEffect$1(() => {
      if (!resolvedAnchorElement || !open) {
        return void 0;
      }
      const handlePopperUpdate = (data) => {
        setPlacement(data.placement);
      };
      let popperModifiers = [{
        name: "preventOverflow",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "flip",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "onUpdate",
        enabled: true,
        phase: "afterWrite",
        fn: ({
          state
        }) => {
          handlePopperUpdate(state);
        }
      }];
      if (modifiers != null) {
        popperModifiers = popperModifiers.concat(modifiers);
      }
      if (popperOptions && popperOptions.modifiers != null) {
        popperModifiers = popperModifiers.concat(popperOptions.modifiers);
      }
      const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, _extends({
        placement: rtlPlacement
      }, popperOptions, {
        modifiers: popperModifiers
      }));
      handlePopperRefRef.current(popper2);
      return () => {
        popper2.destroy();
        handlePopperRefRef.current(null);
      };
    }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
    const childProps = {
      placement
    };
    if (TransitionProps !== null) {
      childProps.TransitionProps = TransitionProps;
    }
    const classes = useUtilityClasses$1f();
    const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
    const rootProps = useSlotProps({
      elementType: Root,
      externalSlotProps: slotProps.root,
      externalForwardedProps: other,
      additionalProps: {
        role: "tooltip",
        ref: ownRef
      },
      ownerState: props,
      className: classes.root
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends({}, rootProps, {
      children: typeof children === "function" ? children(childProps) : children
    }));
  });
  const Popper$1 = /* @__PURE__ */ React__namespace.forwardRef(function Popper2(props, forwardedRef) {
    const {
      anchorEl,
      children,
      container: containerProp,
      direction = "ltr",
      disablePortal = false,
      keepMounted = false,
      modifiers,
      open,
      placement = "bottom",
      popperOptions = defaultPopperOptions,
      popperRef,
      style: style2,
      transition = false,
      slotProps = {},
      slots = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded2$a);
    const [exited, setExited] = React__namespace.useState(true);
    const handleEnter = () => {
      setExited(false);
    };
    const handleExited = () => {
      setExited(true);
    };
    if (!keepMounted && !open && (!transition || exited)) {
      return null;
    }
    let container;
    if (containerProp) {
      container = containerProp;
    } else if (anchorEl) {
      const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
      container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
    }
    const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
    const transitionProps = transition ? {
      in: open,
      onEnter: handleEnter,
      onExited: handleExited
    } : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
      disablePortal,
      container,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, _extends({
        anchorEl,
        direction,
        disablePortal,
        modifiers,
        ref: forwardedRef,
        open: transition ? !exited : open,
        placement,
        popperOptions,
        popperRef,
        slotProps,
        slots
      }, other, {
        style: _extends({
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: "fixed",
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display
        }, style2),
        TransitionProps: transitionProps,
        children
      }))
    });
  });
  const _excluded$1E = ["onChange", "maxRows", "minRows", "style", "value"];
  function getStyleValue(value) {
    return parseInt(value, 10) || 0;
  }
  const styles$2 = {
    shadow: {
      // Visibility needed to hide the extra text area on iPads
      visibility: "hidden",
      // Remove from the content flow
      position: "absolute",
      // Ignore the scrollbar width
      overflow: "hidden",
      height: 0,
      top: 0,
      left: 0,
      // Create a new layer, increase the isolation of the computed values
      transform: "translateZ(0)"
    }
  };
  function isEmpty$1(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
  }
  const TextareaAutosize = /* @__PURE__ */ React__namespace.forwardRef(function TextareaAutosize2(props, forwardedRef) {
    const {
      onChange,
      maxRows,
      minRows = 1,
      style: style2,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1E);
    const {
      current: isControlled
    } = React__namespace.useRef(value != null);
    const inputRef = React__namespace.useRef(null);
    const handleRef = useForkRef(forwardedRef, inputRef);
    const shadowRef = React__namespace.useRef(null);
    const renders = React__namespace.useRef(0);
    const [state, setState] = React__namespace.useState({
      outerHeightStyle: 0
    });
    const getUpdatedState = React__namespace.useCallback(() => {
      const input = inputRef.current;
      const containerWindow = ownerWindow(input);
      const computedStyle = containerWindow.getComputedStyle(input);
      if (computedStyle.width === "0px") {
        return {
          outerHeightStyle: 0
        };
      }
      const inputShallow = shadowRef.current;
      inputShallow.style.width = computedStyle.width;
      inputShallow.value = input.value || props.placeholder || "x";
      if (inputShallow.value.slice(-1) === "\n") {
        inputShallow.value += " ";
      }
      const boxSizing2 = computedStyle.boxSizing;
      const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
      const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
      const innerHeight = inputShallow.scrollHeight;
      inputShallow.value = "x";
      const singleRowHeight = inputShallow.scrollHeight;
      let outerHeight = innerHeight;
      if (minRows) {
        outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
      }
      if (maxRows) {
        outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
      }
      outerHeight = Math.max(outerHeight, singleRowHeight);
      const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
      const overflow = Math.abs(outerHeight - innerHeight) <= 1;
      return {
        outerHeightStyle,
        overflow
      };
    }, [maxRows, minRows, props.placeholder]);
    const updateState = (prevState, newState) => {
      const {
        outerHeightStyle,
        overflow
      } = newState;
      if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
        renders.current += 1;
        return {
          overflow,
          outerHeightStyle
        };
      }
      return prevState;
    };
    const syncHeight = React__namespace.useCallback(() => {
      const newState = getUpdatedState();
      if (isEmpty$1(newState)) {
        return;
      }
      setState((prevState) => {
        return updateState(prevState, newState);
      });
    }, [getUpdatedState]);
    const syncHeightWithFlushSync = () => {
      const newState = getUpdatedState();
      if (isEmpty$1(newState)) {
        return;
      }
      ReactDOM__default__namespace.flushSync(() => {
        setState((prevState) => {
          return updateState(prevState, newState);
        });
      });
    };
    React__namespace.useEffect(() => {
      const handleResize = debounce$1(() => {
        renders.current = 0;
        if (inputRef.current) {
          syncHeightWithFlushSync();
        }
      });
      let resizeObserver;
      const input = inputRef.current;
      const containerWindow = ownerWindow(input);
      containerWindow.addEventListener("resize", handleResize);
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(input);
      }
      return () => {
        handleResize.clear();
        containerWindow.removeEventListener("resize", handleResize);
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
      };
    });
    useEnhancedEffect$1(() => {
      syncHeight();
    });
    React__namespace.useEffect(() => {
      renders.current = 0;
    }, [value]);
    const handleChange = (event) => {
      renders.current = 0;
      if (!isControlled) {
        syncHeight();
      }
      if (onChange) {
        onChange(event);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends({
        value,
        onChange: handleChange,
        ref: handleRef,
        rows: minRows,
        style: _extends({
          height: state.outerHeightStyle,
          // Need a large enough difference to allow scrolling.
          // This prevents infinite rendering loop.
          overflow: state.overflow ? "hidden" : void 0
        }, style2)
      }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
        "aria-hidden": true,
        className: props.className,
        readOnly: true,
        ref: shadowRef,
        tabIndex: -1,
        style: _extends({}, styles$2.shadow, style2, {
          paddingTop: 0,
          paddingBottom: 0
        })
      })]
    });
  });
  function stripDiacritics(string) {
    return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
  }
  function createFilterOptions(config2 = {}) {
    const {
      ignoreAccents = true,
      ignoreCase = true,
      limit,
      matchFrom = "any",
      stringify: stringify2,
      trim: trim2 = false
    } = config2;
    return (options, {
      inputValue,
      getOptionLabel
    }) => {
      let input = trim2 ? inputValue.trim() : inputValue;
      if (ignoreCase) {
        input = input.toLowerCase();
      }
      if (ignoreAccents) {
        input = stripDiacritics(input);
      }
      const filteredOptions = !input ? options : options.filter((option) => {
        let candidate = (stringify2 || getOptionLabel)(option);
        if (ignoreCase) {
          candidate = candidate.toLowerCase();
        }
        if (ignoreAccents) {
          candidate = stripDiacritics(candidate);
        }
        return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
      });
      return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
    };
  }
  function findIndex(array, comp) {
    for (let i = 0; i < array.length; i += 1) {
      if (comp(array[i])) {
        return i;
      }
    }
    return -1;
  }
  const defaultFilterOptions = createFilterOptions();
  const pageSize = 5;
  const defaultIsActiveElementInListbox = (listboxRef) => {
    var _listboxRef$current$p;
    return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
  };
  function useAutocomplete(props) {
    const {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_classNamePrefix = "Mui",
      autoComplete = false,
      autoHighlight = false,
      autoSelect = false,
      blurOnSelect = false,
      clearOnBlur = !props.freeSolo,
      clearOnEscape = false,
      componentName = "useAutocomplete",
      defaultValue = props.multiple ? [] : null,
      disableClearable = false,
      disableCloseOnSelect = false,
      disabled: disabledProp,
      disabledItemsFocusable = false,
      disableListWrap = false,
      filterOptions = defaultFilterOptions,
      filterSelectedOptions = false,
      freeSolo = false,
      getOptionDisabled,
      getOptionLabel: getOptionLabelProp = (option) => {
        var _option$label;
        return (_option$label = option.label) != null ? _option$label : option;
      },
      groupBy,
      handleHomeEndKeys = !props.freeSolo,
      id: idProp,
      includeInputInList = false,
      inputValue: inputValueProp,
      isOptionEqualToValue = (option, value2) => option === value2,
      multiple = false,
      onChange,
      onClose,
      onHighlightChange,
      onInputChange,
      onOpen,
      open: openProp,
      openOnFocus = false,
      options,
      readOnly = false,
      selectOnFocus = !props.freeSolo,
      value: valueProp
    } = props;
    const id = useId(idProp);
    let getOptionLabel = getOptionLabelProp;
    getOptionLabel = (option) => {
      const optionLabel = getOptionLabelProp(option);
      if (typeof optionLabel !== "string") {
        return String(optionLabel);
      }
      return optionLabel;
    };
    const ignoreFocus = React__namespace.useRef(false);
    const firstFocus = React__namespace.useRef(true);
    const inputRef = React__namespace.useRef(null);
    const listboxRef = React__namespace.useRef(null);
    const [anchorEl, setAnchorEl] = React__namespace.useState(null);
    const [focusedTag, setFocusedTag] = React__namespace.useState(-1);
    const defaultHighlighted = autoHighlight ? 0 : -1;
    const highlightedIndexRef = React__namespace.useRef(defaultHighlighted);
    const [value, setValueState] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: componentName
    });
    const [inputValue, setInputValueState] = useControlled({
      controlled: inputValueProp,
      default: "",
      name: componentName,
      state: "inputValue"
    });
    const [focused, setFocused] = React__namespace.useState(false);
    const resetInputValue = React__namespace.useCallback((event, newValue) => {
      const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
      if (!isOptionSelected && !clearOnBlur) {
        return;
      }
      let newInputValue;
      if (multiple) {
        newInputValue = "";
      } else if (newValue == null) {
        newInputValue = "";
      } else {
        const optionLabel = getOptionLabel(newValue);
        newInputValue = typeof optionLabel === "string" ? optionLabel : "";
      }
      if (inputValue === newInputValue) {
        return;
      }
      setInputValueState(newInputValue);
      if (onInputChange) {
        onInputChange(event, newInputValue, "reset");
      }
    }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
    const [open, setOpenState] = useControlled({
      controlled: openProp,
      default: false,
      name: componentName,
      state: "open"
    });
    const [inputPristine, setInputPristine] = React__namespace.useState(true);
    const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
    const popupOpen = open && !readOnly;
    const filteredOptions = popupOpen ? filterOptions(
      options.filter((option) => {
        if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
          return false;
        }
        return true;
      }),
      // we use the empty string to manipulate `filterOptions` to not filter any options
      // i.e. the filter predicate always returns true
      {
        inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
        getOptionLabel
      }
    ) : [];
    const previousProps = usePreviousProps$1({
      filteredOptions,
      value,
      inputValue
    });
    React__namespace.useEffect(() => {
      const valueChange = value !== previousProps.value;
      if (focused && !valueChange) {
        return;
      }
      if (freeSolo && !valueChange) {
        return;
      }
      resetInputValue(null, value);
    }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
    const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
    const focusTag = useEventCallback((tagToFocus) => {
      if (tagToFocus === -1) {
        inputRef.current.focus();
      } else {
        anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
      }
    });
    React__namespace.useEffect(() => {
      if (multiple && focusedTag > value.length - 1) {
        setFocusedTag(-1);
        focusTag(-1);
      }
    }, [value, multiple, focusedTag, focusTag]);
    function validOptionIndex(index, direction) {
      if (!listboxRef.current || index === -1) {
        return -1;
      }
      let nextFocus = index;
      while (true) {
        if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
          return -1;
        }
        const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
        const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
        if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
          nextFocus += direction === "next" ? 1 : -1;
        } else {
          return nextFocus;
        }
      }
    }
    const setHighlightedIndex = useEventCallback(({
      event,
      index,
      reason = "auto"
    }) => {
      highlightedIndexRef.current = index;
      if (index === -1) {
        inputRef.current.removeAttribute("aria-activedescendant");
      } else {
        inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index}`);
      }
      if (onHighlightChange) {
        onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
      }
      if (!listboxRef.current) {
        return;
      }
      const prev2 = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
      if (prev2) {
        prev2.classList.remove(`${unstable_classNamePrefix}-focused`);
        prev2.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
      }
      let listboxNode = listboxRef.current;
      if (listboxRef.current.getAttribute("role") !== "listbox") {
        listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
      }
      if (!listboxNode) {
        return;
      }
      if (index === -1) {
        listboxNode.scrollTop = 0;
        return;
      }
      const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
      if (!option) {
        return;
      }
      option.classList.add(`${unstable_classNamePrefix}-focused`);
      if (reason === "keyboard") {
        option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
      }
      if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse" && reason !== "touch") {
        const element = option;
        const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
        const elementBottom = element.offsetTop + element.offsetHeight;
        if (elementBottom > scrollBottom) {
          listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
        } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
          listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
        }
      }
    });
    const changeHighlightedIndex = useEventCallback(({
      event,
      diff,
      direction = "next",
      reason = "auto"
    }) => {
      if (!popupOpen) {
        return;
      }
      const getNextIndex = () => {
        const maxIndex = filteredOptions.length - 1;
        if (diff === "reset") {
          return defaultHighlighted;
        }
        if (diff === "start") {
          return 0;
        }
        if (diff === "end") {
          return maxIndex;
        }
        const newIndex = highlightedIndexRef.current + diff;
        if (newIndex < 0) {
          if (newIndex === -1 && includeInputInList) {
            return -1;
          }
          if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
            return 0;
          }
          return maxIndex;
        }
        if (newIndex > maxIndex) {
          if (newIndex === maxIndex + 1 && includeInputInList) {
            return -1;
          }
          if (disableListWrap || Math.abs(diff) > 1) {
            return maxIndex;
          }
          return 0;
        }
        return newIndex;
      };
      const nextIndex = validOptionIndex(getNextIndex(), direction);
      setHighlightedIndex({
        index: nextIndex,
        reason,
        event
      });
      if (autoComplete && diff !== "reset") {
        if (nextIndex === -1) {
          inputRef.current.value = inputValue;
        } else {
          const option = getOptionLabel(filteredOptions[nextIndex]);
          inputRef.current.value = option;
          const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
          if (index === 0 && inputValue.length > 0) {
            inputRef.current.setSelectionRange(inputValue.length, option.length);
          }
        }
      }
    });
    const checkHighlightedOptionExists = () => {
      const isSameValue = (value1, value2) => {
        const label1 = value1 ? getOptionLabel(value1) : "";
        const label2 = value2 ? getOptionLabel(value2) : "";
        return label1 === label2;
      };
      if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i) => getOptionLabel(value[i]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
        const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
        if (previousHighlightedOption) {
          const previousHighlightedOptionExists = filteredOptions.some((option) => {
            return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
          });
          if (previousHighlightedOptionExists) {
            return true;
          }
        }
      }
      return false;
    };
    const syncHighlightedIndex = React__namespace.useCallback(() => {
      if (!popupOpen) {
        return;
      }
      if (checkHighlightedOptionExists()) {
        return;
      }
      const valueItem = multiple ? value[0] : value;
      if (filteredOptions.length === 0 || valueItem == null) {
        changeHighlightedIndex({
          diff: "reset"
        });
        return;
      }
      if (!listboxRef.current) {
        return;
      }
      if (valueItem != null) {
        const currentOption = filteredOptions[highlightedIndexRef.current];
        if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
          return;
        }
        const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
        if (itemIndex === -1) {
          changeHighlightedIndex({
            diff: "reset"
          });
        } else {
          setHighlightedIndex({
            index: itemIndex
          });
        }
        return;
      }
      if (highlightedIndexRef.current >= filteredOptions.length - 1) {
        setHighlightedIndex({
          index: filteredOptions.length - 1
        });
        return;
      }
      setHighlightedIndex({
        index: highlightedIndexRef.current
      });
    }, [
      // Only sync the highlighted index when the option switch between empty and not
      filteredOptions.length,
      // Don't sync the highlighted index with the value when multiple
      // eslint-disable-next-line react-hooks/exhaustive-deps
      multiple ? false : value,
      filterSelectedOptions,
      changeHighlightedIndex,
      setHighlightedIndex,
      popupOpen,
      inputValue,
      multiple
    ]);
    const handleListboxRef = useEventCallback((node2) => {
      setRef(listboxRef, node2);
      if (!node2) {
        return;
      }
      syncHighlightedIndex();
    });
    React__namespace.useEffect(() => {
      syncHighlightedIndex();
    }, [syncHighlightedIndex]);
    const handleOpen = (event) => {
      if (open) {
        return;
      }
      setOpenState(true);
      setInputPristine(true);
      if (onOpen) {
        onOpen(event);
      }
    };
    const handleClose = (event, reason) => {
      if (!open) {
        return;
      }
      setOpenState(false);
      if (onClose) {
        onClose(event, reason);
      }
    };
    const handleValue = (event, newValue, reason, details) => {
      if (multiple) {
        if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
          return;
        }
      } else if (value === newValue) {
        return;
      }
      if (onChange) {
        onChange(event, newValue, reason, details);
      }
      setValueState(newValue);
    };
    const isTouch = React__namespace.useRef(false);
    const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
      let reason = reasonProp;
      let newValue = option;
      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];
        const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
        if (itemIndex === -1) {
          newValue.push(option);
        } else if (origin !== "freeSolo") {
          newValue.splice(itemIndex, 1);
          reason = "removeOption";
        }
      }
      resetInputValue(event, newValue);
      handleValue(event, newValue, reason, {
        option
      });
      if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
        handleClose(event, reason);
      }
      if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
        inputRef.current.blur();
      }
    };
    function validTagIndex(index, direction) {
      if (index === -1) {
        return -1;
      }
      let nextFocus = index;
      while (true) {
        if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
          return -1;
        }
        const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
        if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
          nextFocus += direction === "next" ? 1 : -1;
        } else {
          return nextFocus;
        }
      }
    }
    const handleFocusTag = (event, direction) => {
      if (!multiple) {
        return;
      }
      if (inputValue === "") {
        handleClose(event, "toggleInput");
      }
      let nextTag = focusedTag;
      if (focusedTag === -1) {
        if (inputValue === "" && direction === "previous") {
          nextTag = value.length - 1;
        }
      } else {
        nextTag += direction === "next" ? 1 : -1;
        if (nextTag < 0) {
          nextTag = 0;
        }
        if (nextTag === value.length) {
          nextTag = -1;
        }
      }
      nextTag = validTagIndex(nextTag, direction);
      setFocusedTag(nextTag);
      focusTag(nextTag);
    };
    const handleClear = (event) => {
      ignoreFocus.current = true;
      setInputValueState("");
      if (onInputChange) {
        onInputChange(event, "", "clear");
      }
      handleValue(event, multiple ? [] : null, "clear");
    };
    const handleKeyDown2 = (other) => (event) => {
      if (other.onKeyDown) {
        other.onKeyDown(event);
      }
      if (event.defaultMuiPrevented) {
        return;
      }
      if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
        setFocusedTag(-1);
        focusTag(-1);
      }
      if (event.which !== 229) {
        switch (event.key) {
          case "Home":
            if (popupOpen && handleHomeEndKeys) {
              event.preventDefault();
              changeHighlightedIndex({
                diff: "start",
                direction: "next",
                reason: "keyboard",
                event
              });
            }
            break;
          case "End":
            if (popupOpen && handleHomeEndKeys) {
              event.preventDefault();
              changeHighlightedIndex({
                diff: "end",
                direction: "previous",
                reason: "keyboard",
                event
              });
            }
            break;
          case "PageUp":
            event.preventDefault();
            changeHighlightedIndex({
              diff: -pageSize,
              direction: "previous",
              reason: "keyboard",
              event
            });
            handleOpen(event);
            break;
          case "PageDown":
            event.preventDefault();
            changeHighlightedIndex({
              diff: pageSize,
              direction: "next",
              reason: "keyboard",
              event
            });
            handleOpen(event);
            break;
          case "ArrowDown":
            event.preventDefault();
            changeHighlightedIndex({
              diff: 1,
              direction: "next",
              reason: "keyboard",
              event
            });
            handleOpen(event);
            break;
          case "ArrowUp":
            event.preventDefault();
            changeHighlightedIndex({
              diff: -1,
              direction: "previous",
              reason: "keyboard",
              event
            });
            handleOpen(event);
            break;
          case "ArrowLeft":
            handleFocusTag(event, "previous");
            break;
          case "ArrowRight":
            handleFocusTag(event, "next");
            break;
          case "Enter":
            if (highlightedIndexRef.current !== -1 && popupOpen) {
              const option = filteredOptions[highlightedIndexRef.current];
              const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
              event.preventDefault();
              if (disabled) {
                return;
              }
              selectNewValue(event, option, "selectOption");
              if (autoComplete) {
                inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
              }
            } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
              if (multiple) {
                event.preventDefault();
              }
              selectNewValue(event, inputValue, "createOption", "freeSolo");
            }
            break;
          case "Escape":
            if (popupOpen) {
              event.preventDefault();
              event.stopPropagation();
              handleClose(event, "escape");
            } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
              event.preventDefault();
              event.stopPropagation();
              handleClear(event);
            }
            break;
          case "Backspace":
            if (multiple && !readOnly && inputValue === "" && value.length > 0) {
              const index = focusedTag === -1 ? value.length - 1 : focusedTag;
              const newValue = value.slice();
              newValue.splice(index, 1);
              handleValue(event, newValue, "removeOption", {
                option: value[index]
              });
            }
            break;
          case "Delete":
            if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
              const index = focusedTag;
              const newValue = value.slice();
              newValue.splice(index, 1);
              handleValue(event, newValue, "removeOption", {
                option: value[index]
              });
            }
            break;
        }
      }
    };
    const handleFocus = (event) => {
      setFocused(true);
      if (openOnFocus && !ignoreFocus.current) {
        handleOpen(event);
      }
    };
    const handleBlur = (event) => {
      if (unstable_isActiveElementInListbox(listboxRef)) {
        inputRef.current.focus();
        return;
      }
      setFocused(false);
      firstFocus.current = true;
      ignoreFocus.current = false;
      if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
        selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
      } else if (autoSelect && freeSolo && inputValue !== "") {
        selectNewValue(event, inputValue, "blur", "freeSolo");
      } else if (clearOnBlur) {
        resetInputValue(event, value);
      }
      handleClose(event, "blur");
    };
    const handleInputChange = (event) => {
      const newValue = event.target.value;
      if (inputValue !== newValue) {
        setInputValueState(newValue);
        setInputPristine(false);
        if (onInputChange) {
          onInputChange(event, newValue, "input");
        }
      }
      if (newValue === "") {
        if (!disableClearable && !multiple) {
          handleValue(event, null, "clear");
        }
      } else {
        handleOpen(event);
      }
    };
    const handleOptionMouseMove = (event) => {
      const index = Number(event.currentTarget.getAttribute("data-option-index"));
      if (highlightedIndexRef.current !== index) {
        setHighlightedIndex({
          event,
          index,
          reason: "mouse"
        });
      }
    };
    const handleOptionTouchStart = (event) => {
      setHighlightedIndex({
        event,
        index: Number(event.currentTarget.getAttribute("data-option-index")),
        reason: "touch"
      });
      isTouch.current = true;
    };
    const handleOptionClick = (event) => {
      const index = Number(event.currentTarget.getAttribute("data-option-index"));
      selectNewValue(event, filteredOptions[index], "selectOption");
      isTouch.current = false;
    };
    const handleTagDelete = (index) => (event) => {
      const newValue = value.slice();
      newValue.splice(index, 1);
      handleValue(event, newValue, "removeOption", {
        option: value[index]
      });
    };
    const handlePopupIndicator = (event) => {
      if (open) {
        handleClose(event, "toggleInput");
      } else {
        handleOpen(event);
      }
    };
    const handleMouseDown = (event) => {
      if (!event.currentTarget.contains(event.target)) {
        return;
      }
      if (event.target.getAttribute("id") !== id) {
        event.preventDefault();
      }
    };
    const handleClick = (event) => {
      if (!event.currentTarget.contains(event.target)) {
        return;
      }
      inputRef.current.focus();
      if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
        inputRef.current.select();
      }
      firstFocus.current = false;
    };
    const handleInputMouseDown = (event) => {
      if (inputValue === "" || !open) {
        handlePopupIndicator(event);
      }
    };
    let dirty = freeSolo && inputValue.length > 0;
    dirty = dirty || (multiple ? value.length > 0 : value !== null);
    let groupedOptions = filteredOptions;
    if (groupBy) {
      groupedOptions = filteredOptions.reduce((acc, option, index) => {
        const group = groupBy(option);
        if (acc.length > 0 && acc[acc.length - 1].group === group) {
          acc[acc.length - 1].options.push(option);
        } else {
          acc.push({
            key: index,
            index,
            group,
            options: [option]
          });
        }
        return acc;
      }, []);
    }
    if (disabledProp && focused) {
      handleBlur();
    }
    return {
      getRootProps: (other = {}) => _extends({
        "aria-owns": listboxAvailable ? `${id}-listbox` : null
      }, other, {
        onKeyDown: handleKeyDown2(other),
        onMouseDown: handleMouseDown,
        onClick: handleClick
      }),
      getInputLabelProps: () => ({
        id: `${id}-label`,
        htmlFor: id
      }),
      getInputProps: () => ({
        id,
        value: inputValue,
        onBlur: handleBlur,
        onFocus: handleFocus,
        onChange: handleInputChange,
        onMouseDown: handleInputMouseDown,
        // if open then this is handled imperatively so don't let react override
        // only have an opinion about this when closed
        "aria-activedescendant": popupOpen ? "" : null,
        "aria-autocomplete": autoComplete ? "both" : "list",
        "aria-controls": listboxAvailable ? `${id}-listbox` : void 0,
        "aria-expanded": listboxAvailable,
        // Disable browser's suggestion that might overlap with the popup.
        // Handle autocomplete but not autofill.
        autoComplete: "off",
        ref: inputRef,
        autoCapitalize: "none",
        spellCheck: "false",
        role: "combobox",
        disabled: disabledProp
      }),
      getClearProps: () => ({
        tabIndex: -1,
        onClick: handleClear
      }),
      getPopupIndicatorProps: () => ({
        tabIndex: -1,
        onClick: handlePopupIndicator
      }),
      getTagProps: ({
        index
      }) => _extends({
        key: index,
        "data-tag-index": index,
        tabIndex: -1
      }, !readOnly && {
        onDelete: handleTagDelete(index)
      }),
      getListboxProps: () => ({
        role: "listbox",
        id: `${id}-listbox`,
        "aria-labelledby": `${id}-label`,
        ref: handleListboxRef,
        onMouseDown: (event) => {
          event.preventDefault();
        }
      }),
      getOptionProps: ({
        index,
        option
      }) => {
        const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
        const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
        return {
          key: getOptionLabel(option),
          tabIndex: -1,
          role: "option",
          id: `${id}-option-${index}`,
          onMouseMove: handleOptionMouseMove,
          onClick: handleOptionClick,
          onTouchStart: handleOptionTouchStart,
          "data-option-index": index,
          "aria-disabled": disabled,
          "aria-selected": selected
        };
      },
      id,
      inputValue,
      value,
      dirty,
      expanded: popupOpen && anchorEl,
      popupOpen,
      focused: focused || focusedTag !== -1,
      anchorEl,
      setAnchorEl,
      focusedTag,
      groupedOptions
    };
  }
  const reflow = (node2) => node2.scrollTop;
  function getTransitionProps(props, options) {
    var _style$transitionDura, _style$transitionTimi;
    const {
      timeout,
      easing: easing2,
      style: style2 = {}
    } = props;
    return {
      duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
      easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
      delay: style2.transitionDelay
    };
  }
  const _excluded$1D = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  const styles$1 = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  };
  const Fade = /* @__PURE__ */ React__namespace.forwardRef(function Fade2(props, ref) {
    const theme = useTheme();
    const defaultTimeout = {
      enter: theme.transitions.duration.enteringScreen,
      exit: theme.transitions.duration.leavingScreen
    };
    const {
      addEndListener,
      appear = true,
      children,
      easing: easing2,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style: style2,
      timeout = defaultTimeout,
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition$1
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1D);
    const nodeRef = React__namespace.useRef(null);
    const handleRef = useForkRef(nodeRef, children.ref, ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
      if (callback) {
        const node2 = nodeRef.current;
        if (maybeIsAppearing === void 0) {
          callback(node2);
        } else {
          callback(node2, maybeIsAppearing);
        }
      }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
      reflow(node2);
      const transitionProps = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "enter"
      });
      node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
      node2.style.transition = theme.transitions.create("opacity", transitionProps);
      if (onEnter) {
        onEnter(node2, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
      const transitionProps = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "exit"
      });
      node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
      node2.style.transition = theme.transitions.create("opacity", transitionProps);
      if (onExit) {
        onExit(node2);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
      if (addEndListener) {
        addEndListener(nodeRef.current, next2);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
      appear,
      in: inProp,
      nodeRef,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout
    }, other, {
      children: (state, childProps) => {
        return /* @__PURE__ */ React__namespace.cloneElement(children, _extends({
          style: _extends({
            opacity: 0,
            visibility: state === "exited" && !inProp ? "hidden" : void 0
          }, styles$1[state], style2, children.props.style),
          ref: handleRef
        }, childProps));
      }
    }));
  });
  const Fade$1 = Fade;
  function getBackdropUtilityClass(slot) {
    return generateUtilityClass("MuiBackdrop", slot);
  }
  generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
  const _excluded$1C = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
  const useUtilityClasses$1e = (ownerState) => {
    const {
      classes,
      invisible
    } = ownerState;
    const slots = {
      root: ["root", invisible && "invisible"]
    };
    return composeClasses(slots, getBackdropUtilityClass, classes);
  };
  const BackdropRoot = styled$1("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.invisible && styles2.invisible];
    }
  })(({
    ownerState
  }) => _extends({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
  }, ownerState.invisible && {
    backgroundColor: "transparent"
  }));
  const Backdrop = /* @__PURE__ */ React__namespace.forwardRef(function Backdrop2(inProps, ref) {
    var _slotProps$root, _ref, _slots$root;
    const props = useThemeProps({
      props: inProps,
      name: "MuiBackdrop"
    });
    const {
      children,
      className,
      component = "div",
      components = {},
      componentsProps = {},
      invisible = false,
      open,
      slotProps = {},
      slots = {},
      TransitionComponent = Fade$1,
      transitionDuration
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1C);
    const ownerState = _extends({}, props, {
      component,
      invisible
    });
    const classes = useUtilityClasses$1e(ownerState);
    const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
      in: open,
      timeout: transitionDuration
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends({
        "aria-hidden": true
      }, rootSlotProps, {
        as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
        className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
        ownerState: _extends({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
        classes,
        ref,
        children
      }))
    }));
  });
  const Backdrop$1 = Backdrop;
  function getModalUtilityClass(slot) {
    return generateUtilityClass("MuiModal", slot);
  }
  generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
  const _excluded$1B = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "open", "slotProps", "slots", "theme"];
  const useUtilityClasses$1d = (ownerState) => {
    const {
      open,
      exited,
      classes
    } = ownerState;
    const slots = {
      root: ["root", !open && exited && "hidden"],
      backdrop: ["backdrop"]
    };
    return composeClasses(slots, getModalUtilityClass, classes);
  };
  const ModalRoot = styled$1("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    position: "fixed",
    zIndex: (theme.vars || theme).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0
  }, !ownerState.open && ownerState.exited && {
    visibility: "hidden"
  }));
  const ModalBackdrop = styled$1(Backdrop$1, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (props, styles2) => {
      return styles2.backdrop;
    }
  })({
    zIndex: -1
  });
  const Modal = /* @__PURE__ */ React__namespace.forwardRef(function Modal2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
    const props = useThemeProps({
      name: "MuiModal",
      props: inProps
    });
    const {
      BackdropComponent = ModalBackdrop,
      BackdropProps,
      className,
      closeAfterTransition = false,
      children,
      container,
      component,
      components = {},
      componentsProps = {},
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false,
      onBackdropClick,
      open,
      slotProps,
      slots
      // eslint-disable-next-line react/prop-types
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1B);
    const propsWithDefaults = _extends({}, props, {
      closeAfterTransition,
      disableAutoFocus,
      disableEnforceFocus,
      disableEscapeKeyDown,
      disablePortal,
      disableRestoreFocus,
      disableScrollLock,
      hideBackdrop,
      keepMounted
    });
    const {
      getRootProps,
      getBackdropProps,
      getTransitionProps: getTransitionProps2,
      portalRef,
      isTopModal,
      exited,
      hasTransition
    } = useModal(_extends({}, propsWithDefaults, {
      rootRef: ref
    }));
    const ownerState = _extends({}, propsWithDefaults, {
      exited
    });
    const classes = useUtilityClasses$1d(ownerState);
    const childProps = {};
    if (children.props.tabIndex === void 0) {
      childProps.tabIndex = "-1";
    }
    if (hasTransition) {
      const {
        onEnter,
        onExited
      } = getTransitionProps2();
      childProps.onEnter = onEnter;
      childProps.onExited = onExited;
    }
    const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
    const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
    const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
    const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
    const rootProps = useSlotProps({
      elementType: RootSlot,
      externalSlotProps: rootSlotProps,
      externalForwardedProps: other,
      getSlotProps: getRootProps,
      additionalProps: {
        ref,
        as: component
      },
      ownerState,
      className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
    });
    const backdropProps = useSlotProps({
      elementType: BackdropSlot,
      externalSlotProps: backdropSlotProps,
      additionalProps: BackdropProps,
      getSlotProps: (otherHandlers) => {
        return getBackdropProps(_extends({}, otherHandlers, {
          onClick: (e2) => {
            if (onBackdropClick) {
              onBackdropClick(e2);
            }
            if (otherHandlers != null && otherHandlers.onClick) {
              otherHandlers.onClick(e2);
            }
          }
        }));
      },
      className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
      ownerState
    });
    if (!keepMounted && !open && (!hasTransition || exited)) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
      ref: portalRef,
      container,
      disablePortal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends({}, rootProps, {
        children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
          disableEnforceFocus,
          disableAutoFocus,
          disableRestoreFocus,
          isEnabled: isTopModal,
          open,
          children: /* @__PURE__ */ React__namespace.cloneElement(children, childProps)
        })]
      }))
    });
  });
  const Modal$1 = Modal;
  const GridApiContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  function useGridApiContext() {
    const apiRef2 = React__namespace.useContext(GridApiContext);
    if (apiRef2 === void 0) {
      throw new Error(["MUI: Could not find the data grid context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the data grid."].join("\n"));
    }
    return apiRef2;
  }
  const GridRootPropsContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  const useGridRootProps = () => {
    const contextValue = React__namespace.useContext(GridRootPropsContext);
    if (!contextValue) {
      throw new Error("MUI: useGridRootProps should only be used inside the DataGrid, DataGridPro or DataGridPremium component.");
    }
    return contextValue;
  };
  const GridPrivateApiContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  function useGridPrivateApiContext() {
    const privateApiRef = React__namespace.useContext(GridPrivateApiContext);
    if (privateApiRef === void 0) {
      throw new Error(["MUI: Could not find the data grid private context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the data grid."].join("\n"));
    }
    return privateApiRef;
  }
  const UNINITIALIZED = {};
  function useLazyRef(init, initArg) {
    const ref = React__namespace.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = init(initArg);
    }
    return ref;
  }
  const EMPTY = [];
  function useOnMount(fn2) {
    React__namespace.useEffect(fn2, EMPTY);
  }
  const buildWarning = (message, gravity = "warning") => {
    let alreadyWarned = false;
    const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
    return () => {
      if (!alreadyWarned) {
        alreadyWarned = true;
        if (gravity === "error") {
          console.error(cleanMessage);
        } else {
          console.warn(cleanMessage);
        }
      }
    };
  };
  const is = Object.is;
  function fastObjectShallowCompare(a, b2) {
    if (a === b2) {
      return true;
    }
    if (!(a instanceof Object) || !(b2 instanceof Object)) {
      return false;
    }
    let aLength = 0;
    let bLength = 0;
    for (const key in a) {
      aLength += 1;
      if (!is(a[key], b2[key])) {
        return false;
      }
      if (!(key in b2)) {
        return false;
      }
    }
    for (const _2 in b2) {
      bLength += 1;
    }
    return aLength === bLength;
  }
  buildWarning(["MUI: `useGridSelector` has been called before the initialization of the state.", "This hook can only be used inside the context of the grid."]);
  function isOutputSelector(selector) {
    return selector.acceptsApiRef;
  }
  function applySelector(apiRef2, selector) {
    if (isOutputSelector(selector)) {
      return selector(apiRef2);
    }
    return selector(apiRef2.current.state);
  }
  const defaultCompare = Object.is;
  const objectShallowCompare = fastObjectShallowCompare;
  const createRefs = () => ({
    state: null,
    equals: null,
    selector: null
  });
  const useGridSelector = (apiRef2, selector, equals = defaultCompare) => {
    const refs = useLazyRef(createRefs);
    const didInit = refs.current.selector !== null;
    const [state, setState] = React__namespace.useState(
      // We don't use an initialization function to avoid allocations
      didInit ? null : applySelector(apiRef2, selector)
    );
    refs.current.state = state;
    refs.current.equals = equals;
    refs.current.selector = selector;
    useOnMount(() => {
      return apiRef2.current.store.subscribe(() => {
        const newState = applySelector(apiRef2, refs.current.selector);
        if (!refs.current.equals(refs.current.state, newState)) {
          refs.current.state = newState;
          setState(newState);
        }
      });
    });
    return state;
  };
  function getDataGridUtilityClass(slot) {
    return generateUtilityClass("MuiDataGrid", slot);
  }
  const gridClasses = generateUtilityClasses("MuiDataGrid", ["actionsCell", "aggregationColumnHeader", "aggregationColumnHeader--alignLeft", "aggregationColumnHeader--alignCenter", "aggregationColumnHeader--alignRight", "aggregationColumnHeaderLabel", "autoHeight", "booleanCell", "cell--editable", "cell--editing", "cell--textCenter", "cell--textLeft", "cell--textRight", "cell--withRenderer", "cell--rangeTop", "cell--rangeBottom", "cell--rangeLeft", "cell--rangeRight", "cell", "cellContent", "cellCheckbox", "cellSkeleton", "checkboxInput", "columnHeader--alignCenter", "columnHeader--alignLeft", "columnHeader--alignRight", "columnHeader--dragging", "columnHeader--moving", "columnHeader--numeric", "columnHeader--sortable", "columnHeader--sorted", "columnHeader--filtered", "columnHeader", "columnHeaderCheckbox", "columnHeaderDraggableContainer", "columnHeaderDropZone", "columnHeaderTitle", "columnHeaderTitleContainer", "columnHeaderTitleContainerContent", "columnGroupHeader", "columnHeader--filledGroup", "columnHeader--emptyGroup", "columnHeader--showColumnBorder", "columnHeaders", "columnHeadersInner", "columnHeadersInner--scrollable", "columnSeparator--resizable", "columnSeparator--resizing", "columnSeparator--sideLeft", "columnSeparator--sideRight", "columnSeparator", "columnsPanel", "columnsPanelRow", "detailPanel", "detailPanels", "detailPanelToggleCell", "detailPanelToggleCell--expanded", "footerCell", "panel", "panelHeader", "panelWrapper", "panelContent", "panelFooter", "paper", "editBooleanCell", "editInputCell", "filterForm", "filterFormDeleteIcon", "filterFormLogicOperatorInput", "filterFormColumnInput", "filterFormOperatorInput", "filterFormValueInput", "filterIcon", "footerContainer", "headerFilterRow", "iconButtonContainer", "iconSeparator", "main", "menu", "menuIcon", "menuIconButton", "menuOpen", "menuList", "overlay", "overlayWrapper", "overlayWrapperInner", "root", "root--densityStandard", "root--densityComfortable", "root--densityCompact", "root--disableUserSelection", "row", "row--editable", "row--editing", "row--lastVisible", "row--dragging", "row--dynamicHeight", "row--detailPanelExpanded", "rowReorderCellPlaceholder", "rowCount", "rowReorderCellContainer", "rowReorderCell", "rowReorderCell--draggable", "scrollArea--left", "scrollArea--right", "scrollArea", "selectedRowCount", "sortIcon", "toolbarContainer", "toolbarFilterList", "virtualScroller", "virtualScrollerContent", "virtualScrollerContent--overflowed", "virtualScrollerRenderZone", "pinnedColumns", "pinnedColumns--left", "pinnedColumns--right", "pinnedColumnHeaders", "pinnedColumnHeaders--left", "pinnedColumnHeaders--right", "withBorderColor", "cell--withRightBorder", "columnHeader--withRightBorder", "treeDataGroupingCell", "treeDataGroupingCellToggle", "groupingCriteriaCell", "groupingCriteriaCellToggle", "pinnedRows", "pinnedRows--top", "pinnedRows--bottom", "pinnedRowsRenderZone"]);
  var NOT_FOUND = "NOT_FOUND";
  function createSingletonCache(equals) {
    var entry;
    return {
      get: function get(key) {
        if (entry && equals(entry.key, key)) {
          return entry.value;
        }
        return NOT_FOUND;
      },
      put: function put(key, value) {
        entry = {
          key,
          value
        };
      },
      getEntries: function getEntries() {
        return entry ? [entry] : [];
      },
      clear: function clear() {
        entry = void 0;
      }
    };
  }
  function createLruCache(maxSize, equals) {
    var entries = [];
    function get(key) {
      var cacheIndex = entries.findIndex(function(entry2) {
        return equals(key, entry2.key);
      });
      if (cacheIndex > -1) {
        var entry = entries[cacheIndex];
        if (cacheIndex > 0) {
          entries.splice(cacheIndex, 1);
          entries.unshift(entry);
        }
        return entry.value;
      }
      return NOT_FOUND;
    }
    function put(key, value) {
      if (get(key) === NOT_FOUND) {
        entries.unshift({
          key,
          value
        });
        if (entries.length > maxSize) {
          entries.pop();
        }
      }
    }
    function getEntries() {
      return entries;
    }
    function clear() {
      entries = [];
    }
    return {
      get,
      put,
      getEntries,
      clear
    };
  }
  var defaultEqualityCheck = function defaultEqualityCheck2(a, b2) {
    return a === b2;
  };
  function createCacheKeyComparator(equalityCheck) {
    return function areArgumentsShallowlyEqual(prev2, next2) {
      if (prev2 === null || next2 === null || prev2.length !== next2.length) {
        return false;
      }
      var length2 = prev2.length;
      for (var i = 0; i < length2; i++) {
        if (!equalityCheck(prev2[i], next2[i])) {
          return false;
        }
      }
      return true;
    };
  }
  function defaultMemoize(func, equalityCheckOrOptions) {
    var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
      equalityCheck: equalityCheckOrOptions
    };
    var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
    var comparator = createCacheKeyComparator(equalityCheck);
    var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
    function memoized() {
      var value = cache.get(arguments);
      if (value === NOT_FOUND) {
        value = func.apply(null, arguments);
        if (resultEqualityCheck) {
          var entries = cache.getEntries();
          var matchingEntry = entries.find(function(entry) {
            return resultEqualityCheck(entry.value, value);
          });
          if (matchingEntry) {
            value = matchingEntry.value;
          }
        }
        cache.put(arguments, value);
      }
      return value;
    }
    memoized.clearCache = function() {
      return cache.clear();
    };
    return memoized;
  }
  function getDependencies(funcs) {
    var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
    if (!dependencies.every(function(dep) {
      return typeof dep === "function";
    })) {
      var dependencyTypes = dependencies.map(function(dep) {
        return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
      }).join(", ");
      throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
    }
    return dependencies;
  }
  function createSelectorCreator(memoize2) {
    for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      memoizeOptionsFromArgs[_key - 1] = arguments[_key];
    }
    var createSelector2 = function createSelector3() {
      for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        funcs[_key2] = arguments[_key2];
      }
      var _recomputations = 0;
      var _lastResult;
      var directlyPassedOptions = {
        memoizeOptions: void 0
      };
      var resultFunc = funcs.pop();
      if (typeof resultFunc === "object") {
        directlyPassedOptions = resultFunc;
        resultFunc = funcs.pop();
      }
      if (typeof resultFunc !== "function") {
        throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
      }
      var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
      var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
      var dependencies = getDependencies(funcs);
      var memoizedResultFunc = memoize2.apply(void 0, [function recomputationWrapper() {
        _recomputations++;
        return resultFunc.apply(null, arguments);
      }].concat(finalMemoizeOptions));
      var selector = memoize2(function dependenciesChecker() {
        var params = [];
        var length2 = dependencies.length;
        for (var i = 0; i < length2; i++) {
          params.push(dependencies[i].apply(null, arguments));
        }
        _lastResult = memoizedResultFunc.apply(null, params);
        return _lastResult;
      });
      Object.assign(selector, {
        resultFunc,
        memoizedResultFunc,
        dependencies,
        lastResult: function lastResult() {
          return _lastResult;
        },
        recomputations: function recomputations() {
          return _recomputations;
        },
        resetRecomputations: function resetRecomputations() {
          return _recomputations = 0;
        }
      });
      return selector;
    };
    return createSelector2;
  }
  var createSelector$1 = /* @__PURE__ */ createSelectorCreator(defaultMemoize);
  const cacheContainer = {
    cache: /* @__PURE__ */ new WeakMap()
  };
  buildWarning(["MUI: A selector was called without passing the instance ID, which may impact the performance of the grid.", "To fix, call it with `apiRef`, e.g. `mySelector(apiRef)`, or pass the instance ID explicitly, e.g `mySelector(state, apiRef.current.instanceId)`."]);
  function checkIsAPIRef(value) {
    return "current" in value && "instanceId" in value.current;
  }
  const DEFAULT_INSTANCE_ID = {
    id: "default"
  };
  const createSelector = (a, b2, c2, d2, e2, f2, ...rest) => {
    if (rest.length > 0) {
      throw new Error("Unsupported number of selectors");
    }
    let selector;
    if (a && b2 && c2 && d2 && e2 && f2) {
      selector = (stateOrApiRef, instanceIdParam) => {
        const isAPIRef = checkIsAPIRef(stateOrApiRef);
        const instanceId = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
        const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
        const va = a(state, instanceId);
        const vb = b2(state, instanceId);
        const vc = c2(state, instanceId);
        const vd = d2(state, instanceId);
        const ve = e2(state, instanceId);
        return f2(va, vb, vc, vd, ve);
      };
    } else if (a && b2 && c2 && d2 && e2) {
      selector = (stateOrApiRef, instanceIdParam) => {
        const isAPIRef = checkIsAPIRef(stateOrApiRef);
        const instanceId = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
        const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
        const va = a(state, instanceId);
        const vb = b2(state, instanceId);
        const vc = c2(state, instanceId);
        const vd = d2(state, instanceId);
        return e2(va, vb, vc, vd);
      };
    } else if (a && b2 && c2 && d2) {
      selector = (stateOrApiRef, instanceIdParam) => {
        const isAPIRef = checkIsAPIRef(stateOrApiRef);
        const instanceId = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
        const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
        const va = a(state, instanceId);
        const vb = b2(state, instanceId);
        const vc = c2(state, instanceId);
        return d2(va, vb, vc);
      };
    } else if (a && b2 && c2) {
      selector = (stateOrApiRef, instanceIdParam) => {
        const isAPIRef = checkIsAPIRef(stateOrApiRef);
        const instanceId = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
        const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
        const va = a(state, instanceId);
        const vb = b2(state, instanceId);
        return c2(va, vb);
      };
    } else if (a && b2) {
      selector = (stateOrApiRef, instanceIdParam) => {
        const isAPIRef = checkIsAPIRef(stateOrApiRef);
        const instanceId = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
        const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
        const va = a(state, instanceId);
        return b2(va);
      };
    } else {
      throw new Error("Missing arguments");
    }
    selector.acceptsApiRef = true;
    return selector;
  };
  const createSelectorMemoized = (...args) => {
    const selector = (...selectorArgs) => {
      var _cache$get, _cache$get3;
      const [stateOrApiRef, instanceId] = selectorArgs;
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const cacheKey = isAPIRef ? stateOrApiRef.current.instanceId : instanceId != null ? instanceId : DEFAULT_INSTANCE_ID;
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const {
        cache
      } = cacheContainer;
      if (cache.get(cacheKey) && (_cache$get = cache.get(cacheKey)) != null && _cache$get.get(args)) {
        var _cache$get2;
        return (_cache$get2 = cache.get(cacheKey)) == null ? void 0 : _cache$get2.get(args)(state, cacheKey);
      }
      const newSelector = createSelector$1(...args);
      if (!cache.get(cacheKey)) {
        cache.set(cacheKey, /* @__PURE__ */ new Map());
      }
      (_cache$get3 = cache.get(cacheKey)) == null ? void 0 : _cache$get3.set(args, newSelector);
      return newSelector(state, cacheKey);
    };
    selector.acceptsApiRef = true;
    return selector;
  };
  const gridColumnsStateSelector = (state) => state.columns;
  const gridColumnFieldsSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.orderedFields);
  const gridColumnLookupSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.lookup);
  const gridColumnDefinitionsSelector = createSelectorMemoized(gridColumnFieldsSelector, gridColumnLookupSelector, (allFields, lookup) => allFields.map((field) => lookup[field]));
  const gridColumnVisibilityModelSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.columnVisibilityModel);
  const gridVisibleColumnDefinitionsSelector = createSelectorMemoized(gridColumnDefinitionsSelector, gridColumnVisibilityModelSelector, (columns, columnVisibilityModel) => columns.filter((column2) => columnVisibilityModel[column2.field] !== false));
  const gridVisibleColumnFieldsSelector = createSelectorMemoized(gridVisibleColumnDefinitionsSelector, (visibleColumns) => visibleColumns.map((column2) => column2.field));
  const gridColumnPositionsSelector = createSelectorMemoized(gridVisibleColumnDefinitionsSelector, (visibleColumns) => {
    const positions = [];
    let currentPosition = 0;
    for (let i = 0; i < visibleColumns.length; i += 1) {
      positions.push(currentPosition);
      currentPosition += visibleColumns[i].computedWidth;
    }
    return positions;
  });
  const gridColumnsTotalWidthSelector = createSelector(gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector, (visibleColumns, positions) => {
    const colCount = visibleColumns.length;
    if (colCount === 0) {
      return 0;
    }
    return positions[colCount - 1] + visibleColumns[colCount - 1].computedWidth;
  });
  const gridFilterableColumnDefinitionsSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns) => columns.filter((col) => col.filterable));
  const gridFilterableColumnLookupSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns) => columns.reduce((acc, col) => {
    if (col.filterable) {
      acc[col.field] = col;
    }
    return acc;
  }, {}));
  const gridColumnGroupingSelector = (state) => state.columnGrouping;
  const gridColumnGroupsUnwrappedModelSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => {
    var _columnGrouping$unwra;
    return (_columnGrouping$unwra = columnGrouping == null ? void 0 : columnGrouping.unwrappedGroupingModel) != null ? _columnGrouping$unwra : {};
  });
  const gridColumnGroupsLookupSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => {
    var _columnGrouping$looku;
    return (_columnGrouping$looku = columnGrouping == null ? void 0 : columnGrouping.lookup) != null ? _columnGrouping$looku : {};
  });
  const gridColumnGroupsHeaderStructureSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => {
    var _columnGrouping$heade;
    return (_columnGrouping$heade = columnGrouping == null ? void 0 : columnGrouping.headerStructure) != null ? _columnGrouping$heade : [];
  });
  const gridColumnGroupsHeaderMaxDepthSelector = createSelector(gridColumnGroupingSelector, (columnGrouping) => {
    var _columnGrouping$maxDe;
    return (_columnGrouping$maxDe = columnGrouping == null ? void 0 : columnGrouping.maxDepth) != null ? _columnGrouping$maxDe : 0;
  });
  const gridRowsStateSelector = (state) => state.rows;
  const gridRowCountSelector = createSelector(gridRowsStateSelector, (rows) => rows.totalRowCount);
  const gridRowsLoadingSelector = createSelector(gridRowsStateSelector, (rows) => rows.loading);
  const gridTopLevelRowCountSelector = createSelector(gridRowsStateSelector, (rows) => rows.totalTopLevelRowCount);
  const gridRowsLookupSelector = createSelector(gridRowsStateSelector, (rows) => rows.dataRowIdToModelLookup);
  const gridRowsDataRowIdToIdLookupSelector = createSelector(gridRowsStateSelector, (rows) => rows.dataRowIdToIdLookup);
  const gridRowTreeSelector = createSelector(gridRowsStateSelector, (rows) => rows.tree);
  const gridRowGroupingNameSelector = createSelector(gridRowsStateSelector, (rows) => rows.groupingName);
  const gridRowTreeDepthsSelector = createSelector(gridRowsStateSelector, (rows) => rows.treeDepths);
  const gridRowMaximumTreeDepthSelector = createSelectorMemoized(gridRowsStateSelector, (rows) => {
    const entries = Object.entries(rows.treeDepths);
    if (entries.length === 0) {
      return 1;
    }
    return entries.filter(([, nodeCount]) => nodeCount > 0).map(([depth]) => Number(depth)).sort((a, b2) => b2 - a)[0] + 1;
  });
  const gridDataRowIdsSelector = createSelector(gridRowsStateSelector, (rows) => rows.dataRowIds);
  const gridAdditionalRowGroupsSelector = createSelector(gridRowsStateSelector, (rows) => rows == null ? void 0 : rows.additionalRowGroups);
  const gridPinnedRowsSelector = createSelectorMemoized(gridAdditionalRowGroupsSelector, (additionalRowGroups) => {
    var _rawPinnedRows$bottom, _rawPinnedRows$top;
    const rawPinnedRows = additionalRowGroups == null ? void 0 : additionalRowGroups.pinnedRows;
    return {
      bottom: rawPinnedRows == null || (_rawPinnedRows$bottom = rawPinnedRows.bottom) == null ? void 0 : _rawPinnedRows$bottom.map((rowEntry) => {
        var _rowEntry$model;
        return {
          id: rowEntry.id,
          model: (_rowEntry$model = rowEntry.model) != null ? _rowEntry$model : {}
        };
      }),
      top: rawPinnedRows == null || (_rawPinnedRows$top = rawPinnedRows.top) == null ? void 0 : _rawPinnedRows$top.map((rowEntry) => {
        var _rowEntry$model2;
        return {
          id: rowEntry.id,
          model: (_rowEntry$model2 = rowEntry.model) != null ? _rowEntry$model2 : {}
        };
      })
    };
  });
  const gridPinnedRowsCountSelector = createSelector(gridPinnedRowsSelector, (pinnedRows) => {
    var _pinnedRows$top, _pinnedRows$bottom;
    return ((pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.length) || 0) + ((pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.length) || 0);
  });
  const useGridAriaAttributes = () => {
    var _rootProps$experiment;
    const apiRef2 = useGridPrivateApiContext();
    const rootProps = useGridRootProps();
    const visibleColumns = useGridSelector(apiRef2, gridVisibleColumnDefinitionsSelector);
    const totalRowCount = useGridSelector(apiRef2, gridRowCountSelector);
    const headerGroupingMaxDepth = useGridSelector(apiRef2, gridColumnGroupsHeaderMaxDepthSelector);
    const pinnedRowsCount = useGridSelector(apiRef2, gridPinnedRowsCountSelector);
    let role = "grid";
    if ((_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.ariaV7 && rootProps.treeData) {
      role = "treegrid";
    }
    return {
      role,
      "aria-colcount": visibleColumns.length,
      "aria-rowcount": headerGroupingMaxDepth + 1 + pinnedRowsCount + totalRowCount,
      "aria-multiselectable": !rootProps.disableMultipleRowSelection
    };
  };
  const useUtilityClasses$1c = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["main"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridMainContainerRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "Main",
    overridesResolver: (props, styles2) => styles2.main
  })(() => ({
    position: "relative",
    flexGrow: 1,
    display: "flex",
    flexDirection: "column",
    overflow: "hidden"
  }));
  const GridMainContainer = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    var _rootProps$experiment;
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$1c(rootProps);
    const getAriaAttributes = (_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.ariaV7 ? useGridAriaAttributes : null;
    const ariaAttributes = typeof getAriaAttributes === "function" ? getAriaAttributes() : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMainContainerRoot, _extends({
      ref,
      className: classes.root,
      ownerState: rootProps
    }, ariaAttributes, {
      children: props.children
    }));
  });
  const gridSortingStateSelector = (state) => state.sorting;
  const gridSortedRowIdsSelector = createSelector(gridSortingStateSelector, (sortingState) => sortingState.sortedRows);
  const gridSortedRowEntriesSelector = createSelectorMemoized(
    gridSortedRowIdsSelector,
    gridRowsLookupSelector,
    // TODO rows v6: Is this the best approach ?
    (sortedIds, idRowsLookup) => sortedIds.map((id) => {
      var _idRowsLookup$id;
      return {
        id,
        model: (_idRowsLookup$id = idRowsLookup[id]) != null ? _idRowsLookup$id : {}
      };
    })
  );
  const gridSortModelSelector = createSelector(gridSortingStateSelector, (sorting) => sorting.sortModel);
  const gridSortColumnLookupSelector = createSelectorMemoized(gridSortModelSelector, (sortModel) => {
    const result = sortModel.reduce((res, sortItem, index) => {
      res[sortItem.field] = {
        sortDirection: sortItem.sort,
        sortIndex: sortModel.length > 1 ? index + 1 : void 0
      };
      return res;
    }, {});
    return result;
  });
  const gridFilterStateSelector = (state) => state.filter;
  const gridFilterModelSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filterModel);
  const gridQuickFilterValuesSelector = createSelector(gridFilterModelSelector, (filterModel2) => filterModel2.quickFilterValues);
  const gridVisibleRowsLookupSelector = (state) => state.visibleRowsLookup;
  const gridFilteredRowsLookupSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filteredRowsLookup);
  createSelector(gridFilterStateSelector, (filterState) => filterState.filteredDescendantCountLookup);
  const gridExpandedSortedRowEntriesSelector = createSelectorMemoized(gridVisibleRowsLookupSelector, gridSortedRowEntriesSelector, (visibleRowsLookup, sortedRows) => sortedRows.filter((row) => visibleRowsLookup[row.id] !== false));
  const gridExpandedSortedRowIdsSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, (visibleSortedRowEntries) => visibleSortedRowEntries.map((row) => row.id));
  const gridFilteredSortedRowEntriesSelector = createSelectorMemoized(gridFilteredRowsLookupSelector, gridSortedRowEntriesSelector, (filteredRowsLookup, sortedRows) => sortedRows.filter((row) => filteredRowsLookup[row.id] !== false));
  const gridFilteredSortedRowIdsSelector = createSelectorMemoized(gridFilteredSortedRowEntriesSelector, (filteredSortedRowEntries) => filteredSortedRowEntries.map((row) => row.id));
  const gridFilteredSortedTopLevelRowEntriesSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, gridRowTreeSelector, gridRowMaximumTreeDepthSelector, (visibleSortedRows, rowTree, rowTreeDepth) => {
    if (rowTreeDepth < 2) {
      return visibleSortedRows;
    }
    return visibleSortedRows.filter((row) => {
      var _rowTree$row$id;
      return ((_rowTree$row$id = rowTree[row.id]) == null ? void 0 : _rowTree$row$id.depth) === 0;
    });
  });
  const gridExpandedRowCountSelector = createSelector(gridExpandedSortedRowEntriesSelector, (visibleSortedRows) => visibleSortedRows.length);
  const gridFilteredTopLevelRowCountSelector = createSelector(gridFilteredSortedTopLevelRowEntriesSelector, (visibleSortedTopLevelRows) => visibleSortedTopLevelRows.length);
  const gridFilterActiveItemsSelector = createSelectorMemoized(gridFilterModelSelector, gridColumnLookupSelector, (filterModel2, columnLookup) => {
    var _filterModel$items;
    return (_filterModel$items = filterModel2.items) == null ? void 0 : _filterModel$items.filter((item) => {
      var _column$filterOperato, _item$value;
      if (!item.field) {
        return false;
      }
      const column2 = columnLookup[item.field];
      if (!(column2 != null && column2.filterOperators) || (column2 == null || (_column$filterOperato = column2.filterOperators) == null ? void 0 : _column$filterOperato.length) === 0) {
        return false;
      }
      const filterOperator = column2.filterOperators.find((operator) => operator.value === item.operator);
      if (!filterOperator) {
        return false;
      }
      return !filterOperator.InputComponent || item.value != null && ((_item$value = item.value) == null ? void 0 : _item$value.toString()) !== "";
    });
  });
  const gridFilterActiveItemsLookupSelector = createSelectorMemoized(gridFilterActiveItemsSelector, (activeFilters) => {
    const result = activeFilters.reduce((res, filterItem2) => {
      if (!res[filterItem2.field]) {
        res[filterItem2.field] = [filterItem2];
      } else {
        res[filterItem2.field].push(filterItem2);
      }
      return res;
    }, {});
    return result;
  });
  const gridFocusStateSelector = (state) => state.focus;
  const gridFocusCellSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.cell);
  const gridFocusColumnHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeader);
  createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeaderFilter);
  const unstable_gridFocusColumnGroupHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnGroupHeader);
  const gridTabIndexStateSelector = (state) => state.tabIndex;
  const gridTabIndexCellSelector = createSelector(gridTabIndexStateSelector, (state) => state.cell);
  const gridTabIndexColumnHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnHeader);
  createSelector(gridTabIndexStateSelector, (state) => state.columnHeaderFilter);
  const unstable_gridTabIndexColumnGroupHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnGroupHeader);
  const gridDensitySelector = (state) => state.density;
  const gridDensityValueSelector = createSelector(gridDensitySelector, (density) => density.value);
  const gridDensityFactorSelector = createSelector(gridDensitySelector, (density) => density.factor);
  const gridColumnMenuSelector = (state) => state.columnMenu;
  function GridBody(props) {
    const {
      VirtualScrollerComponent,
      ColumnHeadersProps,
      children
    } = props;
    const apiRef2 = useGridPrivateApiContext();
    const rootProps = useGridRootProps();
    const rootRef = React__namespace.useRef(null);
    const visibleColumns = useGridSelector(apiRef2, gridVisibleColumnDefinitionsSelector);
    const filterColumnLookup = useGridSelector(apiRef2, gridFilterActiveItemsLookupSelector);
    const sortColumnLookup = useGridSelector(apiRef2, gridSortColumnLookupSelector);
    const columnPositions = useGridSelector(apiRef2, gridColumnPositionsSelector);
    const columnHeaderTabIndexState = useGridSelector(apiRef2, gridTabIndexColumnHeaderSelector);
    const cellTabIndexState = useGridSelector(apiRef2, gridTabIndexCellSelector);
    const columnGroupHeaderTabIndexState = useGridSelector(apiRef2, unstable_gridTabIndexColumnGroupHeaderSelector);
    const columnHeaderFocus = useGridSelector(apiRef2, gridFocusColumnHeaderSelector);
    const columnGroupHeaderFocus = useGridSelector(apiRef2, unstable_gridFocusColumnGroupHeaderSelector);
    const densityFactor = useGridSelector(apiRef2, gridDensityFactorSelector);
    const headerGroupingMaxDepth = useGridSelector(apiRef2, gridColumnGroupsHeaderMaxDepthSelector);
    const columnMenuState = useGridSelector(apiRef2, gridColumnMenuSelector);
    const columnVisibility = useGridSelector(apiRef2, gridColumnVisibilityModelSelector);
    const columnGroupsHeaderStructure = useGridSelector(apiRef2, gridColumnGroupsHeaderStructureSelector);
    const hasOtherElementInTabSequence = !(columnGroupHeaderTabIndexState === null && columnHeaderTabIndexState === null && cellTabIndexState === null);
    const [isVirtualizationDisabled, setIsVirtualizationDisabled] = React__namespace.useState(rootProps.disableVirtualization);
    useEnhancedEffect$1(() => {
      apiRef2.current.computeSizeAndPublishResizeEvent();
      const elementToObserve = rootRef.current;
      if (typeof ResizeObserver === "undefined") {
        return () => {
        };
      }
      let animationFrame;
      const observer = new ResizeObserver(() => {
        animationFrame = window.requestAnimationFrame(() => {
          apiRef2.current.computeSizeAndPublishResizeEvent();
        });
      });
      if (elementToObserve) {
        observer.observe(elementToObserve);
      }
      return () => {
        if (animationFrame) {
          window.cancelAnimationFrame(animationFrame);
        }
        if (elementToObserve) {
          observer.unobserve(elementToObserve);
        }
      };
    }, [apiRef2]);
    const disableVirtualization = React__namespace.useCallback(() => {
      setIsVirtualizationDisabled(true);
    }, []);
    const enableVirtualization = React__namespace.useCallback(() => {
      setIsVirtualizationDisabled(false);
    }, []);
    React__namespace.useEffect(() => {
      setIsVirtualizationDisabled(rootProps.disableVirtualization);
    }, [rootProps.disableVirtualization]);
    apiRef2.current.unstable_disableVirtualization = disableVirtualization;
    apiRef2.current.unstable_enableVirtualization = enableVirtualization;
    const columnHeadersRef = React__namespace.useRef(null);
    const columnsContainerRef = React__namespace.useRef(null);
    const virtualScrollerRef = React__namespace.useRef(null);
    apiRef2.current.register("private", {
      columnHeadersContainerElementRef: columnsContainerRef,
      columnHeadersElementRef: columnHeadersRef,
      virtualScrollerRef,
      mainElementRef: rootRef
    });
    const hasDimensions = !!apiRef2.current.getRootDimensions();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridMainContainer, {
      ref: rootRef,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaders, _extends({
        ref: columnsContainerRef,
        innerRef: columnHeadersRef,
        visibleColumns,
        filterColumnLookup,
        sortColumnLookup,
        columnPositions,
        columnHeaderTabIndexState,
        columnGroupHeaderTabIndexState,
        columnHeaderFocus,
        columnGroupHeaderFocus,
        densityFactor,
        headerGroupingMaxDepth,
        columnMenuState,
        columnVisibility,
        columnGroupsHeaderStructure,
        hasOtherElementInTabSequence
      }, ColumnHeadersProps)), hasDimensions && /* @__PURE__ */ jsxRuntimeExports.jsx(
        VirtualScrollerComponent,
        {
          ref: virtualScrollerRef,
          disableVirtualization: isVirtualizationDisabled
        }
      ), children]
    });
  }
  function GridFooterPlaceholder() {
    var _rootProps$slotProps;
    const rootProps = useGridRootProps();
    if (rootProps.hideFooter) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.footer, _extends({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.footer));
  }
  const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;
  const GRID_ID_AUTOGENERATED = Symbol("mui.id_autogenerated");
  const buildRootGroup = () => ({
    type: "group",
    id: GRID_ROOT_GROUP_ID,
    depth: -1,
    groupingField: null,
    groupingKey: null,
    isAutoGenerated: true,
    children: [],
    childrenFromPath: {},
    childrenExpanded: true,
    parent: null
  });
  function checkGridRowIdIsValid(id, row, detailErrorMessage = "A row was provided without id in the rows prop:") {
    if (id == null) {
      throw new Error(["MUI: The data grid component requires all rows to have a unique `id` property.", "Alternatively, you can use the `getRowId` prop to specify a custom id for each row.", detailErrorMessage, JSON.stringify(row)].join("\n"));
    }
  }
  const getRowIdFromRowModel = (rowModel, getRowId2, detailErrorMessage) => {
    const id = getRowId2 ? getRowId2(rowModel) : rowModel.id;
    checkGridRowIdIsValid(id, rowModel, detailErrorMessage);
    return id;
  };
  const createRowsInternalCache = ({
    rows,
    getRowId: getRowId2,
    loading,
    rowCount
  }) => {
    const updates = {
      type: "full",
      rows: []
    };
    const dataRowIdToModelLookup = {};
    const dataRowIdToIdLookup = {};
    for (let i = 0; i < rows.length; i += 1) {
      const model = rows[i];
      const id = getRowIdFromRowModel(model, getRowId2);
      dataRowIdToModelLookup[id] = model;
      dataRowIdToIdLookup[id] = id;
      updates.rows.push(id);
    }
    return {
      rowsBeforePartialUpdates: rows,
      loadingPropBeforePartialUpdates: loading,
      rowCountPropBeforePartialUpdates: rowCount,
      updates,
      dataRowIdToIdLookup,
      dataRowIdToModelLookup
    };
  };
  const getTopLevelRowCount = ({
    tree,
    rowCountProp = 0
  }) => {
    const rootGroupNode = tree[GRID_ROOT_GROUP_ID];
    return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));
  };
  const getRowsStateFromCache = ({
    apiRef: apiRef2,
    rowCountProp = 0,
    loadingProp,
    previousTree,
    previousTreeDepths
  }) => {
    const cache = apiRef2.current.caches.rows;
    const {
      tree: unProcessedTree,
      treeDepths: unProcessedTreeDepths,
      dataRowIds: unProcessedDataRowIds,
      groupingName
    } = apiRef2.current.applyStrategyProcessor("rowTreeCreation", {
      previousTree,
      previousTreeDepths,
      updates: cache.updates,
      dataRowIdToIdLookup: cache.dataRowIdToIdLookup,
      dataRowIdToModelLookup: cache.dataRowIdToModelLookup
    });
    const groupingParamsWithHydrateRows = apiRef2.current.unstable_applyPipeProcessors("hydrateRows", {
      tree: unProcessedTree,
      treeDepths: unProcessedTreeDepths,
      dataRowIdToIdLookup: cache.dataRowIdToIdLookup,
      dataRowIds: unProcessedDataRowIds,
      dataRowIdToModelLookup: cache.dataRowIdToModelLookup
    });
    apiRef2.current.caches.rows.updates = {
      type: "partial",
      actions: {
        insert: [],
        modify: [],
        remove: []
      },
      idToActionLookup: {}
    };
    return _extends({}, groupingParamsWithHydrateRows, {
      totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),
      totalTopLevelRowCount: getTopLevelRowCount({
        tree: groupingParamsWithHydrateRows.tree,
        rowCountProp
      }),
      groupingName,
      loading: loadingProp
    });
  };
  const isAutoGeneratedRow = (rowNode) => rowNode.type === "skeletonRow" || rowNode.type === "footer" || rowNode.type === "group" && rowNode.isAutoGenerated || rowNode.type === "pinnedRow" && rowNode.isAutoGenerated;
  const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {
    const node2 = tree[parentId];
    if (node2.type !== "group") {
      return [];
    }
    const validDescendants = [];
    for (let i = 0; i < node2.children.length; i += 1) {
      const child = node2.children[i];
      if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {
        validDescendants.push(child);
      }
      validDescendants.push(...getTreeNodeDescendants(tree, child, skipAutoGeneratedRows));
    }
    if (!skipAutoGeneratedRows && node2.footerId != null) {
      validDescendants.push(node2.footerId);
    }
    return validDescendants;
  };
  const updateCacheWithNewRows = ({
    previousCache,
    getRowId: getRowId2,
    updates
  }) => {
    var _previousCache$update, _previousCache$update2, _previousCache$update3;
    if (previousCache.updates.type === "full") {
      throw new Error("MUI: Unable to prepare a partial update if a full update is not applied yet");
    }
    const uniqueUpdates = /* @__PURE__ */ new Map();
    updates.forEach((update) => {
      const id = getRowIdFromRowModel(update, getRowId2, "A row was provided without id when calling updateRows():");
      if (uniqueUpdates.has(id)) {
        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));
      } else {
        uniqueUpdates.set(id, update);
      }
    });
    const partialUpdates = {
      type: "partial",
      actions: {
        insert: [...(_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : []],
        modify: [...(_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : []],
        remove: [...(_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : []]
      },
      idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)
    };
    const dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);
    const dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);
    const alreadyAppliedActionsToRemove = {
      insert: {},
      modify: {},
      remove: {}
    };
    uniqueUpdates.forEach((partialRow, id) => {
      const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];
      if (partialRow._action === "delete") {
        if (actionAlreadyAppliedToRow === "remove" || !dataRowIdToModelLookup[id]) {
          return;
        }
        if (actionAlreadyAppliedToRow != null) {
          alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;
        }
        partialUpdates.actions.remove.push(id);
        delete dataRowIdToModelLookup[id];
        delete dataRowIdToIdLookup[id];
        return;
      }
      const oldRow = dataRowIdToModelLookup[id];
      if (oldRow) {
        if (actionAlreadyAppliedToRow === "remove") {
          alreadyAppliedActionsToRemove.remove[id] = true;
          partialUpdates.actions.modify.push(id);
        } else if (actionAlreadyAppliedToRow == null) {
          partialUpdates.actions.modify.push(id);
        }
        dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);
        return;
      }
      if (actionAlreadyAppliedToRow === "remove") {
        alreadyAppliedActionsToRemove.remove[id] = true;
        partialUpdates.actions.insert.push(id);
      } else if (actionAlreadyAppliedToRow == null) {
        partialUpdates.actions.insert.push(id);
      }
      dataRowIdToModelLookup[id] = partialRow;
      dataRowIdToIdLookup[id] = id;
    });
    const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);
    for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {
      const actionType = actionTypeWithActionsToRemove[i];
      const idsToRemove = alreadyAppliedActionsToRemove[actionType];
      if (Object.keys(idsToRemove).length > 0) {
        partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter((id) => !idsToRemove[id]);
      }
    }
    return {
      dataRowIdToModelLookup,
      dataRowIdToIdLookup,
      updates: partialUpdates,
      rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,
      loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,
      rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates
    };
  };
  function calculatePinnedRowsHeight(apiRef2) {
    var _pinnedRows$top, _pinnedRows$bottom;
    const pinnedRows = gridPinnedRowsSelector(apiRef2);
    const topPinnedRowsHeight = (pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce((acc, value) => {
      acc += apiRef2.current.unstable_getRowHeight(value.id);
      return acc;
    }, 0)) || 0;
    const bottomPinnedRowsHeight = (pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce((acc, value) => {
      acc += apiRef2.current.unstable_getRowHeight(value.id);
      return acc;
    }, 0)) || 0;
    return {
      top: topPinnedRowsHeight,
      bottom: bottomPinnedRowsHeight
    };
  }
  function getMinimalContentHeight(apiRef2, rowHeight) {
    const densityFactor = gridDensityFactorSelector(apiRef2);
    return 2 * Math.floor(rowHeight * densityFactor);
  }
  const GridOverlayWrapperRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "OverlayWrapper",
    overridesResolver: (props, styles2) => styles2.overlayWrapper
  })({
    position: "sticky",
    // To stay in place while scrolling
    top: 0,
    left: 0,
    width: 0,
    // To stay above the content instead of shifting it down
    height: 0,
    // To stay above the content instead of shifting it down
    zIndex: 4
    // Should be above pinned columns, pinned rows and detail panel
  });
  const GridOverlayWrapperInner = styled$3("div", {
    name: "MuiDataGrid",
    slot: "OverlayWrapperInner",
    overridesResolver: (props, styles2) => styles2.overlayWrapperInner
  })({});
  const useUtilityClasses$1b = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["overlayWrapper"],
      inner: ["overlayWrapperInner"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridOverlayWrapper(props) {
    var _viewportInnerSize$he, _viewportInnerSize$wi;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const [viewportInnerSize, setViewportInnerSize] = React__namespace.useState(() => {
      var _apiRef$current$getRo, _apiRef$current$getRo2;
      return (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef2.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize) != null ? _apiRef$current$getRo : null;
    });
    const handleViewportSizeChange = React__namespace.useCallback(() => {
      var _apiRef$current$getRo3, _apiRef$current$getRo4;
      setViewportInnerSize((_apiRef$current$getRo3 = (_apiRef$current$getRo4 = apiRef2.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo4.viewportInnerSize) != null ? _apiRef$current$getRo3 : null);
    }, [apiRef2]);
    useEnhancedEffect$1(() => {
      return apiRef2.current.subscribeEvent("viewportInnerSizeChange", handleViewportSizeChange);
    }, [apiRef2, handleViewportSizeChange]);
    let height2 = (_viewportInnerSize$he = viewportInnerSize == null ? void 0 : viewportInnerSize.height) != null ? _viewportInnerSize$he : 0;
    if (rootProps.autoHeight && height2 === 0) {
      height2 = getMinimalContentHeight(apiRef2, rootProps.rowHeight);
    }
    const classes = useUtilityClasses$1b(_extends({}, props, {
      classes: rootProps.classes
    }));
    if (!viewportInnerSize) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapperRoot, {
      className: clsx(classes.root),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapperInner, _extends({
        className: clsx(classes.inner),
        style: {
          height: height2,
          width: (_viewportInnerSize$wi = viewportInnerSize == null ? void 0 : viewportInnerSize.width) != null ? _viewportInnerSize$wi : 0
        }
      }, props))
    });
  }
  function GridOverlays() {
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const totalRowCount = useGridSelector(apiRef2, gridRowCountSelector);
    const visibleRowCount = useGridSelector(apiRef2, gridExpandedRowCountSelector);
    const loading = useGridSelector(apiRef2, gridRowsLoadingSelector);
    const showNoRowsOverlay = !loading && totalRowCount === 0;
    const showNoResultsOverlay = !loading && totalRowCount > 0 && visibleRowCount === 0;
    let overlay = null;
    if (showNoRowsOverlay) {
      var _rootProps$slotProps;
      overlay = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.noRowsOverlay, _extends({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.noRowsOverlay));
    }
    if (showNoResultsOverlay) {
      var _rootProps$slotProps2;
      overlay = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.noResultsOverlay, _extends({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.noResultsOverlay));
    }
    if (loading) {
      var _rootProps$slotProps3;
      overlay = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadingOverlay, _extends({}, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.loadingOverlay));
    }
    if (overlay === null) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapper, {
      children: overlay
    });
  }
  function fastMemo(component) {
    return /* @__PURE__ */ React__namespace.memo(component, fastObjectShallowCompare);
  }
  let cachedSupportsPreventScroll;
  function doesSupportPreventScroll() {
    if (cachedSupportsPreventScroll === void 0) {
      document.createElement("div").focus({
        get preventScroll() {
          cachedSupportsPreventScroll = true;
          return false;
        }
      });
    }
    return cachedSupportsPreventScroll;
  }
  var GridEditModes = /* @__PURE__ */ function(GridEditModes2) {
    GridEditModes2["Cell"] = "cell";
    GridEditModes2["Row"] = "row";
    return GridEditModes2;
  }(GridEditModes || {});
  var GridCellModes = /* @__PURE__ */ function(GridCellModes2) {
    GridCellModes2["Edit"] = "edit";
    GridCellModes2["View"] = "view";
    return GridCellModes2;
  }(GridCellModes || {});
  var GridRowModes = /* @__PURE__ */ function(GridRowModes2) {
    GridRowModes2["Edit"] = "edit";
    GridRowModes2["View"] = "view";
    return GridRowModes2;
  }(GridRowModes || {});
  var GridLogicOperator = /* @__PURE__ */ function(GridLogicOperator2) {
    GridLogicOperator2["And"] = "and";
    GridLogicOperator2["Or"] = "or";
    return GridLogicOperator2;
  }(GridLogicOperator || {});
  var GridCellEditStartReasons = /* @__PURE__ */ function(GridCellEditStartReasons2) {
    GridCellEditStartReasons2["enterKeyDown"] = "enterKeyDown";
    GridCellEditStartReasons2["cellDoubleClick"] = "cellDoubleClick";
    GridCellEditStartReasons2["printableKeyDown"] = "printableKeyDown";
    GridCellEditStartReasons2["deleteKeyDown"] = "deleteKeyDown";
    return GridCellEditStartReasons2;
  }(GridCellEditStartReasons || {});
  var GridCellEditStopReasons = /* @__PURE__ */ function(GridCellEditStopReasons2) {
    GridCellEditStopReasons2["cellFocusOut"] = "cellFocusOut";
    GridCellEditStopReasons2["escapeKeyDown"] = "escapeKeyDown";
    GridCellEditStopReasons2["enterKeyDown"] = "enterKeyDown";
    GridCellEditStopReasons2["tabKeyDown"] = "tabKeyDown";
    GridCellEditStopReasons2["shiftTabKeyDown"] = "shiftTabKeyDown";
    return GridCellEditStopReasons2;
  }(GridCellEditStopReasons || {});
  var GridRowEditStartReasons = /* @__PURE__ */ function(GridRowEditStartReasons2) {
    GridRowEditStartReasons2["enterKeyDown"] = "enterKeyDown";
    GridRowEditStartReasons2["cellDoubleClick"] = "cellDoubleClick";
    GridRowEditStartReasons2["printableKeyDown"] = "printableKeyDown";
    GridRowEditStartReasons2["deleteKeyDown"] = "deleteKeyDown";
    return GridRowEditStartReasons2;
  }(GridRowEditStartReasons || {});
  var GridRowEditStopReasons = /* @__PURE__ */ function(GridRowEditStopReasons2) {
    GridRowEditStopReasons2["rowFocusOut"] = "rowFocusOut";
    GridRowEditStopReasons2["escapeKeyDown"] = "escapeKeyDown";
    GridRowEditStopReasons2["enterKeyDown"] = "enterKeyDown";
    GridRowEditStopReasons2["tabKeyDown"] = "tabKeyDown";
    GridRowEditStopReasons2["shiftTabKeyDown"] = "shiftTabKeyDown";
    return GridRowEditStopReasons2;
  }(GridRowEditStopReasons || {});
  function isLeaf(node2) {
    return node2.field !== void 0;
  }
  function isOverflown(element) {
    return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
  }
  function findParentElementFromClassName(elem, className) {
    return elem.closest(`.${className}`);
  }
  function escapeOperandAttributeSelector(operand) {
    return operand.replace(/["\\]/g, "\\$&");
  }
  function getGridColumnHeaderElement(root, field) {
    return root.querySelector(`[role="columnheader"][data-field="${escapeOperandAttributeSelector(field)}"]`);
  }
  function getGridRowElementSelector(id) {
    return `.${gridClasses.row}[data-id="${escapeOperandAttributeSelector(String(id))}"]`;
  }
  function getGridRowElement(root, id) {
    return root.querySelector(getGridRowElementSelector(id));
  }
  function getGridCellElement(root, {
    id,
    field
  }) {
    const rowSelector = getGridRowElementSelector(id);
    const cellSelector = `.${gridClasses.cell}[data-field="${escapeOperandAttributeSelector(field)}"]`;
    const selector = `${rowSelector} ${cellSelector}`;
    return root.querySelector(selector);
  }
  function useGridApiMethod(privateApiRef, apiMethods, visibility) {
    const isFirstRender = React__namespace.useRef(true);
    React__namespace.useEffect(() => {
      isFirstRender.current = false;
      privateApiRef.current.register(visibility, apiMethods);
    }, [privateApiRef, visibility, apiMethods]);
    if (isFirstRender.current) {
      privateApiRef.current.register(visibility, apiMethods);
    }
  }
  class MissingRowIdError extends Error {
  }
  function useGridParamsApi(apiRef2, props) {
    const {
      getRowId: getRowId2
    } = props;
    const getColumnHeaderParams = React__namespace.useCallback((field) => ({
      field,
      colDef: apiRef2.current.getColumn(field)
    }), [apiRef2]);
    const getRowParams = React__namespace.useCallback((id) => {
      const row = apiRef2.current.getRow(id);
      if (!row) {
        throw new MissingRowIdError(`No row with id #${id} found`);
      }
      const params = {
        id,
        columns: apiRef2.current.getAllColumns(),
        row
      };
      return params;
    }, [apiRef2]);
    const getBaseCellParams = React__namespace.useCallback((id, field) => {
      const row = apiRef2.current.getRow(id);
      const rowNode = apiRef2.current.getRowNode(id);
      if (!row || !rowNode) {
        throw new MissingRowIdError(`No row with id #${id} found`);
      }
      const cellFocus = gridFocusCellSelector(apiRef2);
      const cellTabIndex = gridTabIndexCellSelector(apiRef2);
      const params = {
        id,
        field,
        row,
        rowNode,
        value: row[field],
        colDef: apiRef2.current.getColumn(field),
        cellMode: apiRef2.current.getCellMode(id, field),
        api: apiRef2.current,
        hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id,
        tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id ? 0 : -1
      };
      return params;
    }, [apiRef2]);
    const getCellParams = React__namespace.useCallback((id, field) => {
      const colDef = apiRef2.current.getColumn(field);
      const value = apiRef2.current.getCellValue(id, field);
      const row = apiRef2.current.getRow(id);
      const rowNode = apiRef2.current.getRowNode(id);
      if (!row || !rowNode) {
        throw new MissingRowIdError(`No row with id #${id} found`);
      }
      const cellFocus = gridFocusCellSelector(apiRef2);
      const cellTabIndex = gridTabIndexCellSelector(apiRef2);
      const params = {
        id,
        field,
        row,
        rowNode,
        colDef,
        cellMode: apiRef2.current.getCellMode(id, field),
        hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id,
        tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id ? 0 : -1,
        value,
        formattedValue: value,
        isEditable: false
      };
      if (colDef && colDef.valueFormatter) {
        params.formattedValue = colDef.valueFormatter({
          id,
          field: params.field,
          value: params.value,
          api: apiRef2.current
        });
      }
      params.isEditable = colDef && apiRef2.current.isCellEditable(params);
      return params;
    }, [apiRef2]);
    const getCellValue = React__namespace.useCallback((id, field) => {
      const colDef = apiRef2.current.getColumn(field);
      if (!colDef || !colDef.valueGetter) {
        const rowModel = apiRef2.current.getRow(id);
        if (!rowModel) {
          throw new MissingRowIdError(`No row with id #${id} found`);
        }
        return rowModel[field];
      }
      return colDef.valueGetter(getBaseCellParams(id, field));
    }, [apiRef2, getBaseCellParams]);
    const getRowValue = React__namespace.useCallback((row, colDef) => {
      var _getRowId;
      const id = GRID_ID_AUTOGENERATED in row ? row[GRID_ID_AUTOGENERATED] : (_getRowId = getRowId2 == null ? void 0 : getRowId2(row)) != null ? _getRowId : row.id;
      const field = colDef.field;
      if (!colDef || !colDef.valueGetter) {
        return row[field];
      }
      return colDef.valueGetter(getBaseCellParams(id, field));
    }, [getBaseCellParams, getRowId2]);
    const getRowFormattedValue = React__namespace.useCallback((row, colDef) => {
      var _ref;
      const value = getRowValue(row, colDef);
      if (!colDef || !colDef.valueFormatter) {
        return value;
      }
      const id = (_ref = getRowId2 ? getRowId2(row) : row.id) != null ? _ref : row[GRID_ID_AUTOGENERATED];
      const field = colDef.field;
      return colDef.valueFormatter({
        id,
        field,
        value,
        api: apiRef2.current
      });
    }, [apiRef2, getRowId2, getRowValue]);
    const getColumnHeaderElement = React__namespace.useCallback((field) => {
      if (!apiRef2.current.rootElementRef.current) {
        return null;
      }
      return getGridColumnHeaderElement(apiRef2.current.rootElementRef.current, field);
    }, [apiRef2]);
    const getRowElement = React__namespace.useCallback((id) => {
      if (!apiRef2.current.rootElementRef.current) {
        return null;
      }
      return getGridRowElement(apiRef2.current.rootElementRef.current, id);
    }, [apiRef2]);
    const getCellElement = React__namespace.useCallback((id, field) => {
      if (!apiRef2.current.rootElementRef.current) {
        return null;
      }
      return getGridCellElement(apiRef2.current.rootElementRef.current, {
        id,
        field
      });
    }, [apiRef2]);
    const paramsApi = {
      getCellValue,
      getCellParams,
      getCellElement,
      getRowValue,
      getRowFormattedValue,
      getRowParams,
      getRowElement,
      getColumnHeaderParams,
      getColumnHeaderElement
    };
    useGridApiMethod(apiRef2, paramsApi, "public");
  }
  const _excluded$1A = ["changeReason", "unstable_updateValueOnRender"], _excluded3$2 = ["column", "rowId", "editCellState", "align", "children", "colIndex", "height", "width", "className", "showRightBorder", "extendRowFullWidth", "row", "colSpan", "disableDragEvents", "isNotVisible", "onClick", "onDoubleClick", "onMouseDown", "onMouseUp", "onMouseOver", "onKeyDown", "onKeyUp", "onDragEnter", "onDragOver"], _excluded4 = ["changeReason", "unstable_updateValueOnRender"];
  const EMPTY_CELL_PARAMS = {
    id: -1,
    field: "__unset__",
    row: {},
    rowNode: {
      id: -1,
      depth: 0,
      type: "leaf",
      parent: -1,
      groupingKey: null
    },
    colDef: {
      type: "string",
      field: "__unset__",
      computedWidth: 0
    },
    cellMode: GridCellModes.View,
    hasFocus: false,
    tabIndex: -1,
    value: null,
    formattedValue: "__unset__",
    isEditable: false,
    api: {}
  };
  const useUtilityClasses$1a = (ownerState) => {
    const {
      align,
      showRightBorder,
      isEditable,
      isSelected,
      classes
    } = ownerState;
    const slots = {
      root: ["cell", `cell--text${capitalize(align)}`, isEditable && "cell--editable", isSelected && "selected", showRightBorder && "cell--withRightBorder", "withBorderColor"],
      content: ["cellContent"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridCellWrapper = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      column: column2,
      rowId,
      editCellState
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const field = column2.field;
    const cellParamsWithAPI = useGridSelector(apiRef2, () => {
      try {
        const cellParams = apiRef2.current.getCellParams(rowId, field);
        const result = cellParams;
        result.api = apiRef2.current;
        return result;
      } catch (e2) {
        if (e2 instanceof MissingRowIdError) {
          return EMPTY_CELL_PARAMS;
        }
        throw e2;
      }
    }, objectShallowCompare);
    const isSelected = useGridSelector(apiRef2, () => apiRef2.current.unstable_applyPipeProcessors("isCellSelected", false, {
      id: rowId,
      field
    }));
    if (cellParamsWithAPI === EMPTY_CELL_PARAMS) {
      return null;
    }
    const {
      cellMode,
      hasFocus,
      isEditable,
      value,
      formattedValue
    } = cellParamsWithAPI;
    const managesOwnFocus = column2.type === "actions";
    const tabIndex = (cellMode === "view" || !isEditable) && !managesOwnFocus ? cellParamsWithAPI.tabIndex : -1;
    const {
      classes: rootClasses,
      getCellClassName
    } = rootProps;
    const classNames = apiRef2.current.unstable_applyPipeProcessors("cellClassName", [], {
      id: rowId,
      field
    });
    if (column2.cellClassName) {
      classNames.push(typeof column2.cellClassName === "function" ? column2.cellClassName(cellParamsWithAPI) : column2.cellClassName);
    }
    if (getCellClassName) {
      classNames.push(getCellClassName(cellParamsWithAPI));
    }
    let children;
    if (editCellState == null && column2.renderCell) {
      children = column2.renderCell(cellParamsWithAPI);
      classNames.push(gridClasses["cell--withRenderer"]);
      classNames.push(rootClasses == null ? void 0 : rootClasses["cell--withRenderer"]);
    }
    if (editCellState != null && column2.renderEditCell) {
      const updatedRow = apiRef2.current.getRowWithUpdatedValues(rowId, column2.field);
      const editCellStateRest = _objectWithoutPropertiesLoose(editCellState, _excluded$1A);
      const params = _extends({}, cellParamsWithAPI, {
        row: updatedRow
      }, editCellStateRest);
      children = column2.renderEditCell(params);
      classNames.push(gridClasses["cell--editing"]);
      classNames.push(rootClasses == null ? void 0 : rootClasses["cell--editing"]);
    }
    const {
      slots
    } = rootProps;
    const CellComponent = slots.cell;
    const cellProps = _extends({}, props, {
      ref,
      field,
      formattedValue,
      hasFocus,
      isEditable,
      isSelected,
      value,
      cellMode,
      children,
      tabIndex,
      className: clsx(classNames)
    });
    return /* @__PURE__ */ React__namespace.createElement(CellComponent, cellProps);
  });
  const MemoizedCellWrapper = fastMemo(GridCellWrapper);
  const GridCellV7 = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    var _rootProps$experiment4;
    const {
      column: column2,
      rowId,
      editCellState,
      align,
      colIndex,
      height: height2,
      width: width2,
      className,
      showRightBorder,
      colSpan,
      disableDragEvents,
      isNotVisible,
      onClick,
      onDoubleClick,
      onMouseDown,
      onMouseUp,
      onMouseOver,
      onKeyDown,
      onKeyUp,
      onDragEnter,
      onDragOver
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded3$2);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const field = column2.field;
    const cellParamsWithAPI = useGridSelector(apiRef2, () => {
      try {
        const cellParams = apiRef2.current.getCellParams(rowId, field);
        const result = cellParams;
        result.api = apiRef2.current;
        return result;
      } catch (e2) {
        if (e2 instanceof MissingRowIdError) {
          return EMPTY_CELL_PARAMS;
        }
        throw e2;
      }
    }, objectShallowCompare);
    const isSelected = useGridSelector(apiRef2, () => apiRef2.current.unstable_applyPipeProcessors("isCellSelected", false, {
      id: rowId,
      field
    }));
    const {
      cellMode,
      hasFocus,
      isEditable,
      value,
      formattedValue
    } = cellParamsWithAPI;
    const managesOwnFocus = column2.type === "actions";
    const tabIndex = (cellMode === "view" || !isEditable) && !managesOwnFocus ? cellParamsWithAPI.tabIndex : -1;
    const {
      classes: rootClasses,
      getCellClassName
    } = rootProps;
    const classNames = apiRef2.current.unstable_applyPipeProcessors("cellClassName", [], {
      id: rowId,
      field
    });
    if (column2.cellClassName) {
      classNames.push(typeof column2.cellClassName === "function" ? column2.cellClassName(cellParamsWithAPI) : column2.cellClassName);
    }
    if (getCellClassName) {
      classNames.push(getCellClassName(cellParamsWithAPI));
    }
    const valueToRender = formattedValue == null ? value : formattedValue;
    const cellRef = React__namespace.useRef(null);
    const handleRef = useForkRef(ref, cellRef);
    const focusElementRef = React__namespace.useRef(null);
    const ownerState = {
      align,
      showRightBorder,
      isEditable,
      classes: rootProps.classes,
      isSelected
    };
    const classes = useUtilityClasses$1a(ownerState);
    const publishMouseUp = React__namespace.useCallback((eventName) => (event) => {
      const params = apiRef2.current.getCellParams(rowId, field || "");
      apiRef2.current.publishEvent(eventName, params, event);
      if (onMouseUp) {
        onMouseUp(event);
      }
    }, [apiRef2, field, onMouseUp, rowId]);
    const publishMouseDown = React__namespace.useCallback((eventName) => (event) => {
      const params = apiRef2.current.getCellParams(rowId, field || "");
      apiRef2.current.publishEvent(eventName, params, event);
      if (onMouseDown) {
        onMouseDown(event);
      }
    }, [apiRef2, field, onMouseDown, rowId]);
    const publish = React__namespace.useCallback((eventName, propHandler) => (event) => {
      if (!apiRef2.current.getRow(rowId)) {
        return;
      }
      const params = apiRef2.current.getCellParams(rowId, field || "");
      apiRef2.current.publishEvent(eventName, params, event);
      if (propHandler) {
        propHandler(event);
      }
    }, [apiRef2, field, rowId]);
    const style2 = React__namespace.useMemo(() => {
      if (isNotVisible) {
        return {
          padding: 0,
          opacity: 0,
          width: 0
        };
      }
      const cellStyle = {
        minWidth: width2,
        maxWidth: width2,
        minHeight: height2,
        maxHeight: height2 === "auto" ? "none" : height2
        // max-height doesn't support "auto"
      };
      return cellStyle;
    }, [width2, height2, isNotVisible]);
    React__namespace.useEffect(() => {
      if (!hasFocus || cellMode === GridCellModes.Edit) {
        return;
      }
      const doc = ownerDocument(apiRef2.current.rootElementRef.current);
      if (cellRef.current && !cellRef.current.contains(doc.activeElement)) {
        const focusableElement = cellRef.current.querySelector('[tabindex="0"]');
        const elementToFocus = focusElementRef.current || focusableElement || cellRef.current;
        if (doesSupportPreventScroll()) {
          elementToFocus.focus({
            preventScroll: true
          });
        } else {
          const scrollPosition = apiRef2.current.getScrollPosition();
          elementToFocus.focus();
          apiRef2.current.scroll(scrollPosition);
        }
      }
    }, [hasFocus, cellMode, apiRef2]);
    if (cellParamsWithAPI === EMPTY_CELL_PARAMS) {
      return null;
    }
    let handleFocus = other.onFocus;
    let children;
    if (editCellState == null && column2.renderCell) {
      children = column2.renderCell(cellParamsWithAPI);
      classNames.push(gridClasses["cell--withRenderer"]);
      classNames.push(rootClasses == null ? void 0 : rootClasses["cell--withRenderer"]);
    }
    if (editCellState != null && column2.renderEditCell) {
      const updatedRow = apiRef2.current.getRowWithUpdatedValues(rowId, column2.field);
      const editCellStateRest = _objectWithoutPropertiesLoose(editCellState, _excluded4);
      const params = _extends({}, cellParamsWithAPI, {
        row: updatedRow
      }, editCellStateRest);
      children = column2.renderEditCell(params);
      classNames.push(gridClasses["cell--editing"]);
      classNames.push(rootClasses == null ? void 0 : rootClasses["cell--editing"]);
    }
    if (children === void 0) {
      const valueString = valueToRender == null ? void 0 : valueToRender.toString();
      children = /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: classes.content,
        title: valueString,
        role: "presentation",
        children: valueString
      });
    }
    if (/* @__PURE__ */ React__namespace.isValidElement(children) && managesOwnFocus) {
      children = /* @__PURE__ */ React__namespace.cloneElement(children, {
        focusElementRef
      });
    }
    const draggableEventHandlers = disableDragEvents ? null : {
      onDragEnter: publish("cellDragEnter", onDragEnter),
      onDragOver: publish("cellDragOver", onDragOver)
    };
    const ariaV7 = (_rootProps$experiment4 = rootProps.experimentalFeatures) == null ? void 0 : _rootProps$experiment4.ariaV7;
    return (
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends({
        ref: handleRef,
        className: clsx(className, classNames, classes.root),
        role: ariaV7 ? "gridcell" : "cell",
        "data-field": field,
        "data-colindex": colIndex,
        "aria-colindex": colIndex + 1,
        "aria-colspan": colSpan,
        style: style2,
        tabIndex,
        onClick: publish("cellClick", onClick),
        onDoubleClick: publish("cellDoubleClick", onDoubleClick),
        onMouseOver: publish("cellMouseOver", onMouseOver),
        onMouseDown: publishMouseDown("cellMouseDown"),
        onMouseUp: publishMouseUp("cellMouseUp"),
        onKeyDown: publish("cellKeyDown", onKeyDown),
        onKeyUp: publish("cellKeyUp", onKeyUp)
      }, draggableEventHandlers, other, {
        onFocus: handleFocus,
        children
      }))
    );
  });
  const MemoizedGridCellV7 = fastMemo(GridCellV7);
  const _excluded$1z = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "hasFocus", "tabIndex"];
  const useUtilityClasses$19 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["booleanCell"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridBooleanCellRaw(props) {
    const {
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1z);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = {
      classes: rootProps.classes
    };
    const classes = useUtilityClasses$19(ownerState);
    const Icon = React__namespace.useMemo(() => value ? rootProps.slots.booleanCellTrueIcon : rootProps.slots.booleanCellFalseIcon, [rootProps.slots.booleanCellFalseIcon, rootProps.slots.booleanCellTrueIcon, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends({
      fontSize: "small",
      className: classes.root,
      titleAccess: apiRef2.current.getLocaleText(value ? "booleanCellTrueLabel" : "booleanCellFalseLabel"),
      "data-value": Boolean(value)
    }, other));
  }
  const GridBooleanCell = /* @__PURE__ */ React__namespace.memo(GridBooleanCellRaw);
  const renderBooleanCell = (params) => {
    if (isAutoGeneratedRow(params.rowNode)) {
      return "";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridBooleanCell, _extends({}, params));
  };
  const _excluded$1y = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange"];
  const useUtilityClasses$18 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["editBooleanCell"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridEditBooleanCell(props) {
    var _rootProps$slotProps;
    const {
      id: idProp,
      value,
      field,
      className,
      hasFocus,
      onValueChange
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1y);
    const apiRef2 = useGridApiContext();
    const inputRef = React__namespace.useRef(null);
    const id = useId();
    const [valueState, setValueState] = React__namespace.useState(value);
    const rootProps = useGridRootProps();
    const ownerState = {
      classes: rootProps.classes
    };
    const classes = useUtilityClasses$18(ownerState);
    const handleChange = React__namespace.useCallback(async (event) => {
      const newValue = event.target.checked;
      if (onValueChange) {
        await onValueChange(event, newValue);
      }
      setValueState(newValue);
      await apiRef2.current.setEditCellValue({
        id: idProp,
        field,
        value: newValue
      }, event);
    }, [apiRef2, field, idProp, onValueChange]);
    React__namespace.useEffect(() => {
      setValueState(value);
    }, [value]);
    useEnhancedEffect$1(() => {
      if (hasFocus) {
        inputRef.current.focus();
      }
    }, [hasFocus]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("label", _extends({
      htmlFor: id,
      className: clsx(classes.root, className)
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends({
        id,
        inputRef,
        checked: Boolean(valueState),
        onChange: handleChange,
        size: "small"
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseCheckbox))
    }));
  }
  const renderEditBooleanCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditBooleanCell, _extends({}, params));
  function formControlState({
    props,
    states,
    muiFormControl
  }) {
    return states.reduce((acc, state) => {
      acc[state] = props[state];
      if (muiFormControl) {
        if (typeof props[state] === "undefined") {
          acc[state] = muiFormControl[state];
        }
      }
      return acc;
    }, {});
  }
  const FormControlContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  const FormControlContext$1 = FormControlContext;
  function useFormControl() {
    return React__namespace.useContext(FormControlContext$1);
  }
  function GlobalStyles(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends({}, props, {
      defaultTheme: defaultTheme$2,
      themeId: THEME_ID
    }));
  }
  function hasValue(value) {
    return value != null && !(Array.isArray(value) && value.length === 0);
  }
  function isFilled(obj, SSR = false) {
    return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
  }
  function isAdornedStart(obj) {
    return obj.startAdornment;
  }
  function getInputBaseUtilityClass(slot) {
    return generateUtilityClass("MuiInputBase", slot);
  }
  const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
  const inputBaseClasses$1 = inputBaseClasses;
  const _excluded$1x = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
  const rootOverridesResolver = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
  };
  const inputOverridesResolver = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
  };
  const useUtilityClasses$17 = (ownerState) => {
    const {
      classes,
      color: color2,
      disabled,
      error,
      endAdornment,
      focused,
      formControl,
      fullWidth,
      hiddenLabel,
      multiline,
      readOnly,
      size,
      startAdornment,
      type
    } = ownerState;
    const slots = {
      root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size === "small" && "sizeSmall", multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
      input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
    };
    return composeClasses(slots, getInputBaseUtilityClass, classes);
  };
  const InputBaseRoot = styled$1("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: rootOverridesResolver
  })(({
    theme,
    ownerState
  }) => _extends({}, theme.typography.body1, {
    color: (theme.vars || theme).palette.text.primary,
    lineHeight: "1.4375em",
    // 23px
    boxSizing: "border-box",
    // Prevent padding issue with fullWidth.
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${inputBaseClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled,
      cursor: "default"
    }
  }, ownerState.multiline && _extends({
    padding: "4px 0 5px"
  }, ownerState.size === "small" && {
    paddingTop: 1
  }), ownerState.fullWidth && {
    width: "100%"
  }));
  const InputBaseComponent = styled$1("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })(({
    theme,
    ownerState
  }) => {
    const light2 = theme.palette.mode === "light";
    const placeholder = _extends({
      color: "currentColor"
    }, theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: light2 ? 0.42 : 0.5
    }, {
      transition: theme.transitions.create("opacity", {
        duration: theme.transitions.duration.shorter
      })
    });
    const placeholderHidden = {
      opacity: "0 !important"
    };
    const placeholderVisible = theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: light2 ? 0.42 : 0.5
    };
    return _extends({
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "4px 0 5px",
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.4375em",
      // Reset 23pxthe native input line-height
      margin: 0,
      // Reset for Safari
      WebkitTapHighlightColor: "transparent",
      display: "block",
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: "100%",
      // Fix IE11 width issue
      animationName: "mui-auto-fill-cancel",
      animationDuration: "10ms",
      "&::-webkit-input-placeholder": placeholder,
      "&::-moz-placeholder": placeholder,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholder,
      // IE11
      "&::-ms-input-placeholder": placeholder,
      // Edge
      "&:focus": {
        outline: 0
      },
      // Reset Firefox invalid required input style
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        // Remove the padding when type=search.
        WebkitAppearance: "none"
      },
      // Show and hide the placeholder logic
      [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
        "&::-webkit-input-placeholder": placeholderHidden,
        "&::-moz-placeholder": placeholderHidden,
        // Firefox 19+
        "&:-ms-input-placeholder": placeholderHidden,
        // IE11
        "&::-ms-input-placeholder": placeholderHidden,
        // Edge
        "&:focus::-webkit-input-placeholder": placeholderVisible,
        "&:focus::-moz-placeholder": placeholderVisible,
        // Firefox 19+
        "&:focus:-ms-input-placeholder": placeholderVisible,
        // IE11
        "&:focus::-ms-input-placeholder": placeholderVisible
        // Edge
      },
      [`&.${inputBaseClasses$1.disabled}`]: {
        opacity: 1,
        // Reset iOS opacity
        WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
        // Fix opacity Safari bug
      },
      "&:-webkit-autofill": {
        animationDuration: "5000s",
        animationName: "mui-auto-fill"
      }
    }, ownerState.size === "small" && {
      paddingTop: 1
    }, ownerState.multiline && {
      height: "auto",
      resize: "none",
      padding: 0,
      paddingTop: 0
    }, ownerState.type === "search" && {
      // Improve type search style.
      MozAppearance: "textfield"
    });
  });
  const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
    styles: {
      "@keyframes mui-auto-fill": {
        from: {
          display: "block"
        }
      },
      "@keyframes mui-auto-fill-cancel": {
        from: {
          display: "block"
        }
      }
    }
  });
  const InputBase = /* @__PURE__ */ React__namespace.forwardRef(function InputBase2(inProps, ref) {
    var _slotProps$input;
    const props = useThemeProps({
      props: inProps,
      name: "MuiInputBase"
    });
    const {
      "aria-describedby": ariaDescribedby,
      autoComplete,
      autoFocus,
      className,
      components = {},
      componentsProps = {},
      defaultValue,
      disabled,
      disableInjectingGlobalStyles,
      endAdornment,
      fullWidth = false,
      id,
      inputComponent = "input",
      inputProps: inputPropsProp = {},
      inputRef: inputRefProp,
      maxRows,
      minRows,
      multiline = false,
      name,
      onBlur,
      onChange,
      onClick,
      onFocus,
      onKeyDown,
      onKeyUp,
      placeholder,
      readOnly,
      renderSuffix,
      rows,
      slotProps = {},
      slots = {},
      startAdornment,
      type = "text",
      value: valueProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1x);
    const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
    const {
      current: isControlled
    } = React__namespace.useRef(value != null);
    const inputRef = React__namespace.useRef();
    const handleInputRefWarning = React__namespace.useCallback((instance) => {
    }, []);
    const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
    const [focused, setFocused] = React__namespace.useState(false);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    fcs.focused = muiFormControl ? muiFormControl.focused : focused;
    React__namespace.useEffect(() => {
      if (!muiFormControl && disabled && focused) {
        setFocused(false);
        if (onBlur) {
          onBlur();
        }
      }
    }, [muiFormControl, disabled, focused, onBlur]);
    const onFilled = muiFormControl && muiFormControl.onFilled;
    const onEmpty = muiFormControl && muiFormControl.onEmpty;
    const checkDirty = React__namespace.useCallback((obj) => {
      if (isFilled(obj)) {
        if (onFilled) {
          onFilled();
        }
      } else if (onEmpty) {
        onEmpty();
      }
    }, [onFilled, onEmpty]);
    useEnhancedEffect$1(() => {
      if (isControlled) {
        checkDirty({
          value
        });
      }
    }, [value, checkDirty, isControlled]);
    const handleFocus = (event) => {
      if (fcs.disabled) {
        event.stopPropagation();
        return;
      }
      if (onFocus) {
        onFocus(event);
      }
      if (inputPropsProp.onFocus) {
        inputPropsProp.onFocus(event);
      }
      if (muiFormControl && muiFormControl.onFocus) {
        muiFormControl.onFocus(event);
      } else {
        setFocused(true);
      }
    };
    const handleBlur = (event) => {
      if (onBlur) {
        onBlur(event);
      }
      if (inputPropsProp.onBlur) {
        inputPropsProp.onBlur(event);
      }
      if (muiFormControl && muiFormControl.onBlur) {
        muiFormControl.onBlur(event);
      } else {
        setFocused(false);
      }
    };
    const handleChange = (event, ...args) => {
      if (!isControlled) {
        const element = event.target || inputRef.current;
        if (element == null) {
          throw new Error(formatMuiErrorMessage(1));
        }
        checkDirty({
          value: element.value
        });
      }
      if (inputPropsProp.onChange) {
        inputPropsProp.onChange(event, ...args);
      }
      if (onChange) {
        onChange(event, ...args);
      }
    };
    React__namespace.useEffect(() => {
      checkDirty(inputRef.current);
    }, []);
    const handleClick = (event) => {
      if (inputRef.current && event.currentTarget === event.target) {
        inputRef.current.focus();
      }
      if (onClick) {
        onClick(event);
      }
    };
    let InputComponent = inputComponent;
    let inputProps = inputPropsProp;
    if (multiline && InputComponent === "input") {
      if (rows) {
        inputProps = _extends({
          type: void 0,
          minRows: rows,
          maxRows: rows
        }, inputProps);
      } else {
        inputProps = _extends({
          type: void 0,
          maxRows,
          minRows
        }, inputProps);
      }
      InputComponent = TextareaAutosize;
    }
    const handleAutoFill = (event) => {
      checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
        value: "x"
      });
    };
    React__namespace.useEffect(() => {
      if (muiFormControl) {
        muiFormControl.setAdornedStart(Boolean(startAdornment));
      }
    }, [muiFormControl, startAdornment]);
    const ownerState = _extends({}, props, {
      color: fcs.color || "primary",
      disabled: fcs.disabled,
      endAdornment,
      error: fcs.error,
      focused: fcs.focused,
      formControl: muiFormControl,
      fullWidth,
      hiddenLabel: fcs.hiddenLabel,
      multiline,
      size: fcs.size,
      startAdornment,
      type
    });
    const classes = useUtilityClasses$17(ownerState);
    const Root = slots.root || components.Root || InputBaseRoot;
    const rootProps = slotProps.root || componentsProps.root || {};
    const Input3 = slots.input || components.Input || InputBaseComponent;
    inputProps = _extends({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends({}, rootProps, !isHostComponent(Root) && {
        ownerState: _extends({}, ownerState, rootProps.ownerState)
      }, {
        ref,
        onClick: handleClick
      }, other, {
        className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
        children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
          value: null,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, _extends({
            ownerState,
            "aria-invalid": fcs.error,
            "aria-describedby": ariaDescribedby,
            autoComplete,
            autoFocus,
            defaultValue,
            disabled: fcs.disabled,
            id,
            onAnimationStart: handleAutoFill,
            name,
            placeholder,
            readOnly,
            required: fcs.required,
            rows,
            value,
            onKeyDown,
            onKeyUp,
            type
          }, inputProps, !isHostComponent(Input3) && {
            as: InputComponent,
            ownerState: _extends({}, ownerState, inputProps.ownerState)
          }, {
            ref: handleInputRef,
            className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
            onBlur: handleBlur,
            onChange: handleChange,
            onFocus: handleFocus
          }))
        }), endAdornment, renderSuffix ? renderSuffix(_extends({}, fcs, {
          startAdornment
        })) : null]
      }))]
    });
  });
  const InputBase$1 = InputBase;
  const _excluded$1w = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "inputProps", "isValidating", "isProcessingProps", "onValueChange"];
  const StyledInputBase = styled$1(InputBase$1)({
    fontSize: "inherit"
  });
  const useUtilityClasses$16 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["editInputCell"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridEditDateCell(props) {
    const {
      id,
      value: valueProp,
      field,
      colDef,
      hasFocus,
      inputProps,
      onValueChange
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1w);
    const isDateTime = colDef.type === "dateTime";
    const apiRef2 = useGridApiContext();
    const inputRef = React__namespace.useRef();
    const valueTransformed = React__namespace.useMemo(() => {
      let parsedDate;
      if (valueProp == null) {
        parsedDate = null;
      } else if (valueProp instanceof Date) {
        parsedDate = valueProp;
      } else {
        parsedDate = new Date((valueProp != null ? valueProp : "").toString());
      }
      let formattedDate;
      if (parsedDate == null || Number.isNaN(parsedDate.getTime())) {
        formattedDate = "";
      } else {
        const localDate = new Date(parsedDate.getTime() - parsedDate.getTimezoneOffset() * 60 * 1e3);
        formattedDate = localDate.toISOString().substr(0, isDateTime ? 16 : 10);
      }
      return {
        parsed: parsedDate,
        formatted: formattedDate
      };
    }, [valueProp, isDateTime]);
    const [valueState, setValueState] = React__namespace.useState(valueTransformed);
    const rootProps = useGridRootProps();
    const ownerState = {
      classes: rootProps.classes
    };
    const classes = useUtilityClasses$16(ownerState);
    const hasUpdatedEditValueOnMount = React__namespace.useRef(false);
    const parseValueToDate = React__namespace.useCallback((value) => {
      if (value === "") {
        return null;
      }
      const [date, time] = value.split("T");
      const [year, month, day] = date.split("-");
      const parsedDate = /* @__PURE__ */ new Date();
      parsedDate.setFullYear(Number(year), Number(month) - 1, Number(day));
      parsedDate.setHours(0, 0, 0, 0);
      if (time) {
        const [hours, minutes] = time.split(":");
        parsedDate.setHours(Number(hours), Number(minutes), 0, 0);
      }
      return parsedDate;
    }, []);
    const handleChange = React__namespace.useCallback(async (event) => {
      const newFormattedDate = event.target.value;
      const newParsedDate = parseValueToDate(newFormattedDate);
      if (onValueChange) {
        await onValueChange(event, newParsedDate);
      }
      setValueState({
        parsed: newParsedDate,
        formatted: newFormattedDate
      });
      apiRef2.current.setEditCellValue({
        id,
        field,
        value: newParsedDate
      }, event);
    }, [apiRef2, field, id, onValueChange, parseValueToDate]);
    React__namespace.useEffect(() => {
      setValueState((state) => {
        var _valueTransformed$par, _state$parsed;
        if (valueTransformed.parsed !== state.parsed && ((_valueTransformed$par = valueTransformed.parsed) == null ? void 0 : _valueTransformed$par.getTime()) !== ((_state$parsed = state.parsed) == null ? void 0 : _state$parsed.getTime())) {
          return valueTransformed;
        }
        return state;
      });
    }, [valueTransformed]);
    useEnhancedEffect$1(() => {
      if (hasFocus) {
        inputRef.current.focus();
      }
    }, [hasFocus]);
    const meta = apiRef2.current.unstable_getEditCellMeta(id, field);
    const handleInputRef = (el) => {
      inputRef.current = el;
      if (meta != null && meta.unstable_updateValueOnRender && !hasUpdatedEditValueOnMount.current) {
        const inputValue = inputRef.current.value;
        const parsedDate = parseValueToDate(inputValue);
        setValueState({
          parsed: parsedDate,
          formatted: inputValue
        });
        apiRef2.current.setEditCellValue({
          id,
          field,
          value: parsedDate
        });
        hasUpdatedEditValueOnMount.current = true;
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInputBase, _extends({
      inputRef: handleInputRef,
      fullWidth: true,
      className: classes.root,
      type: isDateTime ? "datetime-local" : "date",
      inputProps: _extends({
        max: isDateTime ? "9999-12-31T23:59" : "9999-12-31"
      }, inputProps),
      value: valueState.formatted,
      onChange: handleChange
    }, other));
  }
  const renderEditDateCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditDateCell, _extends({}, params));
  const _excluded$1v = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "isValidating", "debounceMs", "isProcessingProps", "onValueChange"];
  const useUtilityClasses$15 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["editInputCell"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridEditInputCellRoot = styled$1(InputBase$1, {
    name: "MuiDataGrid",
    slot: "EditInputCell",
    overridesResolver: (props, styles2) => styles2.editInputCell
  })(({
    theme
  }) => _extends({}, theme.typography.body2, {
    padding: "1px 0",
    "& input": {
      padding: "0 16px",
      height: "100%"
    }
  }));
  const GridEditInputCell = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const rootProps = useGridRootProps();
    const {
      id,
      value,
      field,
      colDef,
      hasFocus,
      debounceMs = 200,
      isProcessingProps,
      onValueChange
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1v);
    const apiRef2 = useGridApiContext();
    const inputRef = React__namespace.useRef();
    const [valueState, setValueState] = React__namespace.useState(value);
    const classes = useUtilityClasses$15(rootProps);
    const handleChange = React__namespace.useCallback(async (event) => {
      const newValue = event.target.value;
      if (onValueChange) {
        await onValueChange(event, newValue);
      }
      const column2 = apiRef2.current.getColumn(field);
      let parsedValue = newValue;
      if (column2.valueParser) {
        parsedValue = column2.valueParser(newValue, apiRef2.current.getCellParams(id, field));
      }
      setValueState(parsedValue);
      apiRef2.current.setEditCellValue({
        id,
        field,
        value: parsedValue,
        debounceMs,
        unstable_skipValueParser: true
      }, event);
    }, [apiRef2, debounceMs, field, id, onValueChange]);
    const meta = apiRef2.current.unstable_getEditCellMeta(id, field);
    React__namespace.useEffect(() => {
      if ((meta == null ? void 0 : meta.changeReason) !== "debouncedSetEditCellValue") {
        setValueState(value);
      }
    }, [meta, value]);
    useEnhancedEffect$1(() => {
      if (hasFocus) {
        inputRef.current.focus();
      }
    }, [hasFocus]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditInputCellRoot, _extends({
      ref,
      inputRef,
      className: classes.root,
      ownerState: rootProps,
      fullWidth: true,
      type: colDef.type === "number" ? colDef.type : "text",
      value: valueState != null ? valueState : "",
      onChange: handleChange,
      endAdornment: isProcessingProps ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
        fontSize: "small",
        color: "action"
      }) : void 0
    }, other));
  });
  const renderEditInputCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditInputCell, _extends({}, params));
  const isEscapeKey = (key) => key === "Escape";
  const isEnterKey = (key) => key === "Enter";
  const isTabKey = (key) => key === "Tab";
  const isSpaceKey = (key) => key === " ";
  const isArrowKeys = (key) => key.indexOf("Arrow") === 0;
  const isHomeOrEndKeys = (key) => key === "Home" || key === "End";
  const isPageKeys = (key) => key.indexOf("Page") === 0;
  function isPrintableKey(event) {
    return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
  }
  const isNavigationKey = (key) => isHomeOrEndKeys(key) || isArrowKeys(key) || isPageKeys(key) || isSpaceKey(key);
  const isKeyboardEvent$1 = (event) => !!event.key;
  const isHideMenuKey = (key) => isTabKey(key) || isEscapeKey(key);
  function isSingleSelectColDef(colDef) {
    return (colDef == null ? void 0 : colDef.type) === "singleSelect";
  }
  function getValueFromValueOptions(value, valueOptions, getOptionValue) {
    if (valueOptions === void 0) {
      return void 0;
    }
    const result = valueOptions.find((option) => {
      const optionValue = getOptionValue(option);
      return String(optionValue) === String(value);
    });
    return getOptionValue(result);
  }
  const _excluded$1u = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange", "initialOpen", "getOptionLabel", "getOptionValue"], _excluded2$9 = ["MenuProps"];
  function isKeyboardEvent(event) {
    return !!event.key;
  }
  function GridEditSingleSelectCell(props) {
    var _rootProps$slotProps, _baseSelectProps$nati, _rootProps$slotProps2;
    const rootProps = useGridRootProps();
    const {
      id,
      value: valueProp,
      field,
      row,
      colDef,
      hasFocus,
      error,
      onValueChange,
      initialOpen = rootProps.editMode === GridEditModes.Cell,
      getOptionLabel: getOptionLabelProp,
      getOptionValue: getOptionValueProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1u);
    const apiRef2 = useGridApiContext();
    const ref = React__namespace.useRef();
    const inputRef = React__namespace.useRef();
    const [open, setOpen] = React__namespace.useState(initialOpen);
    const baseSelectProps = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseSelect) || {};
    const isSelectNative = (_baseSelectProps$nati = baseSelectProps.native) != null ? _baseSelectProps$nati : false;
    const _ref = ((_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSelect) || {}, {
      MenuProps
    } = _ref, otherBaseSelectProps = _objectWithoutPropertiesLoose(_ref, _excluded2$9);
    useEnhancedEffect$1(() => {
      if (hasFocus) {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      }
    }, [hasFocus]);
    if (!isSingleSelectColDef(colDef)) {
      return null;
    }
    let valueOptions;
    if (typeof (colDef == null ? void 0 : colDef.valueOptions) === "function") {
      valueOptions = colDef == null ? void 0 : colDef.valueOptions({
        id,
        row,
        field
      });
    } else {
      valueOptions = colDef == null ? void 0 : colDef.valueOptions;
    }
    if (!valueOptions) {
      return null;
    }
    const getOptionValue = getOptionValueProp || colDef.getOptionValue;
    const getOptionLabel = getOptionLabelProp || colDef.getOptionLabel;
    const handleChange = async (event) => {
      if (!isSingleSelectColDef(colDef) || !valueOptions) {
        return;
      }
      setOpen(false);
      const target = event.target;
      const formattedTargetValue = getValueFromValueOptions(target.value, valueOptions, getOptionValue);
      if (onValueChange) {
        await onValueChange(event, formattedTargetValue);
      }
      await apiRef2.current.setEditCellValue({
        id,
        field,
        value: formattedTargetValue
      }, event);
    };
    const handleClose = (event, reason) => {
      if (rootProps.editMode === GridEditModes.Row) {
        setOpen(false);
        return;
      }
      if (reason === "backdropClick" || isEscapeKey(event.key)) {
        const params = apiRef2.current.getCellParams(id, field);
        apiRef2.current.publishEvent("cellEditStop", _extends({}, params, {
          reason: isEscapeKey(event.key) ? GridCellEditStopReasons.escapeKeyDown : GridCellEditStopReasons.cellFocusOut
        }));
      }
    };
    const handleOpen = (event) => {
      if (isKeyboardEvent(event) && event.key === "Enter") {
        return;
      }
      setOpen(true);
    };
    if (!valueOptions || !colDef) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends({
      ref,
      inputRef,
      value: valueProp,
      onChange: handleChange,
      open,
      onOpen: handleOpen,
      MenuProps: _extends({
        onClose: handleClose
      }, MenuProps),
      error,
      native: isSelectNative,
      fullWidth: true
    }, other, otherBaseSelectProps, {
      children: valueOptions.map((valueOption) => {
        var _rootProps$slotProps3;
        const value = getOptionValue(valueOption);
        return /* @__PURE__ */ React.createElement(rootProps.slots.baseSelectOption, _extends({}, ((_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseSelectOption) || {}, {
          native: isSelectNative,
          key: value,
          value
        }), getOptionLabel(valueOption));
      })
    }));
  }
  const renderEditSingleSelectCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditSingleSelectCell, _extends({}, params));
  const ListContext = /* @__PURE__ */ React__namespace.createContext({});
  const ListContext$1 = ListContext;
  function getListUtilityClass(slot) {
    return generateUtilityClass("MuiList", slot);
  }
  generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
  const _excluded$1t = ["children", "className", "component", "dense", "disablePadding", "subheader"];
  const useUtilityClasses$14 = (ownerState) => {
    const {
      classes,
      disablePadding,
      dense,
      subheader
    } = ownerState;
    const slots = {
      root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
    };
    return composeClasses(slots, getListUtilityClass, classes);
  };
  const ListRoot = styled$1("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
    }
  })(({
    ownerState
  }) => _extends({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative"
  }, !ownerState.disablePadding && {
    paddingTop: 8,
    paddingBottom: 8
  }, ownerState.subheader && {
    paddingTop: 0
  }));
  const List = /* @__PURE__ */ React__namespace.forwardRef(function List2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiList"
    });
    const {
      children,
      className,
      component = "ul",
      dense = false,
      disablePadding = false,
      subheader
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1t);
    const context = React__namespace.useMemo(() => ({
      dense
    }), [dense]);
    const ownerState = _extends({}, props, {
      component,
      dense,
      disablePadding
    });
    const classes = useUtilityClasses$14(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
      value: context,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends({
        as: component,
        className: clsx(classes.root, className),
        ref,
        ownerState
      }, other, {
        children: [subheader, children]
      }))
    });
  });
  const List$1 = List;
  const _excluded$1s = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
  function nextItem(list, item, disableListWrap) {
    if (list === item) {
      return list.firstChild;
    }
    if (item && item.nextElementSibling) {
      return item.nextElementSibling;
    }
    return disableListWrap ? null : list.firstChild;
  }
  function previousItem(list, item, disableListWrap) {
    if (list === item) {
      return disableListWrap ? list.firstChild : list.lastChild;
    }
    if (item && item.previousElementSibling) {
      return item.previousElementSibling;
    }
    return disableListWrap ? null : list.lastChild;
  }
  function textCriteriaMatches(nextFocus, textCriteria) {
    if (textCriteria === void 0) {
      return true;
    }
    let text = nextFocus.innerText;
    if (text === void 0) {
      text = nextFocus.textContent;
    }
    text = text.trim().toLowerCase();
    if (text.length === 0) {
      return false;
    }
    if (textCriteria.repeating) {
      return text[0] === textCriteria.keys[0];
    }
    return text.indexOf(textCriteria.keys.join("")) === 0;
  }
  function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
    while (nextFocus) {
      if (nextFocus === list.firstChild) {
        if (wrappedOnce) {
          return false;
        }
        wrappedOnce = true;
      }
      const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
      if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
        nextFocus = traversalFunction(list, nextFocus, disableListWrap);
      } else {
        nextFocus.focus();
        return true;
      }
    }
    return false;
  }
  const MenuList = /* @__PURE__ */ React__namespace.forwardRef(function MenuList2(props, ref) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions,
      autoFocus = false,
      autoFocusItem = false,
      children,
      className,
      disabledItemsFocusable = false,
      disableListWrap = false,
      onKeyDown,
      variant = "selectedMenu"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1s);
    const listRef = React__namespace.useRef(null);
    const textCriteriaRef = React__namespace.useRef({
      keys: [],
      repeating: true,
      previousKeyMatched: true,
      lastTime: null
    });
    useEnhancedEffect$1(() => {
      if (autoFocus) {
        listRef.current.focus();
      }
    }, [autoFocus]);
    React__namespace.useImperativeHandle(actions, () => ({
      adjustStyleForScrollbar: (containerElement, theme) => {
        const noExplicitWidth = !listRef.current.style.width;
        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
          listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
          listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
        }
        return listRef.current;
      }
    }), []);
    const handleKeyDown2 = (event) => {
      const list = listRef.current;
      const key = event.key;
      const currentFocus = ownerDocument(list).activeElement;
      if (key === "ArrowDown") {
        event.preventDefault();
        moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
      } else if (key === "ArrowUp") {
        event.preventDefault();
        moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
      } else if (key === "Home") {
        event.preventDefault();
        moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
      } else if (key === "End") {
        event.preventDefault();
        moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
      } else if (key.length === 1) {
        const criteria = textCriteriaRef.current;
        const lowerKey = key.toLowerCase();
        const currTime = performance.now();
        if (criteria.keys.length > 0) {
          if (currTime - criteria.lastTime > 500) {
            criteria.keys = [];
            criteria.repeating = true;
            criteria.previousKeyMatched = true;
          } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
            criteria.repeating = false;
          }
        }
        criteria.lastTime = currTime;
        criteria.keys.push(lowerKey);
        const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
        if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
          event.preventDefault();
        } else {
          criteria.previousKeyMatched = false;
        }
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
    };
    const handleRef = useForkRef(listRef, ref);
    let activeItemIndex = -1;
    React__namespace.Children.forEach(children, (child, index) => {
      if (!/* @__PURE__ */ React__namespace.isValidElement(child)) {
        if (activeItemIndex === index) {
          activeItemIndex += 1;
          if (activeItemIndex >= children.length) {
            activeItemIndex = -1;
          }
        }
        return;
      }
      if (!child.props.disabled) {
        if (variant === "selectedMenu" && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
      if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
    });
    const items2 = React__namespace.Children.map(children, (child, index) => {
      if (index === activeItemIndex) {
        const newChildProps = {};
        if (autoFocusItem) {
          newChildProps.autoFocus = true;
        }
        if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
          newChildProps.tabIndex = 0;
        }
        return /* @__PURE__ */ React__namespace.cloneElement(child, newChildProps);
      }
      return child;
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends({
      role: "menu",
      ref: handleRef,
      className,
      onKeyDown: handleKeyDown2,
      tabIndex: autoFocus ? 0 : -1
    }, other, {
      children: items2
    }));
  });
  const MenuList$1 = MenuList;
  const _excluded$1r = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  function getScale(value) {
    return `scale(${value}, ${value ** 2})`;
  }
  const styles = {
    entering: {
      opacity: 1,
      transform: getScale(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  };
  const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
  const Grow = /* @__PURE__ */ React__namespace.forwardRef(function Grow2(props, ref) {
    const {
      addEndListener,
      appear = true,
      children,
      easing: easing2,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style: style2,
      timeout = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition$1
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1r);
    const timer = React__namespace.useRef();
    const autoTimeout = React__namespace.useRef();
    const theme = useTheme();
    const nodeRef = React__namespace.useRef(null);
    const handleRef = useForkRef(nodeRef, children.ref, ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
      if (callback) {
        const node2 = nodeRef.current;
        if (maybeIsAppearing === void 0) {
          callback(node2);
        } else {
          callback(node2, maybeIsAppearing);
        }
      }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
      reflow(node2);
      const {
        duration: transitionDuration,
        delay,
        easing: transitionTimingFunction
      } = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "enter"
      });
      let duration2;
      if (timeout === "auto") {
        duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
        autoTimeout.current = duration2;
      } else {
        duration2 = transitionDuration;
      }
      node2.style.transition = [theme.transitions.create("opacity", {
        duration: duration2,
        delay
      }), theme.transitions.create("transform", {
        duration: isWebKit154 ? duration2 : duration2 * 0.666,
        delay,
        easing: transitionTimingFunction
      })].join(",");
      if (onEnter) {
        onEnter(node2, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
      const {
        duration: transitionDuration,
        delay,
        easing: transitionTimingFunction
      } = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "exit"
      });
      let duration2;
      if (timeout === "auto") {
        duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
        autoTimeout.current = duration2;
      } else {
        duration2 = transitionDuration;
      }
      node2.style.transition = [theme.transitions.create("opacity", {
        duration: duration2,
        delay
      }), theme.transitions.create("transform", {
        duration: isWebKit154 ? duration2 : duration2 * 0.666,
        delay: isWebKit154 ? delay : delay || duration2 * 0.333,
        easing: transitionTimingFunction
      })].join(",");
      node2.style.opacity = 0;
      node2.style.transform = getScale(0.75);
      if (onExit) {
        onExit(node2);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
      if (timeout === "auto") {
        timer.current = setTimeout(next2, autoTimeout.current || 0);
      }
      if (addEndListener) {
        addEndListener(nodeRef.current, next2);
      }
    };
    React__namespace.useEffect(() => {
      return () => {
        clearTimeout(timer.current);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
      appear,
      in: inProp,
      nodeRef,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout: timeout === "auto" ? null : timeout
    }, other, {
      children: (state, childProps) => {
        return /* @__PURE__ */ React__namespace.cloneElement(children, _extends({
          style: _extends({
            opacity: 0,
            transform: getScale(0.75),
            visibility: state === "exited" && !inProp ? "hidden" : void 0
          }, styles[state], style2, children.props.style),
          ref: handleRef
        }, childProps));
      }
    }));
  });
  Grow.muiSupportAuto = true;
  const Grow$1 = Grow;
  function getPaperUtilityClass(slot) {
    return generateUtilityClass("MuiPaper", slot);
  }
  generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
  const _excluded$1q = ["className", "component", "elevation", "square", "variant"];
  const useUtilityClasses$13 = (ownerState) => {
    const {
      square,
      elevation,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
    };
    return composeClasses(slots, getPaperUtilityClass, classes);
  };
  const PaperRoot = styled$1("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$vars$overlays;
    return _extends({
      backgroundColor: (theme.vars || theme).palette.background.paper,
      color: (theme.vars || theme).palette.text.primary,
      transition: theme.transitions.create("box-shadow")
    }, !ownerState.square && {
      borderRadius: theme.shape.borderRadius
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme.vars || theme).palette.divider}`
    }, ownerState.variant === "elevation" && _extends({
      boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
    }, !theme.vars && theme.palette.mode === "dark" && {
      backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`
    }, theme.vars && {
      backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
    }));
  });
  const Paper = /* @__PURE__ */ React__namespace.forwardRef(function Paper2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPaper"
    });
    const {
      className,
      component = "div",
      elevation = 1,
      square = false,
      variant = "elevation"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1q);
    const ownerState = _extends({}, props, {
      component,
      elevation,
      square,
      variant
    });
    const classes = useUtilityClasses$13(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other));
  });
  const PaperBase = Paper;
  const _excluded$1p = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"];
  const PopperRoot = styled$1(Popper$1, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const Popper = /* @__PURE__ */ React__namespace.forwardRef(function Popper3(inProps, ref) {
    var _slots$root;
    const theme = useTheme$2();
    const props = useThemeProps({
      props: inProps,
      name: "MuiPopper"
    });
    const {
      anchorEl,
      component,
      components,
      componentsProps,
      container,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1p);
    const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
    const otherProps = _extends({
      anchorEl,
      container,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition
    }, other);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, _extends({
      as: component,
      direction: theme == null ? void 0 : theme.direction,
      slots: {
        root: RootComponent
      },
      slotProps: slotProps != null ? slotProps : componentsProps
    }, otherProps, {
      ref
    }));
  });
  const MUIPopper = Popper;
  const _excluded$1o = ["open", "target", "onClickAway", "children", "position", "className", "onExited"];
  const useUtilityClasses$12 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["menu"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridMenuRoot = styled$1(MUIPopper, {
    name: "MuiDataGrid",
    slot: "Menu",
    overridesResolver: (_2, styles2) => styles2.menu
  })(({
    theme
  }) => ({
    zIndex: theme.zIndex.modal,
    [`& .${gridClasses.menuList}`]: {
      outline: 0
    }
  }));
  const transformOrigin = {
    "bottom-start": "top left",
    "bottom-end": "top right"
  };
  function GridMenu(props) {
    var _rootProps$slotProps;
    const {
      open,
      target,
      onClickAway,
      children,
      position: position2,
      className,
      onExited
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1o);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$12(rootProps);
    React__namespace.useEffect(() => {
      const eventName = open ? "menuOpen" : "menuClose";
      apiRef2.current.publishEvent(eventName, {
        target
      });
    }, [apiRef2, open, target]);
    const handleExited = (popperOnExited) => (node2) => {
      if (popperOnExited) {
        popperOnExited();
      }
      if (onExited) {
        onExited(node2);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenuRoot, _extends({
      as: rootProps.slots.basePopper,
      className: clsx(className, classes.root),
      ownerState: rootProps,
      open,
      anchorEl: target,
      transition: true,
      placement: position2
    }, other, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.basePopper, {
      children: ({
        TransitionProps,
        placement
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
        onClickAway,
        mouseEvent: "onMouseDown",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grow$1, _extends({}, TransitionProps, {
          style: {
            transformOrigin: transformOrigin[placement]
          },
          onExited: handleExited(TransitionProps == null ? void 0 : TransitionProps.onExited),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperBase, {
            children
          })
        }))
      })
    }));
  }
  const _excluded$1n = ["api", "colDef", "id", "hasFocus", "isEditable", "field", "value", "formattedValue", "row", "rowNode", "cellMode", "tabIndex", "position", "focusElementRef"];
  const hasActions = (colDef) => typeof colDef.getActions === "function";
  function GridActionsCell(props) {
    var _rootProps$slotProps;
    const {
      colDef,
      id,
      hasFocus,
      tabIndex,
      position: position2 = "bottom-end",
      focusElementRef
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1n);
    const [focusedButtonIndex, setFocusedButtonIndex] = React__namespace.useState(-1);
    const [open, setOpen] = React__namespace.useState(false);
    const apiRef2 = useGridApiContext();
    const rootRef = React__namespace.useRef(null);
    const buttonRef = React__namespace.useRef(null);
    const ignoreCallToFocus = React__namespace.useRef(false);
    const touchRippleRefs = React__namespace.useRef({});
    const theme = useTheme();
    const menuId = useId();
    const buttonId = useId();
    const rootProps = useGridRootProps();
    if (!hasActions(colDef)) {
      throw new Error("MUI: Missing the `getActions` property in the `GridColDef`.");
    }
    const options = colDef.getActions(apiRef2.current.getRowParams(id));
    const iconButtons = options.filter((option) => !option.props.showInMenu);
    const menuButtons = options.filter((option) => option.props.showInMenu);
    const numberOfButtons = iconButtons.length + (menuButtons.length ? 1 : 0);
    React__namespace.useLayoutEffect(() => {
      if (!hasFocus) {
        Object.entries(touchRippleRefs.current).forEach(([index, ref]) => {
          ref == null ? void 0 : ref.stop({}, () => {
            delete touchRippleRefs.current[index];
          });
        });
      }
    }, [hasFocus]);
    React__namespace.useEffect(() => {
      if (focusedButtonIndex < 0 || !rootRef.current) {
        return;
      }
      if (focusedButtonIndex >= rootRef.current.children.length) {
        return;
      }
      const child = rootRef.current.children[focusedButtonIndex];
      child.focus({
        preventScroll: true
      });
    }, [focusedButtonIndex]);
    React__namespace.useEffect(() => {
      if (!hasFocus) {
        setFocusedButtonIndex(-1);
        ignoreCallToFocus.current = false;
      }
    }, [hasFocus]);
    React__namespace.useImperativeHandle(focusElementRef, () => ({
      focus() {
        if (!ignoreCallToFocus.current) {
          setFocusedButtonIndex(0);
        }
      }
    }), []);
    React__namespace.useEffect(() => {
      if (focusedButtonIndex >= numberOfButtons) {
        setFocusedButtonIndex(numberOfButtons - 1);
      }
    }, [focusedButtonIndex, numberOfButtons]);
    const showMenu = () => {
      setOpen(true);
      setFocusedButtonIndex(numberOfButtons - 1);
      ignoreCallToFocus.current = true;
    };
    const hideMenu = () => {
      setOpen(false);
    };
    const handleTouchRippleRef = (index) => (instance) => {
      touchRippleRefs.current[index] = instance;
    };
    const handleButtonClick = (index, onClick) => (event) => {
      setFocusedButtonIndex(index);
      ignoreCallToFocus.current = true;
      if (onClick) {
        onClick(event);
      }
    };
    const handleRootKeyDown = (event) => {
      if (numberOfButtons <= 1) {
        return;
      }
      let newIndex = focusedButtonIndex;
      if (event.key === "ArrowRight") {
        if (theme.direction === "rtl") {
          newIndex -= 1;
        } else {
          newIndex += 1;
        }
      } else if (event.key === "ArrowLeft") {
        if (theme.direction === "rtl") {
          newIndex += 1;
        } else {
          newIndex -= 1;
        }
      }
      if (newIndex < 0 || newIndex >= numberOfButtons) {
        return;
      }
      if (newIndex !== focusedButtonIndex) {
        event.preventDefault();
        event.stopPropagation();
        setFocusedButtonIndex(newIndex);
      }
    };
    const handleListKeyDown = (event) => {
      if (event.key === "Tab") {
        event.preventDefault();
      }
      if (["Tab", "Enter", "Escape"].includes(event.key)) {
        hideMenu();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends({
      role: "menu",
      ref: rootRef,
      tabIndex: -1,
      className: gridClasses.actionsCell,
      onKeyDown: handleRootKeyDown
    }, other, {
      children: [iconButtons.map((button, index) => /* @__PURE__ */ React__namespace.cloneElement(button, {
        key: index,
        touchRippleRef: handleTouchRippleRef(index),
        onClick: handleButtonClick(index, button.props.onClick),
        tabIndex: focusedButtonIndex === index ? tabIndex : -1
      })), menuButtons.length > 0 && buttonId && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends({
        ref: buttonRef,
        id: buttonId,
        "aria-label": apiRef2.current.getLocaleText("actionsCellMore"),
        "aria-haspopup": "menu",
        "aria-expanded": open,
        "aria-controls": open ? menuId : void 0,
        role: "menuitem",
        size: "small",
        onClick: showMenu,
        touchRippleRef: handleTouchRippleRef(buttonId),
        tabIndex: focusedButtonIndex === iconButtons.length ? tabIndex : -1
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.moreActionsIcon, {
          fontSize: "small"
        })
      })), menuButtons.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
        onClickAway: hideMenu,
        onClick: hideMenu,
        open,
        target: buttonRef.current,
        position: position2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList$1, {
          id: menuId,
          className: gridClasses.menuList,
          onKeyDown: handleListKeyDown,
          "aria-labelledby": buttonId,
          variant: "menu",
          autoFocusItem: true,
          children: menuButtons.map((button, index) => /* @__PURE__ */ React__namespace.cloneElement(button, {
            key: index
          }))
        })
      })]
    }));
  }
  const renderActionsCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridActionsCell, _extends({}, params));
  function getDividerUtilityClass(slot) {
    return generateUtilityClass("MuiDivider", slot);
  }
  const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
  const dividerClasses$1 = dividerClasses;
  const _excluded$1m = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"];
  const useUtilityClasses$11 = (ownerState) => {
    const {
      absolute,
      children,
      classes,
      flexItem,
      light: light2,
      orientation,
      textAlign,
      variant
    } = ownerState;
    const slots = {
      root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
    };
    return composeClasses(slots, getDividerUtilityClass, classes);
  };
  const DividerRoot = styled$1("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    margin: 0,
    // Reset browser default style.
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (theme.vars || theme).palette.divider,
    borderBottomWidth: "thin"
  }, ownerState.absolute && {
    position: "absolute",
    bottom: 0,
    left: 0,
    width: "100%"
  }, ownerState.light && {
    borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha(theme.palette.divider, 0.08)
  }, ownerState.variant === "inset" && {
    marginLeft: 72
  }, ownerState.variant === "middle" && ownerState.orientation === "horizontal" && {
    marginLeft: theme.spacing(2),
    marginRight: theme.spacing(2)
  }, ownerState.variant === "middle" && ownerState.orientation === "vertical" && {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  }, ownerState.orientation === "vertical" && {
    height: "100%",
    borderBottomWidth: 0,
    borderRightWidth: "thin"
  }, ownerState.flexItem && {
    alignSelf: "stretch",
    height: "auto"
  }), ({
    ownerState
  }) => _extends({}, ownerState.children && {
    display: "flex",
    whiteSpace: "nowrap",
    textAlign: "center",
    border: 0,
    "&::before, &::after": {
      content: '""',
      alignSelf: "center"
    }
  }), ({
    theme,
    ownerState
  }) => _extends({}, ownerState.children && ownerState.orientation !== "vertical" && {
    "&::before, &::after": {
      width: "100%",
      borderTop: `thin solid ${(theme.vars || theme).palette.divider}`
    }
  }), ({
    theme,
    ownerState
  }) => _extends({}, ownerState.children && ownerState.orientation === "vertical" && {
    flexDirection: "column",
    "&::before, &::after": {
      height: "100%",
      borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`
    }
  }), ({
    ownerState
  }) => _extends({}, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && {
    "&::before": {
      width: "90%"
    },
    "&::after": {
      width: "10%"
    }
  }, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && {
    "&::before": {
      width: "10%"
    },
    "&::after": {
      width: "90%"
    }
  }));
  const DividerWrapper = styled$1("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    display: "inline-block",
    paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
    paddingRight: `calc(${theme.spacing(1)} * 1.2)`
  }, ownerState.orientation === "vertical" && {
    paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
    paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
  }));
  const Divider = /* @__PURE__ */ React__namespace.forwardRef(function Divider2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiDivider"
    });
    const {
      absolute = false,
      children,
      className,
      component = children ? "div" : "hr",
      flexItem = false,
      light: light2 = false,
      orientation = "horizontal",
      role = component !== "hr" ? "separator" : void 0,
      textAlign = "center",
      variant = "fullWidth"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1m);
    const ownerState = _extends({}, props, {
      absolute,
      component,
      flexItem,
      light: light2,
      orientation,
      role,
      textAlign,
      variant
    });
    const classes = useUtilityClasses$11(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, _extends({
      as: component,
      className: clsx(classes.root, className),
      role,
      ref,
      ownerState
    }, other, {
      children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
        className: classes.wrapper,
        ownerState,
        children
      }) : null
    }));
  });
  Divider.muiSkipListHighlight = true;
  const Divider$1 = Divider;
  function getListItemIconUtilityClass(slot) {
    return generateUtilityClass("MuiListItemIcon", slot);
  }
  const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
  const listItemIconClasses$1 = listItemIconClasses;
  const _excluded$1l = ["className"];
  const useUtilityClasses$10 = (ownerState) => {
    const {
      alignItems,
      classes
    } = ownerState;
    const slots = {
      root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
    };
    return composeClasses(slots, getListItemIconUtilityClass, classes);
  };
  const ListItemIconRoot = styled$1("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    minWidth: 56,
    color: (theme.vars || theme).palette.action.active,
    flexShrink: 0,
    display: "inline-flex"
  }, ownerState.alignItems === "flex-start" && {
    marginTop: 8
  }));
  const ListItemIcon = /* @__PURE__ */ React__namespace.forwardRef(function ListItemIcon2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiListItemIcon"
    });
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1l);
    const context = React__namespace.useContext(ListContext$1);
    const ownerState = _extends({}, props, {
      alignItems: context.alignItems
    });
    const classes = useUtilityClasses$10(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIconRoot, _extends({
      className: clsx(classes.root, className),
      ownerState,
      ref
    }, other));
  });
  const ListItemIcon$1 = ListItemIcon;
  function getTypographyUtilityClass(slot) {
    return generateUtilityClass("MuiTypography", slot);
  }
  generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
  const _excluded$1k = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
  const useUtilityClasses$$ = (ownerState) => {
    const {
      align,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
    };
    return composeClasses(slots, getTypographyUtilityClass, classes);
  };
  const TypographyRoot = styled$1("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    margin: 0
  }, ownerState.variant === "inherit" && {
    // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
    font: "inherit"
  }, ownerState.variant !== "inherit" && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
    textAlign: ownerState.align
  }, ownerState.noWrap && {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, ownerState.gutterBottom && {
    marginBottom: "0.35em"
  }, ownerState.paragraph && {
    marginBottom: 16
  }));
  const defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  };
  const colorTransformations = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
  };
  const transformDeprecatedColors = (color2) => {
    return colorTransformations[color2] || color2;
  };
  const Typography = /* @__PURE__ */ React__namespace.forwardRef(function Typography2(inProps, ref) {
    const themeProps = useThemeProps({
      props: inProps,
      name: "MuiTypography"
    });
    const color2 = transformDeprecatedColors(themeProps.color);
    const props = extendSxProp(_extends({}, themeProps, {
      color: color2
    }));
    const {
      align = "inherit",
      className,
      component,
      gutterBottom = false,
      noWrap = false,
      paragraph = false,
      variant = "body1",
      variantMapping = defaultVariantMapping
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1k);
    const ownerState = _extends({}, props, {
      align,
      color: color2,
      className,
      component,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      variantMapping
    });
    const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
    const classes = useUtilityClasses$$(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends({
      as: Component,
      ref,
      ownerState,
      className: clsx(classes.root, className)
    }, other));
  });
  const Typography$1 = Typography;
  function getListItemTextUtilityClass(slot) {
    return generateUtilityClass("MuiListItemText", slot);
  }
  const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
  const listItemTextClasses$1 = listItemTextClasses;
  const _excluded$1j = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
  const useUtilityClasses$_ = (ownerState) => {
    const {
      classes,
      inset,
      primary,
      secondary,
      dense
    } = ownerState;
    const slots = {
      root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
      primary: ["primary"],
      secondary: ["secondary"]
    };
    return composeClasses(slots, getListItemTextUtilityClass, classes);
  };
  const ListItemTextRoot = styled$1("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${listItemTextClasses$1.primary}`]: styles2.primary
      }, {
        [`& .${listItemTextClasses$1.secondary}`]: styles2.secondary
      }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
    }
  })(({
    ownerState
  }) => _extends({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4
  }, ownerState.primary && ownerState.secondary && {
    marginTop: 6,
    marginBottom: 6
  }, ownerState.inset && {
    paddingLeft: 56
  }));
  const ListItemText = /* @__PURE__ */ React__namespace.forwardRef(function ListItemText2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiListItemText"
    });
    const {
      children,
      className,
      disableTypography = false,
      inset = false,
      primary: primaryProp,
      primaryTypographyProps,
      secondary: secondaryProp,
      secondaryTypographyProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1j);
    const {
      dense
    } = React__namespace.useContext(ListContext$1);
    let primary = primaryProp != null ? primaryProp : children;
    let secondary = secondaryProp;
    const ownerState = _extends({}, props, {
      disableTypography,
      inset,
      primary: !!primary,
      secondary: !!secondary,
      dense
    });
    const classes = useUtilityClasses$_(ownerState);
    if (primary != null && primary.type !== Typography$1 && !disableTypography) {
      primary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, _extends({
        variant: dense ? "body2" : "body1",
        className: classes.primary,
        component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
        display: "block"
      }, primaryTypographyProps, {
        children: primary
      }));
    }
    if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
      secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, _extends({
        variant: "body2",
        className: classes.secondary,
        color: "text.secondary",
        display: "block"
      }, secondaryTypographyProps, {
        children: secondary
      }));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemTextRoot, _extends({
      className: clsx(classes.root, className),
      ownerState,
      ref
    }, other, {
      children: [primary, secondary]
    }));
  });
  const ListItemText$1 = ListItemText;
  function getMenuItemUtilityClass(slot) {
    return generateUtilityClass("MuiMenuItem", slot);
  }
  const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
  const menuItemClasses$1 = menuItemClasses;
  const _excluded$1i = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
  const overridesResolver$1 = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
  };
  const useUtilityClasses$Z = (ownerState) => {
    const {
      disabled,
      dense,
      divider,
      disableGutters,
      selected,
      classes
    } = ownerState;
    const slots = {
      root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
    };
    const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const MenuItemRoot = styled$1(ButtonBase$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: overridesResolver$1
  })(({
    theme,
    ownerState
  }) => _extends({}, theme.typography.body1, {
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap"
  }, !ownerState.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, ownerState.divider && {
    borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
    backgroundClip: "padding-box"
  }, {
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (theme.vars || theme).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${menuItemClasses$1.selected}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      [`&.${menuItemClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    },
    [`&.${menuItemClasses$1.selected}:hover`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    },
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`&.${menuItemClasses$1.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity
    },
    [`& + .${dividerClasses$1.root}`]: {
      marginTop: theme.spacing(1),
      marginBottom: theme.spacing(1)
    },
    [`& + .${dividerClasses$1.inset}`]: {
      marginLeft: 52
    },
    [`& .${listItemTextClasses$1.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${listItemTextClasses$1.inset}`]: {
      paddingLeft: 36
    },
    [`& .${listItemIconClasses$1.root}`]: {
      minWidth: 36
    }
  }, !ownerState.dense && {
    [theme.breakpoints.up("sm")]: {
      minHeight: "auto"
    }
  }, ownerState.dense && _extends({
    minHeight: 32,
    // https://m2.material.io/components/menus#specs > Dense
    paddingTop: 4,
    paddingBottom: 4
  }, theme.typography.body2, {
    [`& .${listItemIconClasses$1.root} svg`]: {
      fontSize: "1.25rem"
    }
  })));
  const MenuItem = /* @__PURE__ */ React__namespace.forwardRef(function MenuItem2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiMenuItem"
    });
    const {
      autoFocus = false,
      component = "li",
      dense = false,
      divider = false,
      disableGutters = false,
      focusVisibleClassName,
      role = "menuitem",
      tabIndex: tabIndexProp,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1i);
    const context = React__namespace.useContext(ListContext$1);
    const childContext = React__namespace.useMemo(() => ({
      dense: dense || context.dense || false,
      disableGutters
    }), [context.dense, dense, disableGutters]);
    const menuItemRef = React__namespace.useRef(null);
    useEnhancedEffect$1(() => {
      if (autoFocus) {
        if (menuItemRef.current) {
          menuItemRef.current.focus();
        }
      }
    }, [autoFocus]);
    const ownerState = _extends({}, props, {
      dense: childContext.dense,
      divider,
      disableGutters
    });
    const classes = useUtilityClasses$Z(props);
    const handleRef = useForkRef(menuItemRef, ref);
    let tabIndex;
    if (!props.disabled) {
      tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends({
        ref: handleRef,
        role,
        tabIndex,
        component,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        className: clsx(classes.root, className)
      }, other, {
        ownerState,
        classes
      }))
    });
  });
  const MUIMenuItem = MenuItem;
  function getSkeletonUtilityClass(slot) {
    return generateUtilityClass("MuiSkeleton", slot);
  }
  generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
  const _excluded$1h = ["animation", "className", "component", "height", "style", "variant", "width"];
  let _$1 = (t2) => t2, _t$1, _t2$1, _t3$1, _t4$1;
  const useUtilityClasses$Y = (ownerState) => {
    const {
      classes,
      variant,
      animation,
      hasChildren,
      width: width2,
      height: height2
    } = ownerState;
    const slots = {
      root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
    };
    return composeClasses(slots, getSkeletonUtilityClass, classes);
  };
  const pulseKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
  const waveKeyframe = keyframes(_t2$1 || (_t2$1 = _$1`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
  const SkeletonRoot = styled$1("span", {
    name: "MuiSkeleton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
    }
  })(({
    theme,
    ownerState
  }) => {
    const radiusUnit = getUnit(theme.shape.borderRadius) || "px";
    const radiusValue = toUnitless(theme.shape.borderRadius);
    return _extends({
      display: "block",
      // Create a "on paper" color with sufficient contrast retaining the color
      backgroundColor: theme.vars ? theme.vars.palette.Skeleton.bg : alpha(theme.palette.text.primary, theme.palette.mode === "light" ? 0.11 : 0.13),
      height: "1.2em"
    }, ownerState.variant === "text" && {
      marginTop: 0,
      marginBottom: 0,
      height: "auto",
      transformOrigin: "0 55%",
      transform: "scale(1, 0.60)",
      borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
      "&:empty:before": {
        content: '"\\00a0"'
      }
    }, ownerState.variant === "circular" && {
      borderRadius: "50%"
    }, ownerState.variant === "rounded" && {
      borderRadius: (theme.vars || theme).shape.borderRadius
    }, ownerState.hasChildren && {
      "& > *": {
        visibility: "hidden"
      }
    }, ownerState.hasChildren && !ownerState.width && {
      maxWidth: "fit-content"
    }, ownerState.hasChildren && !ownerState.height && {
      height: "auto"
    });
  }, ({
    ownerState
  }) => ownerState.animation === "pulse" && css(_t3$1 || (_t3$1 = _$1`
      animation: ${0} 2s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
    ownerState,
    theme
  }) => ownerState.animation === "wave" && css(_t4$1 || (_t4$1 = _$1`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 2s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme.vars || theme).palette.action.hover));
  const Skeleton = /* @__PURE__ */ React__namespace.forwardRef(function Skeleton2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiSkeleton"
    });
    const {
      animation = "pulse",
      className,
      component = "span",
      height: height2,
      style: style2,
      variant = "text",
      width: width2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1h);
    const ownerState = _extends({}, props, {
      animation,
      component,
      variant,
      hasChildren: Boolean(other.children)
    });
    const classes = useUtilityClasses$Y(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, _extends({
      as: component,
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      style: _extends({
        width: width2,
        height: height2
      }, style2)
    }));
  });
  const Skeleton$1 = Skeleton;
  const _excluded$1g = ["field", "align", "width", "contentWidth"];
  const useUtilityClasses$X = (ownerState) => {
    const {
      align,
      classes
    } = ownerState;
    const slots = {
      root: ["cell", "cellSkeleton", `cell--text${capitalize(align)}`, "withBorderColor"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridSkeletonCell(props) {
    const {
      align,
      width: width2,
      contentWidth
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1g);
    const rootProps = useGridRootProps();
    const ownerState = {
      classes: rootProps.classes,
      align
    };
    const classes = useUtilityClasses$X(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends({
      className: classes.root,
      style: {
        width: width2
      }
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, {
        width: `${contentWidth}%`
      })
    }));
  }
  function getBorderColor(theme) {
    if (theme.vars) {
      return theme.vars.palette.TableCell.border;
    }
    if (theme.palette.mode === "light") {
      return lighten(alpha(theme.palette.divider, 1), 0.88);
    }
    return darken(alpha(theme.palette.divider, 1), 0.68);
  }
  const columnHeadersStyles = {
    [`.${gridClasses.columnSeparator}, .${gridClasses["columnSeparator--resizing"]}`]: {
      visibility: "visible",
      width: "auto"
    }
  };
  const columnHeaderStyles = {
    [`& .${gridClasses.iconButtonContainer}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.menuIcon}`]: {
      width: "auto",
      visibility: "visible"
    }
  };
  const GridRootStyles = styled$1("div", {
    name: "MuiDataGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => [
      {
        [`&.${gridClasses.autoHeight}`]: styles2.autoHeight
      },
      {
        [`&.${gridClasses.aggregationColumnHeader}`]: styles2.aggregationColumnHeader
      },
      {
        [`&.${gridClasses["aggregationColumnHeader--alignLeft"]}`]: styles2["aggregationColumnHeader--alignLeft"]
      },
      {
        [`&.${gridClasses["aggregationColumnHeader--alignCenter"]}`]: styles2["aggregationColumnHeader--alignCenter"]
      },
      {
        [`&.${gridClasses["aggregationColumnHeader--alignRight"]}`]: styles2["aggregationColumnHeader--alignRight"]
      },
      {
        [`&.${gridClasses.aggregationColumnHeaderLabel}`]: styles2.aggregationColumnHeaderLabel
      },
      {
        [`&.${gridClasses["root--disableUserSelection"]} .${gridClasses.cell}`]: styles2["root--disableUserSelection"]
      },
      {
        [`& .${gridClasses.editBooleanCell}`]: styles2.editBooleanCell
      },
      {
        [`& .${gridClasses["cell--editing"]}`]: styles2["cell--editing"]
      },
      {
        [`& .${gridClasses["cell--textCenter"]}`]: styles2["cell--textCenter"]
      },
      {
        [`& .${gridClasses["cell--textLeft"]}`]: styles2["cell--textLeft"]
      },
      {
        [`& .${gridClasses["cell--textRight"]}`]: styles2["cell--textRight"]
      },
      // TODO v6: Remove
      {
        [`& .${gridClasses["cell--withRenderer"]}`]: styles2["cell--withRenderer"]
      },
      {
        [`& .${gridClasses.cell}`]: styles2.cell
      },
      {
        [`& .${gridClasses["cell--rangeTop"]}`]: styles2["cell--rangeTop"]
      },
      {
        [`& .${gridClasses["cell--rangeBottom"]}`]: styles2["cell--rangeBottom"]
      },
      {
        [`& .${gridClasses["cell--rangeLeft"]}`]: styles2["cell--rangeLeft"]
      },
      {
        [`& .${gridClasses["cell--rangeRight"]}`]: styles2["cell--rangeRight"]
      },
      {
        [`& .${gridClasses["cell--withRightBorder"]}`]: styles2["cell--withRightBorder"]
      },
      {
        [`& .${gridClasses.cellContent}`]: styles2.cellContent
      },
      {
        [`& .${gridClasses.cellCheckbox}`]: styles2.cellCheckbox
      },
      {
        [`& .${gridClasses.cellSkeleton}`]: styles2.cellSkeleton
      },
      {
        [`& .${gridClasses.checkboxInput}`]: styles2.checkboxInput
      },
      {
        [`& .${gridClasses["columnHeader--alignCenter"]}`]: styles2["columnHeader--alignCenter"]
      },
      {
        [`& .${gridClasses["columnHeader--alignLeft"]}`]: styles2["columnHeader--alignLeft"]
      },
      {
        [`& .${gridClasses["columnHeader--alignRight"]}`]: styles2["columnHeader--alignRight"]
      },
      {
        [`& .${gridClasses["columnHeader--dragging"]}`]: styles2["columnHeader--dragging"]
      },
      {
        [`& .${gridClasses["columnHeader--moving"]}`]: styles2["columnHeader--moving"]
      },
      {
        [`& .${gridClasses["columnHeader--numeric"]}`]: styles2["columnHeader--numeric"]
      },
      {
        [`& .${gridClasses["columnHeader--sortable"]}`]: styles2["columnHeader--sortable"]
      },
      {
        [`& .${gridClasses["columnHeader--sorted"]}`]: styles2["columnHeader--sorted"]
      },
      {
        [`& .${gridClasses["columnHeader--withRightBorder"]}`]: styles2["columnHeader--withRightBorder"]
      },
      {
        [`& .${gridClasses.columnHeader}`]: styles2.columnHeader
      },
      {
        [`& .${gridClasses.headerFilterRow}`]: styles2.headerFilterRow
      },
      {
        [`& .${gridClasses.columnHeaderCheckbox}`]: styles2.columnHeaderCheckbox
      },
      {
        [`& .${gridClasses.columnHeaderDraggableContainer}`]: styles2.columnHeaderDraggableContainer
      },
      {
        [`& .${gridClasses.columnHeaderTitleContainer}`]: styles2.columnHeaderTitleContainer
      },
      {
        [`& .${gridClasses["columnSeparator--resizable"]}`]: styles2["columnSeparator--resizable"]
      },
      {
        [`& .${gridClasses["columnSeparator--resizing"]}`]: styles2["columnSeparator--resizing"]
      },
      {
        [`& .${gridClasses.columnSeparator}`]: styles2.columnSeparator
      },
      {
        [`& .${gridClasses.filterIcon}`]: styles2.filterIcon
      },
      {
        [`& .${gridClasses.iconSeparator}`]: styles2.iconSeparator
      },
      {
        [`& .${gridClasses.menuIcon}`]: styles2.menuIcon
      },
      {
        [`& .${gridClasses.menuIconButton}`]: styles2.menuIconButton
      },
      {
        [`& .${gridClasses.menuOpen}`]: styles2.menuOpen
      },
      {
        [`& .${gridClasses.menuList}`]: styles2.menuList
      },
      {
        [`& .${gridClasses["row--editable"]}`]: styles2["row--editable"]
      },
      {
        [`& .${gridClasses["row--editing"]}`]: styles2["row--editing"]
      },
      {
        [`& .${gridClasses["row--dragging"]}`]: styles2["row--dragging"]
      },
      {
        [`& .${gridClasses.row}`]: styles2.row
      },
      {
        [`& .${gridClasses.rowReorderCellPlaceholder}`]: styles2.rowReorderCellPlaceholder
      },
      {
        [`& .${gridClasses.rowReorderCell}`]: styles2.rowReorderCell
      },
      {
        [`& .${gridClasses["rowReorderCell--draggable"]}`]: styles2["rowReorderCell--draggable"]
      },
      {
        [`& .${gridClasses.sortIcon}`]: styles2.sortIcon
      },
      {
        [`& .${gridClasses.withBorderColor}`]: styles2.withBorderColor
      },
      {
        [`& .${gridClasses.treeDataGroupingCell}`]: styles2.treeDataGroupingCell
      },
      {
        [`& .${gridClasses.treeDataGroupingCellToggle}`]: styles2.treeDataGroupingCellToggle
      },
      {
        [`& .${gridClasses.detailPanelToggleCell}`]: styles2.detailPanelToggleCell
      },
      {
        [`& .${gridClasses["detailPanelToggleCell--expanded"]}`]: styles2["detailPanelToggleCell--expanded"]
      },
      styles2.root
    ]
  })(({
    theme
  }) => {
    const borderColor2 = getBorderColor(theme);
    const radius = theme.shape.borderRadius;
    const gridStyle = _extends({
      "--unstable_DataGrid-radius": typeof radius === "number" ? `${radius}px` : radius,
      "--unstable_DataGrid-headWeight": theme.typography.fontWeightMedium,
      "--unstable_DataGrid-overlayBackground": theme.vars ? `rgba(${theme.vars.palette.background.defaultChannel} / ${theme.vars.palette.action.disabledOpacity})` : alpha(theme.palette.background.default, theme.palette.action.disabledOpacity),
      "--DataGrid-cellOffsetMultiplier": 2,
      flex: 1,
      boxSizing: "border-box",
      position: "relative",
      borderWidth: "1px",
      borderStyle: "solid",
      borderColor: borderColor2,
      borderRadius: "var(--unstable_DataGrid-radius)",
      color: (theme.vars || theme).palette.text.primary
    }, theme.typography.body2, {
      outline: "none",
      height: "100%",
      display: "flex",
      minWidth: 0,
      // See https://github.com/mui/mui-x/issues/8547
      minHeight: 0,
      flexDirection: "column",
      overflowAnchor: "none",
      // Keep the same scrolling position
      [`&.${gridClasses.autoHeight}`]: {
        height: "auto",
        [`& .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
          borderBottomColor: "transparent"
        }
      },
      [`& .${gridClasses["virtualScrollerContent--overflowed"]} .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
        borderBottomColor: "transparent"
      },
      [`& .${gridClasses.columnHeader}, & .${gridClasses.cell}`]: {
        WebkitTapHighlightColor: "transparent",
        lineHeight: null,
        padding: "0 10px",
        boxSizing: "border-box"
      },
      [`& .${gridClasses.columnHeader}:focus-within, & .${gridClasses.cell}:focus-within`]: {
        outline: `solid ${theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / 0.5)` : alpha(theme.palette.primary.main, 0.5)} 1px`,
        outlineWidth: 1,
        outlineOffset: -1
      },
      [`& .${gridClasses.columnHeader}:focus, & .${gridClasses.cell}:focus`]: {
        outline: `solid ${theme.palette.primary.main} 1px`
      },
      [`& .${gridClasses.columnHeaderCheckbox}, & .${gridClasses.cellCheckbox}`]: {
        padding: 0,
        justifyContent: "center",
        alignItems: "center"
      },
      [`& .${gridClasses.columnHeader}`]: {
        position: "relative",
        display: "flex",
        alignItems: "center"
      },
      [`& .${gridClasses["columnHeader--sorted"]} .${gridClasses.iconButtonContainer}, & .${gridClasses["columnHeader--filtered"]} .${gridClasses.iconButtonContainer}`]: {
        visibility: "visible",
        width: "auto"
      },
      [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}) .${gridClasses.sortIcon}`]: {
        opacity: 0,
        transition: theme.transitions.create(["opacity"], {
          duration: theme.transitions.duration.shorter
        })
      },
      [`& .${gridClasses.columnHeaderTitleContainer}`]: {
        display: "flex",
        alignItems: "center",
        minWidth: 0,
        flex: 1,
        whiteSpace: "nowrap",
        overflow: "hidden",
        // to anchor the aggregation label
        position: "relative"
      },
      [`& .${gridClasses.columnHeaderTitleContainerContent}`]: {
        overflow: "hidden",
        display: "flex",
        alignItems: "center"
      },
      [`& .${gridClasses["columnHeader--filledGroup"]} .${gridClasses.columnHeaderTitleContainer}`]: {
        borderBottomWidth: "1px",
        borderBottomStyle: "solid",
        boxSizing: "border-box"
      },
      [`& .${gridClasses["columnHeader--filledGroup"]}.${gridClasses["columnHeader--showColumnBorder"]} .${gridClasses.columnHeaderTitleContainer}`]: {
        borderBottom: `none`
      },
      [`& .${gridClasses["columnHeader--filledGroup"]}.${gridClasses["columnHeader--showColumnBorder"]}`]: {
        borderBottomWidth: "1px",
        borderBottomStyle: "solid",
        boxSizing: "border-box"
      },
      [`& .${gridClasses.headerFilterRow}`]: {
        borderTop: `1px solid ${borderColor2}`
      },
      [`& .${gridClasses.sortIcon}, & .${gridClasses.filterIcon}`]: {
        fontSize: "inherit"
      },
      [`& .${gridClasses["columnHeader--sortable"]}`]: {
        cursor: "pointer"
      },
      [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.columnHeaderTitleContainer}`]: {
        justifyContent: "center"
      },
      [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderDraggableContainer}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderTitleContainer}`]: {
        flexDirection: "row-reverse"
      },
      [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.menuIcon}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
        marginRight: "auto",
        marginLeft: -6
      },
      [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
        marginRight: "auto",
        marginLeft: -10
      },
      [`& .${gridClasses["columnHeader--moving"]}`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover
      },
      [`& .${gridClasses.columnSeparator}`]: {
        visibility: "hidden",
        position: "absolute",
        zIndex: 100,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        color: borderColor2
      },
      "@media (hover: hover)": {
        [`& .${gridClasses.columnHeaders}:hover`]: columnHeadersStyles,
        [`& .${gridClasses.columnHeader}:hover`]: columnHeaderStyles,
        [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}):hover .${gridClasses.sortIcon}`]: {
          opacity: 0.5
        }
      },
      "@media (hover: none)": {
        [`& .${gridClasses.columnHeaders}`]: columnHeadersStyles,
        [`& .${gridClasses.columnHeader}`]: columnHeaderStyles
      },
      [`& .${gridClasses["columnSeparator--sideLeft"]}`]: {
        left: -12
      },
      [`& .${gridClasses["columnSeparator--sideRight"]}`]: {
        right: -12
      },
      [`& .${gridClasses["columnSeparator--resizable"]}`]: {
        cursor: "col-resize",
        touchAction: "none",
        "&:hover": {
          color: (theme.vars || theme).palette.text.primary,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            color: borderColor2
          }
        },
        [`&.${gridClasses["columnSeparator--resizing"]}`]: {
          color: (theme.vars || theme).palette.text.primary
        },
        "& svg": {
          pointerEvents: "none"
        }
      },
      [`& .${gridClasses.iconSeparator}`]: {
        color: "inherit"
      },
      [`& .${gridClasses.menuIcon}`]: {
        width: 0,
        visibility: "hidden",
        fontSize: 20,
        marginRight: -10,
        display: "flex",
        alignItems: "center"
      },
      [`.${gridClasses.menuOpen}`]: {
        visibility: "visible",
        width: "auto"
      },
      [`& .${gridClasses.row}`]: {
        display: "flex",
        width: "fit-content",
        breakInside: "avoid",
        // Avoid the row to be broken in two different print pages.
        "&:hover, &.Mui-hovered": {
          backgroundColor: (theme.vars || theme).palette.action.hover,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        "&.Mui-selected": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
          "&:hover, &.Mui-hovered": {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity + theme.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
            }
          }
        }
      },
      [`& .${gridClasses.cell}`]: {
        display: "flex",
        alignItems: "center",
        borderBottom: "1px solid",
        "&.Mui-selected": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
          "&:hover, &.Mui-hovered": {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity + theme.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
            }
          }
        }
      },
      [`&.${gridClasses["root--disableUserSelection"]} .${gridClasses.cell}`]: {
        userSelect: "none"
      },
      [`& .${gridClasses.row}:not(.${gridClasses["row--dynamicHeight"]}) > .${gridClasses.cell}`]: {
        overflow: "hidden",
        whiteSpace: "nowrap"
      },
      [`& .${gridClasses.cellContent}`]: {
        overflow: "hidden",
        textOverflow: "ellipsis"
      },
      [`& .${gridClasses.cell}.${gridClasses["cell--editing"]}`]: {
        padding: 1,
        display: "flex",
        boxShadow: theme.shadows[2],
        backgroundColor: (theme.vars || theme).palette.background.paper,
        "&:focus-within": {
          outline: `solid ${(theme.vars || theme).palette.primary.main} 1px`,
          outlineOffset: "-1px"
        }
      },
      [`& .${gridClasses["row--editing"]}`]: {
        boxShadow: theme.shadows[2]
      },
      [`& .${gridClasses["row--editing"]} .${gridClasses.cell}`]: {
        boxShadow: theme.shadows[0],
        backgroundColor: (theme.vars || theme).palette.background.paper
      },
      [`& .${gridClasses.editBooleanCell}`]: {
        display: "flex",
        height: "100%",
        width: "100%",
        alignItems: "center",
        justifyContent: "center"
      },
      [`& .${gridClasses.booleanCell}[data-value="true"]`]: {
        color: (theme.vars || theme).palette.text.secondary
      },
      [`& .${gridClasses.booleanCell}[data-value="false"]`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`& .${gridClasses.actionsCell}`]: {
        display: "inline-flex",
        alignItems: "center",
        gridGap: theme.spacing(1)
      },
      [`& .${gridClasses.rowReorderCell}`]: {
        display: "inline-flex",
        flex: 1,
        alignItems: "center",
        justifyContent: "center",
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      },
      [`& .${gridClasses["rowReorderCell--draggable"]}`]: {
        cursor: "move",
        opacity: 1
      },
      [`& .${gridClasses.rowReorderCellContainer}`]: {
        padding: 0,
        alignItems: "stretch"
      },
      [`.${gridClasses.withBorderColor}`]: {
        borderColor: borderColor2
      },
      [`& .${gridClasses["cell--withRightBorder"]}`]: {
        borderRightWidth: "1px",
        borderRightStyle: "solid"
      },
      [`& .${gridClasses["columnHeader--withRightBorder"]}`]: {
        borderRightWidth: "1px",
        borderRightStyle: "solid"
      },
      [`& .${gridClasses["cell--textLeft"]}`]: {
        justifyContent: "flex-start"
      },
      [`& .${gridClasses["cell--textRight"]}`]: {
        justifyContent: "flex-end"
      },
      [`& .${gridClasses["cell--textCenter"]}`]: {
        justifyContent: "center"
      },
      [`& .${gridClasses.columnHeaderDraggableContainer}`]: {
        display: "flex",
        width: "100%",
        height: "100%"
      },
      [`& .${gridClasses.rowReorderCellPlaceholder}`]: {
        display: "none"
      },
      [`& .${gridClasses["columnHeader--dragging"]}, & .${gridClasses["row--dragging"]}`]: {
        background: (theme.vars || theme).palette.background.paper,
        padding: "0 12px",
        borderRadius: "var(--unstable_DataGrid-radius)",
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      },
      [`& .${gridClasses["row--dragging"]}`]: {
        background: (theme.vars || theme).palette.background.paper,
        padding: "0 12px",
        borderRadius: "var(--unstable_DataGrid-radius)",
        opacity: (theme.vars || theme).palette.action.disabledOpacity,
        [`& .${gridClasses.rowReorderCellPlaceholder}`]: {
          display: "flex"
        }
      },
      [`& .${gridClasses.treeDataGroupingCell}`]: {
        display: "flex",
        alignItems: "center",
        width: "100%"
      },
      [`& .${gridClasses.treeDataGroupingCellToggle}`]: {
        flex: "0 0 28px",
        alignSelf: "stretch",
        marginRight: theme.spacing(2)
      },
      [`& .${gridClasses.groupingCriteriaCell}`]: {
        display: "flex",
        alignItems: "center",
        width: "100%"
      },
      [`& .${gridClasses.groupingCriteriaCellToggle}`]: {
        flex: "0 0 28px",
        alignSelf: "stretch",
        marginRight: theme.spacing(2)
      }
    });
    return gridStyle;
  });
  const _excluded$1f = ["children", "className"];
  const useUtilityClasses$W = (ownerState) => {
    const {
      autoHeight,
      density,
      classes
    } = ownerState;
    const slots = {
      root: ["root", autoHeight && "autoHeight", `root--density${capitalize(density)}`, "withBorderColor"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridRoot = /* @__PURE__ */ React__namespace.forwardRef(function GridRoot2(props, ref) {
    var _rootProps$experiment;
    const rootProps = useGridRootProps();
    const {
      children,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1f);
    const apiRef2 = useGridPrivateApiContext();
    const densityValue = useGridSelector(apiRef2, gridDensityValueSelector);
    const rootContainerRef = React__namespace.useRef(null);
    const handleRef = useForkRef(rootContainerRef, ref);
    const getAriaAttributes = (_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.ariaV7 ? null : useGridAriaAttributes;
    const ariaAttributes = typeof getAriaAttributes === "function" ? getAriaAttributes() : null;
    const ownerState = _extends({}, rootProps, {
      density: densityValue
    });
    const classes = useUtilityClasses$W(ownerState);
    apiRef2.current.register("public", {
      rootElementRef: rootContainerRef
    });
    const [mountedState, setMountedState] = React__namespace.useState(false);
    useEnhancedEffect$1(() => {
      setMountedState(true);
    }, []);
    if (!mountedState) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRootStyles, _extends({
      ref: handleRef,
      className: clsx(className, classes.root),
      ownerState
    }, ariaAttributes, other, {
      children
    }));
  });
  const _excluded$1e = ["className"];
  const useUtilityClasses$V = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["footerContainer", "withBorderColor"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridFooterContainerRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "FooterContainer",
    overridesResolver: (props, styles2) => styles2.footerContainer
  })({
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    minHeight: 52,
    borderTop: "1px solid"
  });
  const GridFooterContainer = /* @__PURE__ */ React__namespace.forwardRef(function GridFooterContainer2(props, ref) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1e);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$V(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooterContainerRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState: rootProps
    }, other));
  });
  const _excluded$1d = ["className"];
  const useUtilityClasses$U = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["overlay"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridOverlayRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "Overlay",
    overridesResolver: (_2, styles2) => styles2.overlay
  })({
    width: "100%",
    height: "100%",
    display: "flex",
    alignSelf: "center",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "var(--unstable_DataGrid-overlayBackground)"
  });
  const GridOverlay = /* @__PURE__ */ React__namespace.forwardRef(function GridOverlay2(props, ref) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1d);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$U(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState: rootProps
    }, other));
  });
  const _excluded$1c = ["className", "children"];
  const useUtilityClasses$T = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["toolbarContainer"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridToolbarContainerRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "ToolbarContainer",
    overridesResolver: (_2, styles2) => styles2.toolbarContainer
  })(({
    theme
  }) => ({
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    gap: theme.spacing(1),
    padding: theme.spacing(0.5, 0.5, 0)
  }));
  const GridToolbarContainer = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbarContainer2(props, ref) {
    const {
      className,
      children
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1c);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$T(rootProps);
    if (!children) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarContainerRoot, _extends({
      ref,
      className: clsx(className, classes.root),
      ownerState: rootProps
    }, other, {
      children
    }));
  });
  function getBadgeUtilityClass(slot) {
    return generateUtilityClass("MuiBadge", slot);
  }
  const badgeClasses = generateUtilityClasses("MuiBadge", [
    "root",
    "badge",
    "dot",
    "standard",
    "anchorOriginTopRight",
    "anchorOriginBottomRight",
    "anchorOriginTopLeft",
    "anchorOriginBottomLeft",
    "invisible",
    "colorError",
    "colorInfo",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorWarning",
    "overlapRectangular",
    "overlapCircular",
    // TODO: v6 remove the overlap value from these class keys
    "anchorOriginTopLeftCircular",
    "anchorOriginTopLeftRectangular",
    "anchorOriginTopRightCircular",
    "anchorOriginTopRightRectangular",
    "anchorOriginBottomLeftCircular",
    "anchorOriginBottomLeftRectangular",
    "anchorOriginBottomRightCircular",
    "anchorOriginBottomRightRectangular"
  ]);
  const badgeClasses$1 = badgeClasses;
  const _excluded$1b = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"];
  const RADIUS_STANDARD = 10;
  const RADIUS_DOT = 4;
  const useUtilityClasses$S = (ownerState) => {
    const {
      color: color2,
      anchorOrigin,
      invisible,
      overlap,
      variant,
      classes = {}
    } = ownerState;
    const slots = {
      root: ["root"],
      badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}${capitalize(overlap)}`, `overlap${capitalize(overlap)}`, color2 !== "default" && `color${capitalize(color2)}`]
    };
    return composeClasses(slots, getBadgeUtilityClass, classes);
  };
  const BadgeRoot = styled$1("span", {
    name: "MuiBadge",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    position: "relative",
    display: "inline-flex",
    // For correct alignment with the text.
    verticalAlign: "middle",
    flexShrink: 0
  });
  const BadgeBadge = styled$1("span", {
    name: "MuiBadge",
    slot: "Badge",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}${capitalize(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.invisible && styles2.invisible];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    alignContent: "center",
    alignItems: "center",
    position: "absolute",
    boxSizing: "border-box",
    fontFamily: theme.typography.fontFamily,
    fontWeight: theme.typography.fontWeightMedium,
    fontSize: theme.typography.pxToRem(12),
    minWidth: RADIUS_STANDARD * 2,
    lineHeight: 1,
    padding: "0 6px",
    height: RADIUS_STANDARD * 2,
    borderRadius: RADIUS_STANDARD,
    zIndex: 1,
    // Render the badge on top of potential ripples.
    transition: theme.transitions.create("transform", {
      easing: theme.transitions.easing.easeInOut,
      duration: theme.transitions.duration.enteringScreen
    })
  }, ownerState.color !== "default" && {
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
    color: (theme.vars || theme).palette[ownerState.color].contrastText
  }, ownerState.variant === "dot" && {
    borderRadius: RADIUS_DOT,
    height: RADIUS_DOT * 2,
    minWidth: RADIUS_DOT * 2,
    padding: 0
  }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular" && {
    top: 0,
    right: 0,
    transform: "scale(1) translate(50%, -50%)",
    transformOrigin: "100% 0%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(50%, -50%)"
    }
  }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular" && {
    bottom: 0,
    right: 0,
    transform: "scale(1) translate(50%, 50%)",
    transformOrigin: "100% 100%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(50%, 50%)"
    }
  }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular" && {
    top: 0,
    left: 0,
    transform: "scale(1) translate(-50%, -50%)",
    transformOrigin: "0% 0%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(-50%, -50%)"
    }
  }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular" && {
    bottom: 0,
    left: 0,
    transform: "scale(1) translate(-50%, 50%)",
    transformOrigin: "0% 100%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(-50%, 50%)"
    }
  }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular" && {
    top: "14%",
    right: "14%",
    transform: "scale(1) translate(50%, -50%)",
    transformOrigin: "100% 0%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(50%, -50%)"
    }
  }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular" && {
    bottom: "14%",
    right: "14%",
    transform: "scale(1) translate(50%, 50%)",
    transformOrigin: "100% 100%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(50%, 50%)"
    }
  }, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular" && {
    top: "14%",
    left: "14%",
    transform: "scale(1) translate(-50%, -50%)",
    transformOrigin: "0% 0%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(-50%, -50%)"
    }
  }, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular" && {
    bottom: "14%",
    left: "14%",
    transform: "scale(1) translate(-50%, 50%)",
    transformOrigin: "0% 100%",
    [`&.${badgeClasses$1.invisible}`]: {
      transform: "scale(0) translate(-50%, 50%)"
    }
  }, ownerState.invisible && {
    transition: theme.transitions.create("transform", {
      easing: theme.transitions.easing.easeInOut,
      duration: theme.transitions.duration.leavingScreen
    })
  }));
  const Badge = /* @__PURE__ */ React__namespace.forwardRef(function Badge2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$badge, _slotProps$root, _slotProps$badge;
    const props = useThemeProps({
      props: inProps,
      name: "MuiBadge"
    });
    const {
      anchorOrigin: anchorOriginProp = {
        vertical: "top",
        horizontal: "right"
      },
      className,
      component,
      components = {},
      componentsProps = {},
      children,
      overlap: overlapProp = "rectangular",
      color: colorProp = "default",
      invisible: invisibleProp = false,
      max: maxProp = 99,
      badgeContent: badgeContentProp,
      slots,
      slotProps,
      showZero = false,
      variant: variantProp = "standard"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1b);
    const {
      badgeContent,
      invisible: invisibleFromHook,
      max: max2,
      displayValue: displayValueFromHook
    } = useBadge({
      max: maxProp,
      invisible: invisibleProp,
      badgeContent: badgeContentProp,
      showZero
    });
    const prevProps = usePreviousProps$1({
      anchorOrigin: anchorOriginProp,
      color: colorProp,
      overlap: overlapProp,
      variant: variantProp,
      badgeContent: badgeContentProp
    });
    const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
    const {
      color: color2 = colorProp,
      overlap = overlapProp,
      anchorOrigin = anchorOriginProp,
      variant = variantProp
    } = invisible ? prevProps : props;
    const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
    const ownerState = _extends({}, props, {
      badgeContent,
      invisible,
      max: max2,
      displayValue,
      showZero,
      anchorOrigin,
      color: color2,
      overlap,
      variant
    });
    const classes = useUtilityClasses$S(ownerState);
    const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : BadgeRoot;
    const BadgeSlot = (_ref2 = (_slots$badge = slots == null ? void 0 : slots.badge) != null ? _slots$badge : components.Badge) != null ? _ref2 : BadgeBadge;
    const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
    const badgeSlotProps = (_slotProps$badge = slotProps == null ? void 0 : slotProps.badge) != null ? _slotProps$badge : componentsProps.badge;
    const rootProps = useSlotProps({
      elementType: RootSlot,
      externalSlotProps: rootSlotProps,
      externalForwardedProps: other,
      additionalProps: {
        ref,
        as: component
      },
      ownerState,
      className: clsx(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
    });
    const badgeProps = useSlotProps({
      elementType: BadgeSlot,
      externalSlotProps: badgeSlotProps,
      ownerState,
      className: clsx(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends({}, rootProps, {
      children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, _extends({}, badgeProps, {
        children: displayValue
      }))]
    }));
  });
  const Badge$1 = Badge;
  const _excluded$1a = ["className"];
  const useUtilityClasses$R = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["iconButtonContainer"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridIconButtonContainerRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "IconButtonContainer",
    overridesResolver: (props, styles2) => styles2.iconButtonContainer
  })(() => ({
    display: "flex",
    visibility: "hidden",
    width: 0
  }));
  const GridIconButtonContainer = /* @__PURE__ */ React__namespace.forwardRef(function GridIconButtonContainer2(props, ref) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1a);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$R(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridIconButtonContainerRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState: rootProps
    }, other));
  });
  const useUtilityClasses$Q = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      icon: ["sortIcon"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function getIcon(icons, direction, className, sortingOrder) {
    let Icon;
    const iconProps = {};
    if (direction === "asc") {
      Icon = icons.columnSortedAscendingIcon;
    } else if (direction === "desc") {
      Icon = icons.columnSortedDescendingIcon;
    } else {
      Icon = icons.columnUnsortedIcon;
      iconProps.sortingOrder = sortingOrder;
    }
    return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends({
      fontSize: "small",
      className
    }, iconProps)) : null;
  }
  function GridColumnHeaderSortIconRaw(props) {
    var _rootProps$slotProps;
    const {
      direction,
      index,
      sortingOrder
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = _extends({}, props, {
      classes: rootProps.classes
    });
    const classes = useUtilityClasses$Q(ownerState);
    const iconElement = getIcon(rootProps.slots, direction, classes.icon, sortingOrder);
    if (!iconElement) {
      return null;
    }
    const iconButton = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends({
      tabIndex: -1,
      "aria-label": apiRef2.current.getLocaleText("columnHeaderSortIconLabel"),
      title: apiRef2.current.getLocaleText("columnHeaderSortIconLabel"),
      size: "small"
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
      children: iconElement
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridIconButtonContainer, {
      children: [index != null && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, {
        badgeContent: index,
        color: "default",
        children: iconButton
      }), index == null && iconButton]
    });
  }
  const GridColumnHeaderSortIcon = /* @__PURE__ */ React__namespace.memo(GridColumnHeaderSortIconRaw);
  const useUtilityClasses$P = (ownerState) => {
    const {
      classes,
      open
    } = ownerState;
    const slots = {
      root: ["menuIcon", open && "menuOpen"],
      button: ["menuIconButton"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const ColumnHeaderMenuIcon = /* @__PURE__ */ React__namespace.memo((props) => {
    var _rootProps$slotProps, _rootProps$slotProps2;
    const {
      colDef,
      open,
      columnMenuId,
      columnMenuButtonId,
      iconButtonRef
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = _extends({}, props, {
      classes: rootProps.classes
    });
    const classes = useUtilityClasses$P(ownerState);
    const handleMenuIconClick = React__namespace.useCallback((event) => {
      event.preventDefault();
      event.stopPropagation();
      apiRef2.current.toggleColumnMenu(colDef.field);
    }, [apiRef2, colDef.field]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: classes.root,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends({
        title: apiRef2.current.getLocaleText("columnMenuLabel"),
        enterDelay: 1e3
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTooltip, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends({
          ref: iconButtonRef,
          tabIndex: -1,
          className: classes.button,
          "aria-label": apiRef2.current.getLocaleText("columnMenuLabel"),
          size: "small",
          onClick: handleMenuIconClick,
          "aria-haspopup": "menu",
          "aria-expanded": open,
          "aria-controls": open ? columnMenuId : void 0,
          id: columnMenuButtonId
        }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseIconButton, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuIcon, {
            fontSize: "small"
          })
        }))
      }))
    });
  });
  function GridColumnHeaderMenu({
    columnMenuId,
    columnMenuButtonId,
    ContentComponent,
    contentComponentProps,
    field,
    open,
    target,
    onExited
  }) {
    const apiRef2 = useGridApiContext();
    const colDef = apiRef2.current.getColumn(field);
    const hideMenu = React__namespace.useCallback((event) => {
      event.stopPropagation();
      if (!(target != null && target.contains(event.target))) {
        apiRef2.current.hideColumnMenu();
      }
    }, [apiRef2, target]);
    if (!target || !colDef) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
      placement: `bottom-${colDef.align === "right" ? "start" : "end"}`,
      open,
      target,
      onClickAway: hideMenu,
      onExited,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentComponent, _extends({
        colDef,
        hideMenu,
        open,
        id: columnMenuId,
        labelledby: columnMenuButtonId
      }, contentComponentProps))
    });
  }
  const _excluded$19 = ["className"];
  const useUtilityClasses$O = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["columnHeaderTitle"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridColumnHeaderTitleRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "ColumnHeaderTitle",
    overridesResolver: (props, styles2) => styles2.columnHeaderTitle
  })({
    textOverflow: "ellipsis",
    overflow: "hidden",
    whiteSpace: "nowrap",
    fontWeight: "var(--unstable_DataGrid-headWeight)"
  });
  const ColumnHeaderInnerTitle = /* @__PURE__ */ React__namespace.forwardRef(function ColumnHeaderInnerTitle2(props, ref) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$19);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$O(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderTitleRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState: rootProps
    }, other));
  });
  function GridColumnHeaderTitle(props) {
    var _rootProps$slotProps;
    const {
      label,
      description
    } = props;
    const rootProps = useGridRootProps();
    const titleRef = React__namespace.useRef(null);
    const [tooltip, setTooltip] = React__namespace.useState("");
    const handleMouseOver = React__namespace.useCallback(() => {
      if (!description && titleRef != null && titleRef.current) {
        const isOver = isOverflown(titleRef.current);
        if (isOver) {
          setTooltip(label);
        } else {
          setTooltip("");
        }
      }
    }, [description, label]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends({
      title: description || tooltip
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTooltip, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnHeaderInnerTitle, {
        onMouseOver: handleMouseOver,
        ref: titleRef,
        children: label
      })
    }));
  }
  const _excluded$18 = ["resizable", "resizing", "height", "side"];
  var GridColumnHeaderSeparatorSides = /* @__PURE__ */ function(GridColumnHeaderSeparatorSides2) {
    GridColumnHeaderSeparatorSides2["Left"] = "left";
    GridColumnHeaderSeparatorSides2["Right"] = "right";
    return GridColumnHeaderSeparatorSides2;
  }(GridColumnHeaderSeparatorSides || {});
  const useUtilityClasses$N = (ownerState) => {
    const {
      resizable,
      resizing,
      classes,
      side
    } = ownerState;
    const slots = {
      root: ["columnSeparator", resizable && "columnSeparator--resizable", resizing && "columnSeparator--resizing", side && `columnSeparator--side${capitalize(side)}`],
      icon: ["iconSeparator"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridColumnHeaderSeparatorRaw(props) {
    const {
      height: height2,
      side = GridColumnHeaderSeparatorSides.Right
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$18);
    const rootProps = useGridRootProps();
    const ownerState = _extends({}, props, {
      side,
      classes: rootProps.classes
    });
    const classes = useUtilityClasses$N(ownerState);
    const stopClick = React__namespace.useCallback((event) => {
      event.preventDefault();
      event.stopPropagation();
    }, []);
    return (
      // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends({
        className: classes.root,
        style: {
          minHeight: height2,
          opacity: rootProps.showColumnVerticalBorder ? 0 : 1
        }
      }, other, {
        onClick: stopClick,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnResizeIcon, {
          className: classes.icon
        })
      }))
    );
  }
  const GridColumnHeaderSeparator = /* @__PURE__ */ React__namespace.memo(GridColumnHeaderSeparatorRaw);
  const _excluded$17 = ["classes", "columnMenuOpen", "colIndex", "height", "isResizing", "sortDirection", "hasFocus", "tabIndex", "separatorSide", "isDraggable", "headerComponent", "description", "elementId", "width", "columnMenuIconButton", "columnMenu", "columnTitleIconButtons", "headerClassName", "label", "resizable", "draggableContainerProps", "columnHeaderSeparatorProps"];
  const GridGenericColumnHeaderItem = /* @__PURE__ */ React__namespace.forwardRef(function GridGenericColumnHeaderItem2(props, ref) {
    const {
      classes,
      columnMenuOpen,
      colIndex,
      height: height2,
      isResizing,
      sortDirection,
      hasFocus,
      tabIndex,
      separatorSide,
      isDraggable,
      headerComponent,
      description,
      width: width2,
      columnMenuIconButton = null,
      columnMenu = null,
      columnTitleIconButtons = null,
      headerClassName,
      label,
      resizable,
      draggableContainerProps,
      columnHeaderSeparatorProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$17);
    const apiRef2 = useGridPrivateApiContext();
    const rootProps = useGridRootProps();
    const headerCellRef = React__namespace.useRef(null);
    const [showColumnMenuIcon, setShowColumnMenuIcon] = React__namespace.useState(columnMenuOpen);
    const handleRef = useForkRef(headerCellRef, ref);
    let ariaSort = "none";
    if (sortDirection != null) {
      ariaSort = sortDirection === "asc" ? "ascending" : "descending";
    }
    React__namespace.useEffect(() => {
      if (!showColumnMenuIcon) {
        setShowColumnMenuIcon(columnMenuOpen);
      }
    }, [showColumnMenuIcon, columnMenuOpen]);
    React__namespace.useLayoutEffect(() => {
      const columnMenuState = apiRef2.current.state.columnMenu;
      if (hasFocus && !columnMenuState.open) {
        const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
        const elementToFocus = focusableElement || headerCellRef.current;
        elementToFocus == null ? void 0 : elementToFocus.focus();
        apiRef2.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
      }
    }, [apiRef2, hasFocus]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends({
      ref: handleRef,
      className: clsx(classes.root, headerClassName),
      style: {
        height: height2,
        width: width2,
        minWidth: width2,
        maxWidth: width2
      },
      role: "columnheader",
      tabIndex,
      "aria-colindex": colIndex + 1,
      "aria-sort": ariaSort,
      "aria-label": headerComponent == null ? label : void 0
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends({
        className: classes.draggableContainer,
        draggable: isDraggable,
        role: "presentation"
      }, draggableContainerProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: classes.titleContainer,
          role: "presentation",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: classes.titleContainerContent,
            children: headerComponent !== void 0 ? headerComponent : /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderTitle, {
              label,
              description,
              columnWidth: width2
            })
          }), columnTitleIconButtons]
        }), columnMenuIconButton]
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderSeparator, _extends({
        resizable: !rootProps.disableColumnResize && !!resizable,
        resizing: isResizing,
        height: height2,
        side: separatorSide
      }, columnHeaderSeparatorProps)), columnMenu]
    }));
  });
  const useUtilityClasses$M = (ownerState) => {
    const {
      colDef,
      classes,
      isDragging,
      sortDirection,
      showRightBorder,
      filterItemsCounter
    } = ownerState;
    const isColumnSorted = sortDirection != null;
    const isColumnFiltered = filterItemsCounter != null && filterItemsCounter > 0;
    const isColumnNumeric = colDef.type === "number";
    const slots = {
      root: ["columnHeader", colDef.headerAlign === "left" && "columnHeader--alignLeft", colDef.headerAlign === "center" && "columnHeader--alignCenter", colDef.headerAlign === "right" && "columnHeader--alignRight", colDef.sortable && "columnHeader--sortable", isDragging && "columnHeader--moving", isColumnSorted && "columnHeader--sorted", isColumnFiltered && "columnHeader--filtered", isColumnNumeric && "columnHeader--numeric", "withBorderColor", showRightBorder && "columnHeader--withRightBorder"],
      draggableContainer: ["columnHeaderDraggableContainer"],
      titleContainer: ["columnHeaderTitleContainer"],
      titleContainerContent: ["columnHeaderTitleContainerContent"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridColumnHeaderItem(props) {
    var _rootProps$slotProps, _colDef$sortingOrder, _rootProps$slotProps2, _colDef$headerName;
    const {
      colDef,
      columnMenuOpen,
      colIndex,
      headerHeight,
      isResizing,
      sortDirection,
      sortIndex,
      filterItemsCounter,
      hasFocus,
      tabIndex,
      disableReorder,
      separatorSide
    } = props;
    const apiRef2 = useGridPrivateApiContext();
    const rootProps = useGridRootProps();
    const headerCellRef = React__namespace.useRef(null);
    const columnMenuId = useId();
    const columnMenuButtonId = useId();
    const iconButtonRef = React__namespace.useRef(null);
    const [showColumnMenuIcon, setShowColumnMenuIcon] = React__namespace.useState(columnMenuOpen);
    const isDraggable = React__namespace.useMemo(() => !rootProps.disableColumnReorder && !disableReorder && !colDef.disableReorder, [rootProps.disableColumnReorder, disableReorder, colDef.disableReorder]);
    let headerComponent;
    if (colDef.renderHeader) {
      headerComponent = colDef.renderHeader(apiRef2.current.getColumnHeaderParams(colDef.field));
    }
    const ownerState = _extends({}, props, {
      classes: rootProps.classes,
      showRightBorder: rootProps.showColumnVerticalBorder
    });
    const classes = useUtilityClasses$M(ownerState);
    const publish = React__namespace.useCallback((eventName) => (event) => {
      if (!event.currentTarget.contains(event.target)) {
        return;
      }
      apiRef2.current.publishEvent(eventName, apiRef2.current.getColumnHeaderParams(colDef.field), event);
    }, [apiRef2, colDef.field]);
    const mouseEventsHandlers = React__namespace.useMemo(() => ({
      onClick: publish("columnHeaderClick"),
      onDoubleClick: publish("columnHeaderDoubleClick"),
      onMouseOver: publish("columnHeaderOver"),
      // TODO remove as it's not used
      onMouseOut: publish("columnHeaderOut"),
      // TODO remove as it's not used
      onMouseEnter: publish("columnHeaderEnter"),
      // TODO remove as it's not used
      onMouseLeave: publish("columnHeaderLeave"),
      // TODO remove as it's not used
      onKeyDown: publish("columnHeaderKeyDown"),
      onFocus: publish("columnHeaderFocus"),
      onBlur: publish("columnHeaderBlur")
    }), [publish]);
    const draggableEventHandlers = React__namespace.useMemo(() => isDraggable ? {
      onDragStart: publish("columnHeaderDragStart"),
      onDragEnter: publish("columnHeaderDragEnter"),
      onDragOver: publish("columnHeaderDragOver"),
      onDragEnd: publish("columnHeaderDragEnd")
    } : {}, [isDraggable, publish]);
    const columnHeaderSeparatorProps = React__namespace.useMemo(() => ({
      onMouseDown: publish("columnSeparatorMouseDown")
    }), [publish]);
    React__namespace.useEffect(() => {
      if (!showColumnMenuIcon) {
        setShowColumnMenuIcon(columnMenuOpen);
      }
    }, [showColumnMenuIcon, columnMenuOpen]);
    const handleExited = React__namespace.useCallback(() => {
      setShowColumnMenuIcon(false);
    }, []);
    const columnMenuIconButton = !rootProps.disableColumnMenu && !colDef.disableColumnMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnHeaderMenuIcon, {
      colDef,
      columnMenuId,
      columnMenuButtonId,
      open: showColumnMenuIcon,
      iconButtonRef
    });
    const columnMenu = /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderMenu, {
      columnMenuId,
      columnMenuButtonId,
      field: colDef.field,
      open: columnMenuOpen,
      target: iconButtonRef.current,
      ContentComponent: rootProps.slots.columnMenu,
      contentComponentProps: (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.columnMenu,
      onExited: handleExited
    });
    const sortingOrder = (_colDef$sortingOrder = colDef.sortingOrder) != null ? _colDef$sortingOrder : rootProps.sortingOrder;
    const columnTitleIconButtons = /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [!rootProps.disableColumnFilter && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaderFilterIconButton, _extends({
        field: colDef.field,
        counter: filterItemsCounter
      }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.columnHeaderFilterIconButton)), colDef.sortable && !colDef.hideSortIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderSortIcon, {
        direction: sortDirection,
        index: sortIndex,
        sortingOrder
      })]
    });
    React__namespace.useLayoutEffect(() => {
      const columnMenuState = apiRef2.current.state.columnMenu;
      if (hasFocus && !columnMenuState.open) {
        const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
        const elementToFocus = focusableElement || headerCellRef.current;
        elementToFocus == null ? void 0 : elementToFocus.focus();
        apiRef2.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
      }
    }, [apiRef2, hasFocus]);
    const headerClassName = typeof colDef.headerClassName === "function" ? colDef.headerClassName({
      field: colDef.field,
      colDef
    }) : colDef.headerClassName;
    const label = (_colDef$headerName = colDef.headerName) != null ? _colDef$headerName : colDef.field;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnHeaderItem, _extends({
      ref: headerCellRef,
      classes,
      columnMenuOpen,
      colIndex,
      height: headerHeight,
      isResizing,
      sortDirection,
      hasFocus,
      tabIndex,
      separatorSide,
      isDraggable,
      headerComponent,
      description: colDef.description,
      elementId: colDef.field,
      width: colDef.computedWidth,
      columnMenuIconButton,
      columnTitleIconButtons,
      headerClassName,
      label,
      resizable: !rootProps.disableColumnResize && !!colDef.resizable,
      "data-field": colDef.field,
      columnMenu,
      draggableContainerProps: draggableEventHandlers,
      columnHeaderSeparatorProps
    }, mouseEventsHandlers));
  }
  const getDefaultGridFilterModel = () => ({
    items: [],
    logicOperator: GridLogicOperator.And,
    quickFilterValues: [],
    quickFilterLogicOperator: GridLogicOperator.And
  });
  const CLEANUP_TIMER_LOOP_MILLIS = 1e3;
  class TimerBasedCleanupTracking {
    constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
      this.timeouts = /* @__PURE__ */ new Map();
      this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
      this.cleanupTimeout = timeout;
    }
    register(object, unsubscribe, unregisterToken) {
      if (!this.timeouts) {
        this.timeouts = /* @__PURE__ */ new Map();
      }
      const timeout = setTimeout(() => {
        if (typeof unsubscribe === "function") {
          unsubscribe();
        }
        this.timeouts.delete(unregisterToken.cleanupToken);
      }, this.cleanupTimeout);
      this.timeouts.set(unregisterToken.cleanupToken, timeout);
    }
    unregister(unregisterToken) {
      const timeout = this.timeouts.get(unregisterToken.cleanupToken);
      if (timeout) {
        this.timeouts.delete(unregisterToken.cleanupToken);
        clearTimeout(timeout);
      }
    }
    reset() {
      if (this.timeouts) {
        this.timeouts.forEach((value, key) => {
          this.unregister({
            cleanupToken: key
          });
        });
        this.timeouts = void 0;
      }
    }
  }
  class FinalizationRegistryBasedCleanupTracking {
    constructor() {
      this.registry = new FinalizationRegistry((unsubscribe) => {
        if (typeof unsubscribe === "function") {
          unsubscribe();
        }
      });
    }
    register(object, unsubscribe, unregisterToken) {
      this.registry.register(object, unsubscribe, unregisterToken);
    }
    unregister(unregisterToken) {
      this.registry.unregister(unregisterToken);
    }
    // eslint-disable-next-line class-methods-use-this
    reset() {
    }
  }
  var GridSignature = /* @__PURE__ */ function(GridSignature2) {
    GridSignature2["DataGrid"] = "DataGrid";
    GridSignature2["DataGridPro"] = "DataGridPro";
    return GridSignature2;
  }(GridSignature || {});
  class ObjectToBeRetainedByReact {
  }
  function createUseGridApiEventHandler(registryContainer2) {
    let cleanupTokensCounter = 0;
    return function useGridApiEventHandler2(apiRef2, eventName, handler, options) {
      if (registryContainer2.registry === null) {
        registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
      }
      const [objectRetainedByReact] = React__namespace.useState(new ObjectToBeRetainedByReact());
      const subscription = React__namespace.useRef(null);
      const handlerRef = React__namespace.useRef();
      handlerRef.current = handler;
      const cleanupTokenRef = React__namespace.useRef(null);
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params, event, details) => {
          if (!event.defaultMuiPrevented) {
            var _handlerRef$current;
            (_handlerRef$current = handlerRef.current) == null ? void 0 : _handlerRef$current.call(handlerRef, params, event, details);
          }
        };
        subscription.current = apiRef2.current.subscribeEvent(eventName, enhancedHandler, options);
        cleanupTokensCounter += 1;
        cleanupTokenRef.current = {
          cleanupToken: cleanupTokensCounter
        };
        registryContainer2.registry.register(
          objectRetainedByReact,
          // The callback below will be called once this reference stops being retained
          () => {
            var _subscription$current;
            (_subscription$current = subscription.current) == null ? void 0 : _subscription$current.call(subscription);
            subscription.current = null;
            cleanupTokenRef.current = null;
          },
          cleanupTokenRef.current
        );
      } else if (!handlerRef.current && subscription.current) {
        subscription.current();
        subscription.current = null;
        if (cleanupTokenRef.current) {
          registryContainer2.registry.unregister(cleanupTokenRef.current);
          cleanupTokenRef.current = null;
        }
      }
      React__namespace.useEffect(() => {
        if (!subscription.current && handlerRef.current) {
          const enhancedHandler = (params, event, details) => {
            if (!event.defaultMuiPrevented) {
              var _handlerRef$current2;
              (_handlerRef$current2 = handlerRef.current) == null ? void 0 : _handlerRef$current2.call(handlerRef, params, event, details);
            }
          };
          subscription.current = apiRef2.current.subscribeEvent(eventName, enhancedHandler, options);
        }
        if (cleanupTokenRef.current && registryContainer2.registry) {
          registryContainer2.registry.unregister(cleanupTokenRef.current);
          cleanupTokenRef.current = null;
        }
        return () => {
          var _subscription$current2;
          (_subscription$current2 = subscription.current) == null ? void 0 : _subscription$current2.call(subscription);
          subscription.current = null;
        };
      }, [apiRef2, eventName, options]);
    };
  }
  const registryContainer = {
    registry: null
  };
  const useGridApiEventHandler = createUseGridApiEventHandler(registryContainer);
  const optionsSubscriberOptions = {
    isFirst: true
  };
  function useGridApiOptionHandler(apiRef2, eventName, handler) {
    useGridApiEventHandler(apiRef2, eventName, handler, optionsSubscriberOptions);
  }
  function useGridLogger(privateApiRef, name) {
    const logger = React__namespace.useRef(null);
    if (logger.current) {
      return logger.current;
    }
    const newLogger = privateApiRef.current.getLogger(name);
    logger.current = newLogger;
    return newLogger;
  }
  function isNumber$1(value) {
    return typeof value === "number";
  }
  function isFunction$1(value) {
    return typeof value === "function";
  }
  function isObject$1(value) {
    return typeof value === "object" && value !== null;
  }
  function localStorageAvailable() {
    try {
      const key = "__some_random_key_you_are_not_going_to_use__";
      window.localStorage.setItem(key, key);
      window.localStorage.removeItem(key);
      return true;
    } catch (err) {
      return false;
    }
  }
  function escapeRegExp(value) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  const clamp = (value, min2, max2) => Math.max(min2, Math.min(max2, value));
  function isDeepEqual(a, b2) {
    if (a === b2) {
      return true;
    }
    if (a && b2 && typeof a === "object" && typeof b2 === "object") {
      if (a.constructor !== b2.constructor) {
        return false;
      }
      if (Array.isArray(a)) {
        const length3 = a.length;
        if (length3 !== b2.length) {
          return false;
        }
        for (let i = 0; i < length3; i += 1) {
          if (!isDeepEqual(a[i], b2[i])) {
            return false;
          }
        }
        return true;
      }
      if (a instanceof Map && b2 instanceof Map) {
        if (a.size !== b2.size) {
          return false;
        }
        const entriesA = Array.from(a.entries());
        for (let i = 0; i < entriesA.length; i += 1) {
          if (!b2.has(entriesA[i][0])) {
            return false;
          }
        }
        for (let i = 0; i < entriesA.length; i += 1) {
          const entryA = entriesA[i];
          if (!isDeepEqual(entryA[1], b2.get(entryA[0]))) {
            return false;
          }
        }
        return true;
      }
      if (a instanceof Set && b2 instanceof Set) {
        if (a.size !== b2.size) {
          return false;
        }
        const entries = Array.from(a.entries());
        for (let i = 0; i < entries.length; i += 1) {
          if (!b2.has(entries[i][0])) {
            return false;
          }
        }
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b2)) {
        const length3 = a.length;
        if (length3 !== b2.length) {
          return false;
        }
        for (let i = 0; i < length3; i += 1) {
          if (a[i] !== b2[i]) {
            return false;
          }
        }
        return true;
      }
      if (a.constructor === RegExp) {
        return a.source === b2.source && a.flags === b2.flags;
      }
      if (a.valueOf !== Object.prototype.valueOf) {
        return a.valueOf() === b2.valueOf();
      }
      if (a.toString !== Object.prototype.toString) {
        return a.toString() === b2.toString();
      }
      const keys = Object.keys(a);
      const length2 = keys.length;
      if (length2 !== Object.keys(b2).length) {
        return false;
      }
      for (let i = 0; i < length2; i += 1) {
        if (!Object.prototype.hasOwnProperty.call(b2, keys[i])) {
          return false;
        }
      }
      for (let i = 0; i < length2; i += 1) {
        const key = keys[i];
        if (!isDeepEqual(a[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    return a !== a && b2 !== b2;
  }
  function mulberry32(a) {
    return () => {
      let t2 = a += 1831565813;
      t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
      t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
      return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
    };
  }
  function randomNumberBetween(seed, min2, max2) {
    const random = mulberry32(seed);
    return () => min2 + (max2 - min2) * random();
  }
  function deepClone(obj) {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    }
    return JSON.parse(JSON.stringify(obj));
  }
  const useGridNativeEventListener = (apiRef2, ref, eventName, handler, options) => {
    const logger = useGridLogger(apiRef2, "useNativeEventListener");
    const [added, setAdded] = React__namespace.useState(false);
    const handlerRef = React__namespace.useRef(handler);
    const wrapHandler = React__namespace.useCallback((event) => {
      return handlerRef.current && handlerRef.current(event);
    }, []);
    React__namespace.useEffect(() => {
      handlerRef.current = handler;
    }, [handler]);
    React__namespace.useEffect(() => {
      let targetElement;
      if (isFunction$1(ref)) {
        targetElement = ref();
      } else {
        targetElement = ref && ref.current ? ref.current : null;
      }
      if (targetElement && eventName && !added) {
        logger.debug(`Binding native ${eventName} event`);
        targetElement.addEventListener(eventName, wrapHandler, options);
        const boundElem = targetElement;
        setAdded(true);
        const unsubscribe = () => {
          logger.debug(`Clearing native ${eventName} event`);
          boundElem.removeEventListener(eventName, wrapHandler, options);
        };
        apiRef2.current.subscribeEvent("unmount", unsubscribe);
      }
    }, [ref, wrapHandler, eventName, added, logger, options, apiRef2]);
  };
  const useFirstRender = (callback) => {
    const isFirstRender = React__namespace.useRef(true);
    if (isFirstRender.current) {
      isFirstRender.current = false;
      callback();
    }
  };
  const MAX_PAGE_SIZE = 100;
  const defaultPageSize = (autoPageSize) => autoPageSize ? 0 : 100;
  const getPageCount = (rowCount, pageSize2) => {
    if (pageSize2 > 0 && rowCount > 0) {
      return Math.ceil(rowCount / pageSize2);
    }
    return 0;
  };
  buildWarning(["MUI: the 'rowCount' prop is undefined while using paginationMode='server'", "For more detail, see http://mui.com/components/data-grid/pagination/#basic-implementation"], "error");
  const getDefaultGridPaginationModel = (autoPageSize) => ({
    page: 0,
    pageSize: autoPageSize ? 0 : 100
  });
  const getValidPage = (page, pageCount = 0) => {
    if (pageCount === 0) {
      return page;
    }
    return Math.max(Math.min(page, pageCount - 1), 0);
  };
  const throwIfPageSizeExceedsTheLimit = (pageSize2, signatureProp) => {
    if (signatureProp === GridSignature.DataGrid && pageSize2 > MAX_PAGE_SIZE) {
      throw new Error(["MUI: `pageSize` cannot exceed 100 in the MIT version of the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
    }
  };
  const gridPaginationSelector = (state) => state.pagination;
  const gridPaginationModelSelector = createSelector(gridPaginationSelector, (pagination) => pagination.paginationModel);
  const gridPageSelector = createSelector(gridPaginationModelSelector, (paginationModel) => paginationModel.page);
  const gridPageSizeSelector = createSelector(gridPaginationModelSelector, (paginationModel) => paginationModel.pageSize);
  createSelector(gridPaginationModelSelector, gridFilteredTopLevelRowCountSelector, (paginationModel, visibleTopLevelRowCount) => getPageCount(visibleTopLevelRowCount, paginationModel.pageSize));
  const gridPaginationRowRangeSelector = createSelectorMemoized(gridPaginationModelSelector, gridRowTreeSelector, gridRowMaximumTreeDepthSelector, gridExpandedSortedRowEntriesSelector, gridFilteredSortedTopLevelRowEntriesSelector, (paginationModel, rowTree, rowTreeDepth, visibleSortedRowEntries, visibleSortedTopLevelRowEntries) => {
    const visibleTopLevelRowCount = visibleSortedTopLevelRowEntries.length;
    const topLevelFirstRowIndex = Math.min(paginationModel.pageSize * paginationModel.page, visibleTopLevelRowCount - 1);
    const topLevelLastRowIndex = Math.min(topLevelFirstRowIndex + paginationModel.pageSize - 1, visibleTopLevelRowCount - 1);
    if (topLevelFirstRowIndex === -1 || topLevelLastRowIndex === -1) {
      return null;
    }
    if (rowTreeDepth < 2) {
      return {
        firstRowIndex: topLevelFirstRowIndex,
        lastRowIndex: topLevelLastRowIndex
      };
    }
    const topLevelFirstRow = visibleSortedTopLevelRowEntries[topLevelFirstRowIndex];
    const topLevelRowsInCurrentPageCount = topLevelLastRowIndex - topLevelFirstRowIndex + 1;
    const firstRowIndex = visibleSortedRowEntries.findIndex((row) => row.id === topLevelFirstRow.id);
    let lastRowIndex = firstRowIndex;
    let topLevelRowAdded = 0;
    while (lastRowIndex < visibleSortedRowEntries.length && topLevelRowAdded <= topLevelRowsInCurrentPageCount) {
      var _rowTree$row$id;
      const row = visibleSortedRowEntries[lastRowIndex];
      const depth = (_rowTree$row$id = rowTree[row.id]) == null ? void 0 : _rowTree$row$id.depth;
      if (depth === void 0) {
        lastRowIndex += 1;
      } else {
        if (topLevelRowAdded < topLevelRowsInCurrentPageCount || depth > 0) {
          lastRowIndex += 1;
        }
        if (depth === 0) {
          topLevelRowAdded += 1;
        }
      }
    }
    return {
      firstRowIndex,
      lastRowIndex: lastRowIndex - 1
    };
  });
  const gridPaginatedVisibleSortedGridRowEntriesSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, gridPaginationRowRangeSelector, (visibleSortedRowEntries, paginationRange) => {
    if (!paginationRange) {
      return [];
    }
    return visibleSortedRowEntries.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
  });
  const gridPaginatedVisibleSortedGridRowIdsSelector = createSelectorMemoized(gridExpandedSortedRowIdsSelector, gridPaginationRowRangeSelector, (visibleSortedRowIds, paginationRange) => {
    if (!paginationRange) {
      return [];
    }
    return visibleSortedRowIds.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
  });
  const gridPreferencePanelStateSelector = (state) => state.preferencePanel;
  var GridPreferencePanelsValue = /* @__PURE__ */ function(GridPreferencePanelsValue2) {
    GridPreferencePanelsValue2["filters"] = "filters";
    GridPreferencePanelsValue2["columns"] = "columns";
    return GridPreferencePanelsValue2;
  }(GridPreferencePanelsValue || {});
  const gridRowsMetaSelector = (state) => state.rowsMeta;
  const gridRowSelectionStateSelector = (state) => state.rowSelection;
  const selectedGridRowsCountSelector = createSelector(gridRowSelectionStateSelector, (selection) => selection.length);
  const selectedGridRowsSelector = createSelectorMemoized(gridRowSelectionStateSelector, gridRowsLookupSelector, (selectedRows, rowsLookup) => new Map(selectedRows.map((id) => [id, rowsLookup[id]])));
  const selectedIdsLookupSelector = createSelectorMemoized(gridRowSelectionStateSelector, (selection) => selection.reduce((lookup, rowId) => {
    lookup[rowId] = rowId;
    return lookup;
  }, {}));
  const sortModelDisableMultiColumnsSortingWarning = buildWarning(["MUI: The `sortModel` can only contain a single item when the `disableMultipleColumnsSorting` prop is set to `true`.", "If you are using the community version of the `DataGrid`, this prop is always `true`."], "error");
  const sanitizeSortModel = (model, disableMultipleColumnsSorting) => {
    if (disableMultipleColumnsSorting && model.length > 1) {
      sortModelDisableMultiColumnsSortingWarning();
      return [model[0]];
    }
    return model;
  };
  const mergeStateWithSortModel = (sortModel, disableMultipleColumnsSorting) => (state) => _extends({}, state, {
    sorting: _extends({}, state.sorting, {
      sortModel: sanitizeSortModel(sortModel, disableMultipleColumnsSorting)
    })
  });
  const isDesc = (direction) => direction === "desc";
  const parseSortItem = (sortItem, apiRef2) => {
    const column2 = apiRef2.current.getColumn(sortItem.field);
    if (!column2) {
      return null;
    }
    const comparator = isDesc(sortItem.sort) ? (...args) => -1 * column2.sortComparator(...args) : column2.sortComparator;
    const getSortCellParams = (id) => ({
      id,
      field: column2.field,
      rowNode: apiRef2.current.getRowNode(id),
      value: apiRef2.current.getCellValue(id, column2.field),
      api: apiRef2.current
    });
    return {
      getSortCellParams,
      comparator
    };
  };
  const compareRows = (parsedSortItems, row1, row2) => {
    return parsedSortItems.reduce((res, item, index) => {
      if (res !== 0) {
        return res;
      }
      const sortCellParams1 = row1.params[index];
      const sortCellParams2 = row2.params[index];
      res = item.comparator(sortCellParams1.value, sortCellParams2.value, sortCellParams1, sortCellParams2);
      return res;
    }, 0);
  };
  const buildAggregatedSortingApplier = (sortModel, apiRef2) => {
    const comparatorList = sortModel.map((item) => parseSortItem(item, apiRef2)).filter((comparator) => !!comparator);
    if (comparatorList.length === 0) {
      return null;
    }
    return (rowList) => rowList.map((node2) => ({
      node: node2,
      params: comparatorList.map((el) => el.getSortCellParams(node2.id))
    })).sort((a, b2) => compareRows(comparatorList, a, b2)).map((row) => row.node.id);
  };
  const getNextGridSortDirection = (sortingOrder, current) => {
    const currentIdx = sortingOrder.indexOf(current);
    if (!current || currentIdx === -1 || currentIdx + 1 === sortingOrder.length) {
      return sortingOrder[0];
    }
    return sortingOrder[currentIdx + 1];
  };
  const gridNillComparator = (v1, v2) => {
    if (v1 == null && v2 != null) {
      return -1;
    }
    if (v2 == null && v1 != null) {
      return 1;
    }
    if (v1 == null && v2 == null) {
      return 0;
    }
    return null;
  };
  const collator$2 = new Intl.Collator();
  const gridStringOrNumberComparator = (value1, value2) => {
    const nillResult = gridNillComparator(value1, value2);
    if (nillResult !== null) {
      return nillResult;
    }
    if (typeof value1 === "string") {
      return collator$2.compare(value1.toString(), value2.toString());
    }
    return value1 - value2;
  };
  const gridNumberComparator = (value1, value2) => {
    const nillResult = gridNillComparator(value1, value2);
    if (nillResult !== null) {
      return nillResult;
    }
    return Number(value1) - Number(value2);
  };
  const gridDateComparator = (value1, value2) => {
    const nillResult = gridNillComparator(value1, value2);
    if (nillResult !== null) {
      return nillResult;
    }
    if (value1 > value2) {
      return 1;
    }
    if (value1 < value2) {
      return -1;
    }
    return 0;
  };
  const unstable_gridHeaderFilteringStateSelector = (state) => state.headerFiltering;
  const unstable_gridHeaderFilteringEditFieldSelector = createSelector(unstable_gridHeaderFilteringStateSelector, (headerFilteringState) => headerFilteringState.editing);
  const unstable_gridHeaderFilteringMenuSelector = createSelector(unstable_gridHeaderFilteringStateSelector, (headerFilteringState) => headerFilteringState.menuOpen);
  const useUtilityClasses$L = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      icon: ["filterIcon"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridColumnHeaderFilterIconButton(props) {
    var _rootProps$slotProps, _rootProps$slotProps2;
    const {
      counter,
      field,
      onClick
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = _extends({}, props, {
      classes: rootProps.classes
    });
    const classes = useUtilityClasses$L(ownerState);
    const preferencePanel = useGridSelector(apiRef2, gridPreferencePanelStateSelector);
    const labelId = useId();
    const panelId = useId();
    const toggleFilter = React__namespace.useCallback((event) => {
      event.preventDefault();
      event.stopPropagation();
      const {
        open: open2,
        openedPanelValue
      } = gridPreferencePanelStateSelector(apiRef2.current.state);
      if (open2 && openedPanelValue === GridPreferencePanelsValue.filters) {
        apiRef2.current.hideFilterPanel();
      } else {
        apiRef2.current.showFilterPanel(void 0, panelId, labelId);
      }
      if (onClick) {
        onClick(apiRef2.current.getColumnHeaderParams(field), event);
      }
    }, [apiRef2, field, onClick, panelId, labelId]);
    if (!counter) {
      return null;
    }
    const open = preferencePanel.open && preferencePanel.labelId === labelId;
    const iconButton = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends({
      id: labelId,
      onClick: toggleFilter,
      color: "default",
      "aria-label": apiRef2.current.getLocaleText("columnHeaderFiltersLabel"),
      size: "small",
      tabIndex: -1,
      "aria-haspopup": "menu",
      "aria-expanded": open,
      "aria-controls": open ? panelId : void 0
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnFilteredIcon, {
        className: classes.icon,
        fontSize: "small"
      })
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends({
      title: apiRef2.current.getLocaleText("columnHeaderFiltersTooltipActive")(counter),
      enterDelay: 1e3
    }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseTooltip, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridIconButtonContainer, {
        children: [counter > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, {
          badgeContent: counter,
          color: "default",
          children: iconButton
        }), counter === 1 && iconButton]
      })
    }));
  }
  const _excluded$16 = ["field", "id", "value", "formattedValue", "row", "rowNode", "colDef", "isEditable", "cellMode", "hasFocus", "tabIndex", "api"];
  const useUtilityClasses$K = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["checkboxInput"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridCellCheckboxForwardRef = /* @__PURE__ */ React__namespace.forwardRef(function GridCellCheckboxRenderer2(props, ref) {
    var _rootProps$slotProps;
    const {
      field,
      id,
      value: isChecked,
      rowNode,
      hasFocus,
      tabIndex
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$16);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = {
      classes: rootProps.classes
    };
    const classes = useUtilityClasses$K(ownerState);
    const checkboxElement = React__namespace.useRef(null);
    const rippleRef = React__namespace.useRef(null);
    const handleRef = useForkRef(checkboxElement, ref);
    const element = apiRef2.current.getCellElement(id, field);
    const handleChange = (event) => {
      const params = {
        value: event.target.checked,
        id
      };
      apiRef2.current.publishEvent("rowSelectionCheckboxChange", params, event);
    };
    React__namespace.useLayoutEffect(() => {
      if (tabIndex === 0 && element) {
        element.tabIndex = -1;
      }
    }, [element, tabIndex]);
    React__namespace.useEffect(() => {
      if (hasFocus) {
        var _checkboxElement$curr;
        const input = (_checkboxElement$curr = checkboxElement.current) == null ? void 0 : _checkboxElement$curr.querySelector("input");
        input == null ? void 0 : input.focus({
          preventScroll: true
        });
      } else if (rippleRef.current) {
        rippleRef.current.stop({});
      }
    }, [hasFocus]);
    const handleKeyDown2 = React__namespace.useCallback((event) => {
      if (isSpaceKey(event.key)) {
        event.stopPropagation();
      }
    }, []);
    if (rowNode.type === "footer" || rowNode.type === "pinnedRow") {
      return null;
    }
    const isSelectable = apiRef2.current.isRowSelectable(id);
    const label = apiRef2.current.getLocaleText(isChecked ? "checkboxSelectionUnselectRow" : "checkboxSelectionSelectRow");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends({
      ref: handleRef,
      tabIndex,
      checked: isChecked,
      onChange: handleChange,
      className: classes.root,
      inputProps: {
        "aria-label": label
      },
      onKeyDown: handleKeyDown2,
      disabled: !isSelectable,
      touchRippleRef: rippleRef
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseCheckbox, other));
  });
  const GridCellCheckboxRenderer = GridCellCheckboxForwardRef;
  const _excluded$15 = ["field", "colDef"];
  const useUtilityClasses$J = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["checkboxInput"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridHeaderCheckbox = /* @__PURE__ */ React__namespace.forwardRef(function GridHeaderCheckbox2(props, ref) {
    var _rootProps$slotProps;
    const other = _objectWithoutPropertiesLoose(props, _excluded$15);
    const [, forceUpdate] = React__namespace.useState(false);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = {
      classes: rootProps.classes
    };
    const classes = useUtilityClasses$J(ownerState);
    const tabIndexState = useGridSelector(apiRef2, gridTabIndexColumnHeaderSelector);
    const selection = useGridSelector(apiRef2, gridRowSelectionStateSelector);
    const visibleRowIds = useGridSelector(apiRef2, gridExpandedSortedRowIdsSelector);
    const paginatedVisibleRowIds = useGridSelector(apiRef2, gridPaginatedVisibleSortedGridRowIdsSelector);
    const filteredSelection = React__namespace.useMemo(() => {
      if (typeof rootProps.isRowSelectable !== "function") {
        return selection;
      }
      return selection.filter((id) => {
        if (!apiRef2.current.getRow(id)) {
          return false;
        }
        return rootProps.isRowSelectable(apiRef2.current.getRowParams(id));
      });
    }, [apiRef2, rootProps.isRowSelectable, selection]);
    const selectionCandidates = React__namespace.useMemo(() => {
      const rowIds = !rootProps.pagination || !rootProps.checkboxSelectionVisibleOnly ? visibleRowIds : paginatedVisibleRowIds;
      return rowIds.reduce((acc, id) => {
        acc[id] = true;
        return acc;
      }, {});
    }, [rootProps.pagination, rootProps.checkboxSelectionVisibleOnly, paginatedVisibleRowIds, visibleRowIds]);
    const currentSelectionSize = React__namespace.useMemo(() => filteredSelection.filter((id) => selectionCandidates[id]).length, [filteredSelection, selectionCandidates]);
    const isIndeterminate = currentSelectionSize > 0 && currentSelectionSize < Object.keys(selectionCandidates).length;
    const isChecked = currentSelectionSize > 0;
    const handleChange = (event) => {
      const params = {
        value: event.target.checked
      };
      apiRef2.current.publishEvent("headerSelectionCheckboxChange", params);
    };
    const tabIndex = tabIndexState !== null && tabIndexState.field === props.field ? 0 : -1;
    React__namespace.useLayoutEffect(() => {
      const element = apiRef2.current.getColumnHeaderElement(props.field);
      if (tabIndex === 0 && element) {
        element.tabIndex = -1;
      }
    }, [tabIndex, apiRef2, props.field]);
    const handleKeyDown2 = React__namespace.useCallback((event) => {
      if (event.key === " ") {
        apiRef2.current.publishEvent("headerSelectionCheckboxChange", {
          value: !isChecked
        });
      }
    }, [apiRef2, isChecked]);
    const handleSelectionChange = React__namespace.useCallback(() => {
      forceUpdate((p2) => !p2);
    }, []);
    React__namespace.useEffect(() => {
      return apiRef2.current.subscribeEvent("rowSelectionChange", handleSelectionChange);
    }, [apiRef2, handleSelectionChange]);
    const label = apiRef2.current.getLocaleText(isChecked ? "checkboxSelectionUnselectAllRows" : "checkboxSelectionSelectAllRows");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends({
      ref,
      indeterminate: isIndeterminate,
      checked: isChecked,
      onChange: handleChange,
      className: classes.root,
      inputProps: {
        "aria-label": label
      },
      tabIndex,
      onKeyDown: handleKeyDown2
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseCheckbox, other));
  });
  const GridArrowUpwardIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"
  }), "ArrowUpward");
  const GridArrowDownwardIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
  }), "ArrowDownward");
  const GridKeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
  }), "KeyboardArrowRight");
  const GridExpandMoreIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }), "ExpandMore");
  const GridFilterListIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"
  }), "FilterList");
  const GridFilterAltIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z"
  }), "FilterAlt");
  const GridSearchIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
  }), "Search");
  createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
  }), "Menu");
  createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
  }), "CheckCircle");
  const GridColumnIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"
  }), "ColumnIcon");
  const GridSeparatorIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11 19V5h2v14z"
  }), "Separator");
  const GridViewHeadlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"
  }), "ViewHeadline");
  const GridTableRowsIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M21,8H3V4h18V8z M21,10H3v4h18V10z M21,16H3v4h18V16z"
  }), "TableRows");
  const GridViewStreamIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M4 18h17v-6H4v6zM4 5v6h17V5H4z"
  }), "ViewStream");
  const GridTripleDotsVerticalIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
  }), "TripleDotsVertical");
  const GridCloseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), "Close");
  const GridAddIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
  }), "Add");
  const GridRemoveIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 13H5v-2h14v2z"
  }), "Remove");
  const GridLoadIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
  }), "Load");
  const GridDragIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
  }), "Drag");
  const GridSaveAltIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"
  }), "SaveAlt");
  const GridCheckIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
  }), "Check");
  const GridMoreVertIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
  }), "MoreVert");
  const GridVisibilityOffIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
  }), "VisibilityOff");
  const GridViewColumnIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("g", {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M14.67,5v14H9.33V5H14.67z M15.67,19H21V5h-5.33V19z M8.33,19V5H3v14H8.33z"
    })
  }), "ViewColumn");
  const GridClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), "Clear");
  createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
  }), "Delete");
  const GridDeleteForeverIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
  }), "Delete");
  const _excluded$14 = ["hideMenu", "colDef", "id", "labelledby", "className", "children", "open"];
  const StyledMenuList = styled$1(MenuList$1)(() => ({
    minWidth: 248
  }));
  const GridColumnMenuContainer = /* @__PURE__ */ React__namespace.forwardRef(function GridColumnMenuContainer2(props, ref) {
    const {
      hideMenu,
      id,
      labelledby,
      className,
      children,
      open
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$14);
    const handleListKeyDown = React__namespace.useCallback((event) => {
      if (isTabKey(event.key)) {
        event.preventDefault();
      }
      if (isHideMenuKey(event.key)) {
        hideMenu(event);
      }
    }, [hideMenu]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledMenuList, _extends({
      id,
      ref,
      className: clsx(gridClasses.menuList, className),
      "aria-labelledby": labelledby,
      onKeyDown: handleListKeyDown,
      autoFocus: open
    }, other, {
      children
    }));
  });
  const _excluded$13 = ["displayOrder"];
  const useGridColumnMenuSlots = (props) => {
    const apiRef2 = useGridPrivateApiContext();
    const {
      defaultSlots: defaultSlots2,
      defaultSlotProps,
      slots = {},
      slotProps = {},
      hideMenu,
      colDef,
      addDividers = true
    } = props;
    const processedComponents = React__namespace.useMemo(() => _extends({}, defaultSlots2, slots), [defaultSlots2, slots]);
    const processedSlotProps = React__namespace.useMemo(() => {
      if (!slotProps || Object.keys(slotProps).length === 0) {
        return defaultSlotProps;
      }
      const mergedProps = _extends({}, slotProps);
      Object.entries(defaultSlotProps).forEach(([key, currentSlotProps]) => {
        mergedProps[key] = _extends({}, currentSlotProps, slotProps[key] || {});
      });
      return mergedProps;
    }, [defaultSlotProps, slotProps]);
    const defaultItems = apiRef2.current.unstable_applyPipeProcessors("columnMenu", [], props.colDef);
    const userItems = React__namespace.useMemo(() => {
      const defaultComponentKeys = Object.keys(defaultSlots2);
      return Object.keys(slots).filter((key) => !defaultComponentKeys.includes(key));
    }, [slots, defaultSlots2]);
    return React__namespace.useMemo(() => {
      const uniqueItems = Array.from(/* @__PURE__ */ new Set([...defaultItems, ...userItems]));
      const cleansedItems = uniqueItems.filter((key) => processedComponents[key] != null);
      const sorted = cleansedItems.sort((a, b2) => {
        const leftItemProps = processedSlotProps[a];
        const rightItemProps = processedSlotProps[b2];
        const leftDisplayOrder = Number.isFinite(leftItemProps == null ? void 0 : leftItemProps.displayOrder) ? leftItemProps.displayOrder : 100;
        const rightDisplayOrder = Number.isFinite(rightItemProps == null ? void 0 : rightItemProps.displayOrder) ? rightItemProps.displayOrder : 100;
        return leftDisplayOrder - rightDisplayOrder;
      });
      return sorted.reduce((acc, key, index) => {
        let itemProps = {
          colDef,
          onClick: hideMenu
        };
        const processedComponentProps = processedSlotProps[key];
        if (processedComponentProps) {
          const customProps = _objectWithoutPropertiesLoose(processedComponentProps, _excluded$13);
          itemProps = _extends({}, itemProps, customProps);
        }
        return addDividers && index !== sorted.length - 1 ? [...acc, [processedComponents[key], itemProps], [Divider$1, {}]] : [...acc, [processedComponents[key], itemProps]];
      }, []);
    }, [addDividers, colDef, defaultItems, hideMenu, processedComponents, processedSlotProps, userItems]);
  };
  function GridColumnMenuHideItem(props) {
    const {
      colDef,
      onClick
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef2);
    const columnsWithMenu = visibleColumns.filter((col) => col.disableColumnMenu !== true);
    const disabled = columnsWithMenu.length === 1;
    const toggleColumn = React__namespace.useCallback((event) => {
      if (disabled) {
        return;
      }
      apiRef2.current.setColumnVisibility(colDef.field, false);
      onClick(event);
    }, [apiRef2, colDef.field, onClick, disabled]);
    if (rootProps.disableColumnSelector) {
      return null;
    }
    if (colDef.hideable === false) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
      onClick: toggleColumn,
      disabled,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuHideIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
        children: apiRef2.current.getLocaleText("columnMenuHideColumn")
      })]
    });
  }
  function GridColumnMenuManageItem(props) {
    const {
      onClick
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const showColumns = React__namespace.useCallback((event) => {
      onClick(event);
      apiRef2.current.showPreferences(GridPreferencePanelsValue.columns);
    }, [apiRef2, onClick]);
    if (rootProps.disableColumnSelector) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
      onClick: showColumns,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuManageColumnsIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
        children: apiRef2.current.getLocaleText("columnMenuManageColumns")
      })]
    });
  }
  function GridColumnMenuColumnsItem(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuHideItem, _extends({}, props)), /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuManageItem, _extends({}, props))]
    });
  }
  function GridColumnMenuFilterItem(props) {
    const {
      colDef,
      onClick
    } = props;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const showFilter = React__namespace.useCallback((event) => {
      onClick(event);
      apiRef2.current.showFilterPanel(colDef.field);
    }, [apiRef2, colDef.field, onClick]);
    if (rootProps.disableColumnFilter || !colDef.filterable) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
      onClick: showFilter,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuFilterIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
        children: apiRef2.current.getLocaleText("columnMenuFilter")
      })]
    });
  }
  function GridColumnMenuSortItem(props) {
    var _colDef$sortingOrder;
    const {
      colDef,
      onClick
    } = props;
    const apiRef2 = useGridApiContext();
    const sortModel = useGridSelector(apiRef2, gridSortModelSelector);
    const rootProps = useGridRootProps();
    const sortDirection = React__namespace.useMemo(() => {
      if (!colDef) {
        return null;
      }
      const sortItem = sortModel.find((item) => item.field === colDef.field);
      return sortItem == null ? void 0 : sortItem.sort;
    }, [colDef, sortModel]);
    const sortingOrder = (_colDef$sortingOrder = colDef.sortingOrder) != null ? _colDef$sortingOrder : rootProps.sortingOrder;
    const onSortMenuItemClick = React__namespace.useCallback((event) => {
      onClick(event);
      const direction = event.currentTarget.getAttribute("data-value") || null;
      apiRef2.current.sortColumn(colDef, direction === sortDirection ? null : direction);
    }, [apiRef2, colDef, onClick, sortDirection]);
    if (!colDef || !colDef.sortable || !sortingOrder.some((item) => !!item)) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [sortingOrder.includes("asc") && sortDirection !== "asc" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
        onClick: onSortMenuItemClick,
        "data-value": "asc",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuSortAscendingIcon, {
            fontSize: "small"
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
          children: apiRef2.current.getLocaleText("columnMenuSortAsc")
        })]
      }) : null, sortingOrder.includes("desc") && sortDirection !== "desc" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
        onClick: onSortMenuItemClick,
        "data-value": "desc",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuSortDescendingIcon, {
            fontSize: "small"
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
          children: apiRef2.current.getLocaleText("columnMenuSortDesc")
        })]
      }) : null, sortingOrder.includes(null) && sortDirection != null ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
        onClick: onSortMenuItemClick,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
          children: apiRef2.current.getLocaleText("columnMenuUnsort")
        })]
      }) : null]
    });
  }
  const _excluded$12 = ["defaultSlots", "defaultSlotProps", "slots", "slotProps"];
  const GRID_COLUMN_MENU_SLOTS = {
    columnMenuSortItem: GridColumnMenuSortItem,
    columnMenuFilterItem: GridColumnMenuFilterItem,
    columnMenuColumnsItem: GridColumnMenuColumnsItem
  };
  const GRID_COLUMN_MENU_SLOT_PROPS = {
    columnMenuSortItem: {
      displayOrder: 10
    },
    columnMenuFilterItem: {
      displayOrder: 20
    },
    columnMenuColumnsItem: {
      displayOrder: 30
    }
  };
  const GridGenericColumnMenu = /* @__PURE__ */ React__namespace.forwardRef(function GridGenericColumnMenu2(props, ref) {
    const {
      defaultSlots: defaultSlots2,
      defaultSlotProps,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$12);
    const orderedSlots = useGridColumnMenuSlots(_extends({}, other, {
      defaultSlots: defaultSlots2,
      defaultSlotProps,
      slots,
      slotProps
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuContainer, _extends({
      ref
    }, other, {
      children: orderedSlots.map(([Component, otherProps], index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Component, _extends({}, otherProps), index))
    }));
  });
  const GridColumnMenu = /* @__PURE__ */ React__namespace.forwardRef(function GridColumnMenu2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnMenu, _extends({}, props, {
      ref,
      defaultSlots: GRID_COLUMN_MENU_SLOTS,
      defaultSlotProps: GRID_COLUMN_MENU_SLOT_PROPS
    }));
  });
  function getIconButtonUtilityClass(slot) {
    return generateUtilityClass("MuiIconButton", slot);
  }
  const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
  const iconButtonClasses$1 = iconButtonClasses;
  const _excluded$11 = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
  const useUtilityClasses$I = (ownerState) => {
    const {
      classes,
      disabled,
      color: color2,
      edge,
      size
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
    };
    return composeClasses(slots, getIconButtonUtilityClass, classes);
  };
  const IconButtonRoot = styled$1(ButtonBase$1, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: theme.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    overflow: "visible",
    // Explicitly set the default value to solve a bug on IE11.
    color: (theme.vars || theme).palette.action.active,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shortest
    })
  }, !ownerState.disableRipple && {
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }
  }, ownerState.edge === "start" && {
    marginLeft: ownerState.size === "small" ? -3 : -12
  }, ownerState.edge === "end" && {
    marginRight: ownerState.size === "small" ? -3 : -12
  }), ({
    theme,
    ownerState
  }) => {
    var _palette;
    const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
    return _extends({}, ownerState.color === "inherit" && {
      color: "inherit"
    }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends({
      color: palette == null ? void 0 : palette.main
    }, !ownerState.disableRipple && {
      "&:hover": _extends({}, palette && {
        backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme.palette.action.hoverOpacity)
      }, {
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      })
    }), ownerState.size === "small" && {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }, ownerState.size === "large" && {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }, {
      [`&.${iconButtonClasses$1.disabled}`]: {
        backgroundColor: "transparent",
        color: (theme.vars || theme).palette.action.disabled
      }
    });
  });
  const IconButton = /* @__PURE__ */ React__namespace.forwardRef(function IconButton2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiIconButton"
    });
    const {
      edge = false,
      children,
      className,
      color: color2 = "default",
      disabled = false,
      disableFocusRipple = false,
      size = "medium"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$11);
    const ownerState = _extends({}, props, {
      edge,
      color: color2,
      disabled,
      disableFocusRipple,
      size
    });
    const classes = useUtilityClasses$I(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends({
      className: clsx(classes.root, className),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled,
      ref,
      ownerState
    }, other, {
      children
    }));
  });
  const MUIIconButton = IconButton;
  function getSwitchBaseUtilityClass(slot) {
    return generateUtilityClass("PrivateSwitchBase", slot);
  }
  generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
  const _excluded$10 = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
  const useUtilityClasses$H = (ownerState) => {
    const {
      classes,
      checked,
      disabled,
      edge
    } = ownerState;
    const slots = {
      root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize(edge)}`],
      input: ["input"]
    };
    return composeClasses(slots, getSwitchBaseUtilityClass, classes);
  };
  const SwitchBaseRoot = styled$1(ButtonBase$1)(({
    ownerState
  }) => _extends({
    padding: 9,
    borderRadius: "50%"
  }, ownerState.edge === "start" && {
    marginLeft: ownerState.size === "small" ? -3 : -12
  }, ownerState.edge === "end" && {
    marginRight: ownerState.size === "small" ? -3 : -12
  }));
  const SwitchBaseInput = styled$1("input")({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  });
  const SwitchBase = /* @__PURE__ */ React__namespace.forwardRef(function SwitchBase2(props, ref) {
    const {
      autoFocus,
      checked: checkedProp,
      checkedIcon,
      className,
      defaultChecked,
      disabled: disabledProp,
      disableFocusRipple = false,
      edge = false,
      icon,
      id,
      inputProps,
      inputRef,
      name,
      onBlur,
      onChange,
      onFocus,
      readOnly,
      required = false,
      tabIndex,
      type,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$10);
    const [checked, setCheckedState] = useControlled({
      controlled: checkedProp,
      default: Boolean(defaultChecked),
      name: "SwitchBase",
      state: "checked"
    });
    const muiFormControl = useFormControl();
    const handleFocus = (event) => {
      if (onFocus) {
        onFocus(event);
      }
      if (muiFormControl && muiFormControl.onFocus) {
        muiFormControl.onFocus(event);
      }
    };
    const handleBlur = (event) => {
      if (onBlur) {
        onBlur(event);
      }
      if (muiFormControl && muiFormControl.onBlur) {
        muiFormControl.onBlur(event);
      }
    };
    const handleInputChange = (event) => {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      const newChecked = event.target.checked;
      setCheckedState(newChecked);
      if (onChange) {
        onChange(event, newChecked);
      }
    };
    let disabled = disabledProp;
    if (muiFormControl) {
      if (typeof disabled === "undefined") {
        disabled = muiFormControl.disabled;
      }
    }
    const hasLabelFor = type === "checkbox" || type === "radio";
    const ownerState = _extends({}, props, {
      checked,
      disabled,
      disableFocusRipple,
      edge
    });
    const classes = useUtilityClasses$H(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends({
      component: "span",
      className: clsx(classes.root, className),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled,
      tabIndex: null,
      role: void 0,
      onFocus: handleFocus,
      onBlur: handleBlur,
      ownerState,
      ref
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, _extends({
        autoFocus,
        checked: checkedProp,
        defaultChecked,
        className: classes.input,
        disabled,
        id: hasLabelFor ? id : void 0,
        name,
        onChange: handleInputChange,
        readOnly,
        ref: inputRef,
        required,
        ownerState,
        tabIndex,
        type
      }, type === "checkbox" && value === void 0 ? {} : {
        value
      }, inputProps)), checked ? checkedIcon : icon]
    }));
  });
  const SwitchBase$1 = SwitchBase;
  function getSwitchUtilityClass(slot) {
    return generateUtilityClass("MuiSwitch", slot);
  }
  const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
  const switchClasses$1 = switchClasses;
  const _excluded$$ = ["className", "color", "edge", "size", "sx"];
  const useUtilityClasses$G = (ownerState) => {
    const {
      classes,
      edge,
      size,
      color: color2,
      checked,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
      switchBase: ["switchBase", `color${capitalize(color2)}`, checked && "checked", disabled && "disabled"],
      thumb: ["thumb"],
      track: ["track"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const SwitchRoot = styled$1("span", {
    name: "MuiSwitch",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
    }
  })(({
    ownerState
  }) => _extends({
    display: "inline-flex",
    width: 34 + 12 * 2,
    height: 14 + 12 * 2,
    overflow: "hidden",
    padding: 12,
    boxSizing: "border-box",
    position: "relative",
    flexShrink: 0,
    zIndex: 0,
    // Reset the stacking context.
    verticalAlign: "middle",
    // For correct alignment with the text.
    "@media print": {
      colorAdjust: "exact"
    }
  }, ownerState.edge === "start" && {
    marginLeft: -8
  }, ownerState.edge === "end" && {
    marginRight: -8
  }, ownerState.size === "small" && {
    width: 40,
    height: 24,
    padding: 7,
    [`& .${switchClasses$1.thumb}`]: {
      width: 16,
      height: 16
    },
    [`& .${switchClasses$1.switchBase}`]: {
      padding: 4,
      [`&.${switchClasses$1.checked}`]: {
        transform: "translateX(16px)"
      }
    }
  }));
  const SwitchSwitchBase = styled$1(SwitchBase$1, {
    name: "MuiSwitch",
    slot: "SwitchBase",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.switchBase, {
        [`& .${switchClasses$1.input}`]: styles2.input
      }, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
    }
  })(({
    theme
  }) => ({
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: 1,
    // Render above the focus ripple.
    color: theme.vars ? theme.vars.palette.Switch.defaultColor : `${theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[300]}`,
    transition: theme.transitions.create(["left", "transform"], {
      duration: theme.transitions.duration.shortest
    }),
    [`&.${switchClasses$1.checked}`]: {
      transform: "translateX(20px)"
    },
    [`&.${switchClasses$1.disabled}`]: {
      color: theme.vars ? theme.vars.palette.Switch.defaultDisabledColor : `${theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[600]}`
    },
    [`&.${switchClasses$1.checked} + .${switchClasses$1.track}`]: {
      opacity: 0.5
    },
    [`&.${switchClasses$1.disabled} + .${switchClasses$1.track}`]: {
      opacity: theme.vars ? theme.vars.opacity.switchTrackDisabled : `${theme.palette.mode === "light" ? 0.12 : 0.2}`
    },
    [`& .${switchClasses$1.input}`]: {
      left: "-100%",
      width: "300%"
    }
  }), ({
    theme,
    ownerState
  }) => _extends({
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }
  }, ownerState.color !== "default" && {
    [`&.${switchClasses$1.checked}`]: {
      color: (theme.vars || theme).palette[ownerState.color].main,
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${switchClasses$1.disabled}`]: {
        color: theme.vars ? theme.vars.palette.Switch[`${ownerState.color}DisabledColor`] : `${theme.palette.mode === "light" ? lighten(theme.palette[ownerState.color].main, 0.62) : darken(theme.palette[ownerState.color].main, 0.55)}`
      }
    },
    [`&.${switchClasses$1.checked} + .${switchClasses$1.track}`]: {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main
    }
  }));
  const SwitchTrack = styled$1("span", {
    name: "MuiSwitch",
    slot: "Track",
    overridesResolver: (props, styles2) => styles2.track
  })(({
    theme
  }) => ({
    height: "100%",
    width: "100%",
    borderRadius: 14 / 2,
    zIndex: -1,
    transition: theme.transitions.create(["opacity", "background-color"], {
      duration: theme.transitions.duration.shortest
    }),
    backgroundColor: theme.vars ? theme.vars.palette.common.onBackground : `${theme.palette.mode === "light" ? theme.palette.common.black : theme.palette.common.white}`,
    opacity: theme.vars ? theme.vars.opacity.switchTrack : `${theme.palette.mode === "light" ? 0.38 : 0.3}`
  }));
  const SwitchThumb = styled$1("span", {
    name: "MuiSwitch",
    slot: "Thumb",
    overridesResolver: (props, styles2) => styles2.thumb
  })(({
    theme
  }) => ({
    boxShadow: (theme.vars || theme).shadows[1],
    backgroundColor: "currentColor",
    width: 20,
    height: 20,
    borderRadius: "50%"
  }));
  const Switch = /* @__PURE__ */ React__namespace.forwardRef(function Switch2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiSwitch"
    });
    const {
      className,
      color: color2 = "primary",
      edge = false,
      size = "medium",
      sx
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$$);
    const ownerState = _extends({}, props, {
      color: color2,
      edge,
      size
    });
    const classes = useUtilityClasses$G(ownerState);
    const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
      className: classes.thumb,
      ownerState
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, {
      className: clsx(classes.root, className),
      sx,
      ownerState,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, _extends({
        type: "checkbox",
        icon,
        checkedIcon: icon,
        ref,
        ownerState
      }, other, {
        classes: _extends({}, classes, {
          root: classes.switchBase
        })
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchTrack, {
        className: classes.track,
        ownerState
      })]
    });
  });
  const MUISwitch = Switch;
  function getFormControlUtilityClasses(slot) {
    return generateUtilityClass("MuiFormControl", slot);
  }
  generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
  const _excluded$_ = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
  const useUtilityClasses$F = (ownerState) => {
    const {
      classes,
      margin: margin2,
      fullWidth
    } = ownerState;
    const slots = {
      root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
    };
    return composeClasses(slots, getFormControlUtilityClasses, classes);
  };
  const FormControlRoot = styled$1("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({
      ownerState
    }, styles2) => {
      return _extends({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
    }
  })(({
    ownerState
  }) => _extends({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top"
  }, ownerState.margin === "normal" && {
    marginTop: 16,
    marginBottom: 8
  }, ownerState.margin === "dense" && {
    marginTop: 8,
    marginBottom: 4
  }, ownerState.fullWidth && {
    width: "100%"
  }));
  const FormControl = /* @__PURE__ */ React__namespace.forwardRef(function FormControl2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiFormControl"
    });
    const {
      children,
      className,
      color: color2 = "primary",
      component = "div",
      disabled = false,
      error = false,
      focused: visuallyFocused,
      fullWidth = false,
      hiddenLabel = false,
      margin: margin2 = "none",
      required = false,
      size = "medium",
      variant = "outlined"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$_);
    const ownerState = _extends({}, props, {
      color: color2,
      component,
      disabled,
      error,
      fullWidth,
      hiddenLabel,
      margin: margin2,
      required,
      size,
      variant
    });
    const classes = useUtilityClasses$F(ownerState);
    const [adornedStart, setAdornedStart] = React__namespace.useState(() => {
      let initialAdornedStart = false;
      if (children) {
        React__namespace.Children.forEach(children, (child) => {
          if (!isMuiElement(child, ["Input", "Select"])) {
            return;
          }
          const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
          if (input && isAdornedStart(input.props)) {
            initialAdornedStart = true;
          }
        });
      }
      return initialAdornedStart;
    });
    const [filled, setFilled] = React__namespace.useState(() => {
      let initialFilled = false;
      if (children) {
        React__namespace.Children.forEach(children, (child) => {
          if (!isMuiElement(child, ["Input", "Select"])) {
            return;
          }
          if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
            initialFilled = true;
          }
        });
      }
      return initialFilled;
    });
    const [focusedState, setFocused] = React__namespace.useState(false);
    if (disabled && focusedState) {
      setFocused(false);
    }
    const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
    let registerEffect;
    const childContext = React__namespace.useMemo(() => {
      return {
        adornedStart,
        setAdornedStart,
        color: color2,
        disabled,
        error,
        filled,
        focused,
        fullWidth,
        hiddenLabel,
        size,
        onBlur: () => {
          setFocused(false);
        },
        onEmpty: () => {
          setFilled(false);
        },
        onFilled: () => {
          setFilled(true);
        },
        onFocus: () => {
          setFocused(true);
        },
        registerEffect,
        required,
        variant
      };
    }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children
      }))
    });
  });
  const MUIFormControl = FormControl;
  const Stack = createStack({
    createStyledComponent: styled$1("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    }),
    useThemeProps: (inProps) => useThemeProps({
      props: inProps,
      name: "MuiStack"
    })
  });
  const Stack$1 = Stack;
  function getFormControlLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiFormControlLabel", slot);
  }
  const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]);
  const formControlLabelClasses$1 = formControlLabelClasses;
  const _excluded$Z = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "required", "slotProps", "value"];
  const useUtilityClasses$E = (ownerState) => {
    const {
      classes,
      disabled,
      labelPlacement,
      error,
      required
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", `labelPlacement${capitalize(labelPlacement)}`, error && "error", required && "required"],
      label: ["label", disabled && "disabled"],
      asterisk: ["asterisk", error && "error"]
    };
    return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
  };
  const FormControlLabelRoot = styled$1("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${formControlLabelClasses$1.label}`]: styles2.label
      }, styles2.root, styles2[`labelPlacement${capitalize(ownerState.labelPlacement)}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    // For correct alignment with the text.
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    // used for row presentation of radio/checkbox
    [`&.${formControlLabelClasses$1.disabled}`]: {
      cursor: "default"
    }
  }, ownerState.labelPlacement === "start" && {
    flexDirection: "row-reverse",
    marginLeft: 16,
    // used for row presentation of radio/checkbox
    marginRight: -11
  }, ownerState.labelPlacement === "top" && {
    flexDirection: "column-reverse",
    marginLeft: 16
  }, ownerState.labelPlacement === "bottom" && {
    flexDirection: "column",
    marginLeft: 16
  }, {
    [`& .${formControlLabelClasses$1.label}`]: {
      [`&.${formControlLabelClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      }
    }
  }));
  const AsteriskComponent$1 = styled$1("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk",
    overridesResolver: (props, styles2) => styles2.asterisk
  })(({
    theme
  }) => ({
    [`&.${formControlLabelClasses$1.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }));
  const FormControlLabel = /* @__PURE__ */ React__namespace.forwardRef(function FormControlLabel2(inProps, ref) {
    var _ref, _slotProps$typography;
    const props = useThemeProps({
      props: inProps,
      name: "MuiFormControlLabel"
    });
    const {
      className,
      componentsProps = {},
      control,
      disabled: disabledProp,
      disableTypography,
      label: labelProp,
      labelPlacement = "end",
      required: requiredProp,
      slotProps = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Z);
    const muiFormControl = useFormControl();
    const disabled = (_ref = disabledProp != null ? disabledProp : control.props.disabled) != null ? _ref : muiFormControl == null ? void 0 : muiFormControl.disabled;
    const required = requiredProp != null ? requiredProp : control.props.required;
    const controlProps = {
      disabled,
      required
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
      if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
        controlProps[key] = props[key];
      }
    });
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["error"]
    });
    const ownerState = _extends({}, props, {
      disabled,
      labelPlacement,
      required,
      error: fcs.error
    });
    const classes = useUtilityClasses$E(ownerState);
    const typographySlotProps = (_slotProps$typography = slotProps.typography) != null ? _slotProps$typography : componentsProps.typography;
    let label = labelProp;
    if (label != null && label.type !== Typography$1 && !disableTypography) {
      label = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, _extends({
        component: "span"
      }, typographySlotProps, {
        className: clsx(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
        children: label
      }));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControlLabelRoot, _extends({
      className: clsx(classes.root, className),
      ownerState,
      ref
    }, other, {
      children: [/* @__PURE__ */ React__namespace.cloneElement(control, controlProps), required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, {
        direction: "row",
        alignItems: "center",
        children: [label, /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
          ownerState,
          "aria-hidden": true,
          className: classes.asterisk,
          children: [" ", "*"]
        })]
      }) : label]
    }));
  });
  const FormControlLabel$1 = FormControlLabel;
  const _excluded$Y = ["className"];
  const useUtilityClasses$D = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["panelContent"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridPanelContentRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "PanelContent",
    overridesResolver: (props, styles2) => styles2.panelContent
  })({
    display: "flex",
    flexDirection: "column",
    overflow: "auto",
    flex: "1 1",
    maxHeight: 400
  });
  function GridPanelContent(props) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Y);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$D(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContentRoot, _extends({
      className: clsx(className, classes.root),
      ownerState: rootProps
    }, other));
  }
  const _excluded$X = ["className"];
  const useUtilityClasses$C = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["panelFooter"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridPanelFooterRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "PanelFooter",
    overridesResolver: (props, styles2) => styles2.panelFooter
  })(({
    theme
  }) => ({
    padding: theme.spacing(0.5),
    display: "flex",
    justifyContent: "space-between"
  }));
  function GridPanelFooter(props) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$X);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$C(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelFooterRoot, _extends({
      className: clsx(className, classes.root),
      ownerState: rootProps
    }, other));
  }
  const _excluded$W = ["className"];
  const useUtilityClasses$B = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["panelHeader"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridPanelHeaderRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "PanelHeader",
    overridesResolver: (props, styles2) => styles2.panelHeader
  })(({
    theme
  }) => ({
    padding: theme.spacing(1)
  }));
  function GridPanelHeader(props) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$W);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$B(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelHeaderRoot, _extends({
      className: clsx(className, classes.root),
      ownerState: rootProps
    }, other));
  }
  const _excluded$V = ["className", "slotProps"];
  const useUtilityClasses$A = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["panelWrapper"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridPanelWrapperRoot = styled$1("div", {
    name: "MuiDataGrid",
    slot: "PanelWrapper",
    overridesResolver: (props, styles2) => styles2.panelWrapper
  })({
    display: "flex",
    flexDirection: "column",
    flex: 1,
    "&:focus": {
      outline: 0
    }
  });
  const isEnabled = () => true;
  const GridPanelWrapper = /* @__PURE__ */ React__namespace.forwardRef(function GridPanelWrapper2(props, ref) {
    const {
      className,
      slotProps = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$V);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$A(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, _extends({
      open: true,
      disableEnforceFocus: true,
      isEnabled
    }, slotProps.TrapFocus, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelWrapperRoot, _extends({
        ref,
        tabIndex: -1,
        className: clsx(className, classes.root),
        ownerState: rootProps
      }, other))
    }));
  });
  const GRID_EXPERIMENTAL_ENABLED = false;
  const _excluded$U = ["sort", "searchPredicate", "autoFocusSearchField", "disableHideAllButton", "disableShowAllButton", "getTogglableColumns"];
  const useUtilityClasses$z = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["columnsPanel"],
      columnsPanelRow: ["columnsPanelRow"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridColumnsPanelRoot = styled$1("div", {
    name: "MuiDataGrid",
    slot: "ColumnsPanel",
    overridesResolver: (props, styles2) => styles2.columnsPanel
  })({
    padding: "8px 0px 8px 8px"
  });
  const GridColumnsPanelRowRoot = styled$1("div", {
    name: "MuiDataGrid",
    slot: "ColumnsPanelRow",
    overridesResolver: (props, styles2) => styles2.columnsPanelRow
  })(({
    theme
  }) => ({
    display: "flex",
    justifyContent: "space-between",
    padding: "1px 8px 1px 7px",
    [`& .${switchClasses$1.root}`]: {
      marginRight: theme.spacing(0.5)
    }
  }));
  const GridIconButtonRoot = styled$1(MUIIconButton)({
    justifyContent: "flex-end"
  });
  const collator$1 = new Intl.Collator();
  const defaultSearchPredicate = (column2, searchValue) => {
    return (column2.headerName || column2.field).toLowerCase().indexOf(searchValue) > -1;
  };
  function GridColumnsPanel(props) {
    var _rootProps$slotProps, _rootProps$slotProps3, _rootProps$slotProps4;
    const apiRef2 = useGridApiContext();
    const searchInputRef = React__namespace.useRef(null);
    const columns = useGridSelector(apiRef2, gridColumnDefinitionsSelector);
    const columnVisibilityModel = useGridSelector(apiRef2, gridColumnVisibilityModelSelector);
    const rootProps = useGridRootProps();
    const [searchValue, setSearchValue] = React__namespace.useState("");
    const classes = useUtilityClasses$z(rootProps);
    const {
      sort,
      searchPredicate = defaultSearchPredicate,
      autoFocusSearchField = true,
      disableHideAllButton = false,
      disableShowAllButton = false,
      getTogglableColumns
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$U);
    const sortedColumns = React__namespace.useMemo(() => {
      switch (sort) {
        case "asc":
          return [...columns].sort((a, b2) => collator$1.compare(a.headerName || a.field, b2.headerName || b2.field));
        case "desc":
          return [...columns].sort((a, b2) => -collator$1.compare(a.headerName || a.field, b2.headerName || b2.field));
        default:
          return columns;
      }
    }, [columns, sort]);
    const toggleColumn = (event) => {
      const {
        name: field
      } = event.target;
      apiRef2.current.setColumnVisibility(field, columnVisibilityModel[field] === false);
    };
    const toggleAllColumns = React__namespace.useCallback((isVisible) => {
      const currentModel = gridColumnVisibilityModelSelector(apiRef2);
      const newModel = _extends({}, currentModel);
      const togglableColumns = getTogglableColumns ? getTogglableColumns(columns) : null;
      columns.forEach((col) => {
        if (col.hideable && (togglableColumns == null || togglableColumns.includes(col.field))) {
          if (isVisible) {
            delete newModel[col.field];
          } else {
            newModel[col.field] = false;
          }
        }
      });
      return apiRef2.current.setColumnVisibilityModel(newModel);
    }, [apiRef2, columns, getTogglableColumns]);
    const handleSearchValueChange = React__namespace.useCallback((event) => {
      setSearchValue(event.target.value);
    }, []);
    const currentColumns = React__namespace.useMemo(() => {
      const togglableColumns = getTogglableColumns ? getTogglableColumns(sortedColumns) : null;
      const togglableSortedColumns = togglableColumns ? sortedColumns.filter(({
        field
      }) => togglableColumns.includes(field)) : sortedColumns;
      if (!searchValue) {
        return togglableSortedColumns;
      }
      return togglableSortedColumns.filter((column2) => searchPredicate(column2, searchValue.toLowerCase()));
    }, [sortedColumns, searchValue, searchPredicate, getTogglableColumns]);
    const firstSwitchRef = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
      if (autoFocusSearchField) {
        searchInputRef.current.focus();
      } else if (firstSwitchRef.current && typeof firstSwitchRef.current.focus === "function") {
        firstSwitchRef.current.focus();
      }
    }, [autoFocusSearchField]);
    let firstHideableColumnFound = false;
    const isFirstHideableColumn = (column2) => {
      if (firstHideableColumnFound === false && column2.hideable !== false) {
        firstHideableColumnFound = true;
        return true;
      }
      return false;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelWrapper, _extends({}, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelHeader, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends({
          label: apiRef2.current.getLocaleText("columnsPanelTextFieldLabel"),
          placeholder: apiRef2.current.getLocaleText("columnsPanelTextFieldPlaceholder"),
          inputRef: searchInputRef,
          value: searchValue,
          onChange: handleSearchValueChange,
          variant: "standard",
          fullWidth: true
        }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField))
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContent, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnsPanelRoot, {
          className: classes.root,
          ownerState: rootProps,
          children: currentColumns.map((column2) => {
            var _rootProps$slotProps2;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnsPanelRowRoot, {
              className: classes.columnsPanelRow,
              ownerState: rootProps,
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
                control: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSwitch, _extends({
                  disabled: column2.hideable === false,
                  checked: columnVisibilityModel[column2.field] !== false,
                  onClick: toggleColumn,
                  name: column2.field,
                  size: "small",
                  inputRef: isFirstHideableColumn(column2) ? firstSwitchRef : void 0
                }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSwitch)),
                label: column2.headerName || column2.field
              }), !rootProps.disableColumnReorder && GRID_EXPERIMENTAL_ENABLED && /* @__PURE__ */ jsxRuntimeExports.jsx(GridIconButtonRoot, {
                draggable: true,
                "aria-label": apiRef2.current.getLocaleText("columnsPanelDragIconLabel"),
                title: apiRef2.current.getLocaleText("columnsPanelDragIconLabel"),
                size: "small",
                disabled: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnReorderIcon, {})
              })]
            }, column2.field);
          })
        })
      }), disableShowAllButton && disableHideAllButton ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelFooter, {
        children: [!disableHideAllButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
          onClick: () => toggleAllColumns(false)
        }, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseButton, {
          disabled: disableHideAllButton,
          children: apiRef2.current.getLocaleText("columnsPanelHideAllButton")
        })) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), !disableShowAllButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
          onClick: () => toggleAllColumns(true)
        }, (_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseButton, {
          disabled: disableShowAllButton,
          children: apiRef2.current.getLocaleText("columnsPanelShowAllButton")
        })) : null]
      })]
    }));
  }
  const _excluded$T = ["children", "className", "classes"];
  const gridPanelClasses = generateUtilityClasses("MuiDataGrid", ["panel", "paper"]);
  const GridPanelRoot = styled$1(MUIPopper, {
    name: "MuiDataGrid",
    slot: "Panel",
    overridesResolver: (props, styles2) => styles2.panel
  })(({
    theme
  }) => ({
    zIndex: theme.zIndex.modal
  }));
  const GridPaperRoot = styled$1(PaperBase, {
    name: "MuiDataGrid",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper
  })(({
    theme
  }) => ({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    minWidth: 300,
    maxHeight: 450,
    display: "flex"
  }));
  const GridPanel = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    const {
      children,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$T);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const classes = gridPanelClasses;
    const [isPlaced, setIsPlaced] = React__namespace.useState(false);
    const handleClickAway = React__namespace.useCallback(() => {
      apiRef2.current.hidePreferences();
    }, [apiRef2]);
    const handleKeyDown2 = React__namespace.useCallback((event) => {
      if (isEscapeKey(event.key)) {
        apiRef2.current.hidePreferences();
      }
    }, [apiRef2]);
    const modifiers = React__namespace.useMemo(() => [{
      name: "flip",
      enabled: false
    }, {
      name: "isPlaced",
      enabled: true,
      phase: "main",
      fn: () => {
        setIsPlaced(true);
      },
      effect: () => () => {
        setIsPlaced(false);
      }
    }], []);
    const [anchorEl, setAnchorEl] = React__namespace.useState(null);
    React__namespace.useEffect(() => {
      var _apiRef$current$rootE;
      const columnHeadersElement = (_apiRef$current$rootE = apiRef2.current.rootElementRef) == null || (_apiRef$current$rootE = _apiRef$current$rootE.current) == null ? void 0 : _apiRef$current$rootE.querySelector(`.${gridClasses.columnHeaders}`);
      if (columnHeadersElement) {
        setAnchorEl(columnHeadersElement);
      }
    }, [apiRef2]);
    if (!anchorEl) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelRoot, _extends({
      ref,
      placement: "bottom-start",
      className: clsx(className, classes.panel),
      ownerState: rootProps,
      anchorEl,
      modifiers
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
        mouseEvent: "onMouseUp",
        onClickAway: handleClickAway,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPaperRoot, {
          className: classes.paper,
          ownerState: rootProps,
          elevation: 8,
          onKeyDown: handleKeyDown2,
          children: isPlaced && children
        })
      })
    }));
  });
  const GridPreferencesPanel = /* @__PURE__ */ React__namespace.forwardRef(function GridPreferencesPanel2(props, ref) {
    var _preferencePanelState, _rootProps$slotProps, _rootProps$slotProps2;
    const apiRef2 = useGridApiContext();
    const columns = useGridSelector(apiRef2, gridColumnDefinitionsSelector);
    const rootProps = useGridRootProps();
    const preferencePanelState = useGridSelector(apiRef2, gridPreferencePanelStateSelector);
    const panelContent = apiRef2.current.unstable_applyPipeProcessors("preferencePanel", null, (_preferencePanelState = preferencePanelState.openedPanelValue) != null ? _preferencePanelState : GridPreferencePanelsValue.filters);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.panel, _extends({
      ref,
      as: rootProps.slots.basePopper,
      open: columns.length > 0 && preferencePanelState.open,
      id: preferencePanelState.panelId,
      "aria-labelledby": preferencePanelState.labelId
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.panel, props, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.basePopper, {
      children: panelContent
    }));
  });
  const _excluded$S = ["item", "hasMultipleFilters", "deleteFilter", "applyFilterChanges", "multiFilterOperator", "showMultiFilterOperators", "disableMultiFilterOperator", "applyMultiFilterOperatorChanges", "focusElementRef", "logicOperators", "columnsSort", "filterColumns", "deleteIconProps", "logicOperatorInputProps", "operatorInputProps", "columnInputProps", "valueInputProps", "children"], _excluded2$8 = ["InputComponentProps"];
  const useUtilityClasses$y = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["filterForm"],
      deleteIcon: ["filterFormDeleteIcon"],
      logicOperatorInput: ["filterFormLogicOperatorInput"],
      columnInput: ["filterFormColumnInput"],
      operatorInput: ["filterFormOperatorInput"],
      valueInput: ["filterFormValueInput"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridFilterFormRoot = styled$1("div", {
    name: "MuiDataGrid",
    slot: "FilterForm",
    overridesResolver: (props, styles2) => styles2.filterForm
  })(({
    theme
  }) => ({
    display: "flex",
    padding: theme.spacing(1)
  }));
  const FilterFormDeleteIcon = styled$1("div", {
    name: "MuiDataGrid",
    slot: "FilterFormDeleteIcon",
    overridesResolver: (_2, styles2) => styles2.filterFormDeleteIcon
  })(({
    theme
  }) => ({
    flexShrink: 0,
    justifyContent: "flex-end",
    marginRight: theme.spacing(0.5),
    marginBottom: theme.spacing(0.2)
  }));
  const FilterFormLogicOperatorInput = styled$1("div", {
    name: "MuiDataGrid",
    slot: "FilterFormLogicOperatorInput",
    overridesResolver: (_2, styles2) => styles2.filterFormLogicOperatorInput
  })({
    minWidth: 55,
    marginRight: 5,
    justifyContent: "end"
  });
  const FilterFormColumnInput = styled$1("div", {
    name: "MuiDataGrid",
    slot: "FilterFormColumnInput",
    overridesResolver: (_2, styles2) => styles2.filterFormColumnInput
  })({
    width: 150
  });
  const FilterFormOperatorInput = styled$1("div", {
    name: "MuiDataGrid",
    slot: "FilterFormOperatorInput",
    overridesResolver: (_2, styles2) => styles2.filterFormOperatorInput
  })({
    width: 120
  });
  const FilterFormValueInput = styled$1("div", {
    name: "MuiDataGrid",
    slot: "FilterFormValueInput",
    overridesResolver: (_2, styles2) => styles2.filterFormValueInput
  })({
    width: 190
  });
  const getLogicOperatorLocaleKey = (logicOperator) => {
    switch (logicOperator) {
      case GridLogicOperator.And:
        return "filterPanelOperatorAnd";
      case GridLogicOperator.Or:
        return "filterPanelOperatorOr";
      default:
        throw new Error("MUI: Invalid `logicOperator` property in the `GridFilterPanel`.");
    }
  };
  const getColumnLabel = (col) => col.headerName || col.field;
  const collator = new Intl.Collator();
  const GridFilterForm = /* @__PURE__ */ React__namespace.forwardRef(function GridFilterForm2(props, ref) {
    var _rootProps$slotProps, _rootProps$slotProps2, _baseSelectProps$nati, _rootProps$slotProps3, _rootProps$slotProps4, _rootProps$slotProps5, _rootProps$slotProps6, _rootProps$slotProps7, _rootProps$slotProps8, _currentColumn$filter2;
    const {
      item,
      hasMultipleFilters,
      deleteFilter,
      applyFilterChanges,
      multiFilterOperator,
      showMultiFilterOperators,
      disableMultiFilterOperator,
      applyMultiFilterOperatorChanges,
      focusElementRef,
      logicOperators = [GridLogicOperator.And, GridLogicOperator.Or],
      columnsSort,
      filterColumns,
      deleteIconProps = {},
      logicOperatorInputProps = {},
      operatorInputProps = {},
      columnInputProps = {},
      valueInputProps = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$S);
    const apiRef2 = useGridApiContext();
    const filterableColumns = useGridSelector(apiRef2, gridFilterableColumnDefinitionsSelector);
    const filterModel2 = useGridSelector(apiRef2, gridFilterModelSelector);
    const columnSelectId = useId();
    const columnSelectLabelId = useId();
    const operatorSelectId = useId();
    const operatorSelectLabelId = useId();
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$y(rootProps);
    const valueRef = React__namespace.useRef(null);
    const filterSelectorRef = React__namespace.useRef(null);
    const hasLogicOperatorColumn = hasMultipleFilters && logicOperators.length > 0;
    const baseFormControlProps = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseFormControl) || {};
    const baseSelectProps = ((_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSelect) || {};
    const isBaseSelectNative = (_baseSelectProps$nati = baseSelectProps.native) != null ? _baseSelectProps$nati : true;
    const baseInputLabelProps = ((_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseInputLabel) || {};
    const baseSelectOptionProps = ((_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseSelectOption) || {};
    const {
      InputComponentProps
    } = valueInputProps, valueInputPropsOther = _objectWithoutPropertiesLoose(valueInputProps, _excluded2$8);
    const filteredColumns = React__namespace.useMemo(() => {
      if (filterColumns === void 0 || typeof filterColumns !== "function") {
        return filterableColumns;
      }
      const filteredFields = filterColumns({
        field: item.field,
        columns: filterableColumns,
        currentFilters: (filterModel2 == null ? void 0 : filterModel2.items) || []
      });
      return filterableColumns.filter((column2) => filteredFields.includes(column2.field));
    }, [filterColumns, filterModel2 == null ? void 0 : filterModel2.items, filterableColumns, item.field]);
    const sortedFilteredColumns = React__namespace.useMemo(() => {
      switch (columnsSort) {
        case "asc":
          return filteredColumns.sort((a, b2) => collator.compare(getColumnLabel(a), getColumnLabel(b2)));
        case "desc":
          return filteredColumns.sort((a, b2) => -collator.compare(getColumnLabel(a), getColumnLabel(b2)));
        default:
          return filteredColumns;
      }
    }, [filteredColumns, columnsSort]);
    const currentColumn = item.field ? apiRef2.current.getColumn(item.field) : null;
    const currentOperator = React__namespace.useMemo(() => {
      var _currentColumn$filter;
      if (!item.operator || !currentColumn) {
        return null;
      }
      return (_currentColumn$filter = currentColumn.filterOperators) == null ? void 0 : _currentColumn$filter.find((operator) => operator.value === item.operator);
    }, [item, currentColumn]);
    const changeColumn = React__namespace.useCallback((event) => {
      const field = event.target.value;
      const column2 = apiRef2.current.getColumn(field);
      if (column2.field === currentColumn.field) {
        return;
      }
      const newOperator = column2.filterOperators.find((operator) => operator.value === item.operator) || column2.filterOperators[0];
      const eraseItemValue = !newOperator.InputComponent || newOperator.InputComponent !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
      applyFilterChanges(_extends({}, item, {
        field,
        operator: newOperator.value,
        value: eraseItemValue ? void 0 : item.value
      }));
    }, [apiRef2, applyFilterChanges, item, currentColumn, currentOperator]);
    const changeOperator = React__namespace.useCallback((event) => {
      const operator = event.target.value;
      const newOperator = currentColumn == null ? void 0 : currentColumn.filterOperators.find((op) => op.value === operator);
      const eraseItemValue = !(newOperator != null && newOperator.InputComponent) || (newOperator == null ? void 0 : newOperator.InputComponent) !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
      applyFilterChanges(_extends({}, item, {
        operator,
        value: eraseItemValue ? void 0 : item.value
      }));
    }, [applyFilterChanges, item, currentColumn, currentOperator]);
    const changeLogicOperator = React__namespace.useCallback((event) => {
      const logicOperator = event.target.value === GridLogicOperator.And.toString() ? GridLogicOperator.And : GridLogicOperator.Or;
      applyMultiFilterOperatorChanges(logicOperator);
    }, [applyMultiFilterOperatorChanges]);
    const handleDeleteFilter = () => {
      if (rootProps.disableMultipleColumnsFiltering) {
        if (item.value === void 0) {
          deleteFilter(item);
        } else {
          applyFilterChanges(_extends({}, item, {
            value: void 0
          }));
        }
      } else {
        deleteFilter(item);
      }
    };
    React__namespace.useImperativeHandle(focusElementRef, () => ({
      focus: () => {
        if (currentOperator != null && currentOperator.InputComponent) {
          var _valueRef$current;
          valueRef == null || (_valueRef$current = valueRef.current) == null ? void 0 : _valueRef$current.focus();
        } else {
          filterSelectorRef.current.focus();
        }
      }
    }), [currentOperator]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFilterFormRoot, _extends({
      ref,
      className: classes.root,
      "data-id": item.id,
      ownerState: rootProps
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormDeleteIcon, _extends({
        variant: "standard",
        as: rootProps.slots.baseFormControl
      }, baseFormControlProps, deleteIconProps, {
        className: clsx(classes.deleteIcon, baseFormControlProps.className, deleteIconProps.className),
        ownerState: rootProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends({
          "aria-label": apiRef2.current.getLocaleText("filterPanelDeleteIconLabel"),
          title: apiRef2.current.getLocaleText("filterPanelDeleteIconLabel"),
          onClick: handleDeleteFilter,
          size: "small"
        }, (_rootProps$slotProps5 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps5.baseIconButton, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelDeleteIcon, {
            fontSize: "small"
          })
        }))
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormLogicOperatorInput, _extends({
        variant: "standard",
        as: rootProps.slots.baseFormControl
      }, baseFormControlProps, logicOperatorInputProps, {
        sx: _extends({
          display: hasLogicOperatorColumn ? "flex" : "none",
          visibility: showMultiFilterOperators ? "visible" : "hidden"
        }, baseFormControlProps.sx || {}, logicOperatorInputProps.sx || {}),
        className: clsx(classes.logicOperatorInput, baseFormControlProps.className, logicOperatorInputProps.className),
        ownerState: rootProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends({
          inputProps: {
            "aria-label": apiRef2.current.getLocaleText("filterPanelLogicOperator")
          },
          value: multiFilterOperator,
          onChange: changeLogicOperator,
          disabled: !!disableMultiFilterOperator || logicOperators.length === 1,
          native: isBaseSelectNative
        }, (_rootProps$slotProps6 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps6.baseSelect, {
          children: logicOperators.map((logicOperator) => /* @__PURE__ */ React.createElement(rootProps.slots.baseSelectOption, _extends({}, baseSelectOptionProps, {
            native: isBaseSelectNative,
            key: logicOperator.toString(),
            value: logicOperator.toString()
          }), apiRef2.current.getLocaleText(getLogicOperatorLocaleKey(logicOperator))))
        }))
      })), /* @__PURE__ */ jsxRuntimeExports.jsxs(FilterFormColumnInput, _extends({
        variant: "standard",
        as: rootProps.slots.baseFormControl
      }, baseFormControlProps, columnInputProps, {
        className: clsx(classes.columnInput, baseFormControlProps.className, columnInputProps.className),
        ownerState: rootProps,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends({}, baseInputLabelProps, {
          htmlFor: columnSelectId,
          id: columnSelectLabelId,
          children: apiRef2.current.getLocaleText("filterPanelColumns")
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends({
          labelId: columnSelectLabelId,
          id: columnSelectId,
          label: apiRef2.current.getLocaleText("filterPanelColumns"),
          value: item.field || "",
          onChange: changeColumn,
          native: isBaseSelectNative
        }, (_rootProps$slotProps7 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps7.baseSelect, {
          children: sortedFilteredColumns.map((col) => /* @__PURE__ */ React.createElement(rootProps.slots.baseSelectOption, _extends({}, baseSelectOptionProps, {
            native: isBaseSelectNative,
            key: col.field,
            value: col.field
          }), getColumnLabel(col)))
        }))]
      })), /* @__PURE__ */ jsxRuntimeExports.jsxs(FilterFormOperatorInput, _extends({
        variant: "standard",
        as: rootProps.slots.baseFormControl
      }, baseFormControlProps, operatorInputProps, {
        className: clsx(classes.operatorInput, baseFormControlProps.className, operatorInputProps.className),
        ownerState: rootProps,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends({}, baseInputLabelProps, {
          htmlFor: operatorSelectId,
          id: operatorSelectLabelId,
          children: apiRef2.current.getLocaleText("filterPanelOperator")
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends({
          labelId: operatorSelectLabelId,
          label: apiRef2.current.getLocaleText("filterPanelOperator"),
          id: operatorSelectId,
          value: item.operator,
          onChange: changeOperator,
          native: isBaseSelectNative,
          inputRef: filterSelectorRef
        }, (_rootProps$slotProps8 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps8.baseSelect, {
          children: currentColumn == null || (_currentColumn$filter2 = currentColumn.filterOperators) == null ? void 0 : _currentColumn$filter2.map((operator) => /* @__PURE__ */ React.createElement(rootProps.slots.baseSelectOption, _extends({}, baseSelectOptionProps, {
            native: isBaseSelectNative,
            key: operator.value,
            value: operator.value
          }), operator.label || apiRef2.current.getLocaleText(`filterOperator${capitalize(operator.value)}`)))
        }))]
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormValueInput, _extends({
        variant: "standard",
        as: rootProps.slots.baseFormControl
      }, baseFormControlProps, valueInputPropsOther, {
        className: clsx(classes.valueInput, baseFormControlProps.className, valueInputPropsOther.className),
        ownerState: rootProps,
        children: currentOperator != null && currentOperator.InputComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(currentOperator.InputComponent, _extends({
          apiRef: apiRef2,
          item,
          applyValue: applyFilterChanges,
          focusElementRef: valueRef
        }, currentOperator.InputComponentProps, InputComponentProps)) : null
      }))]
    }));
  });
  class Timeout {
    constructor() {
      this.currentId = 0;
      this.clear = () => {
        if (this.currentId !== 0) {
          clearTimeout(this.currentId);
          this.currentId = 0;
        }
      };
      this.disposeEffect = () => {
        return this.clear;
      };
    }
    static create() {
      return new Timeout();
    }
    start(delay, fn2) {
      this.clear();
      this.currentId = setTimeout(fn2, delay);
    }
  }
  function useTimeout() {
    const timeout = useLazyRef(Timeout.create).current;
    useOnMount(timeout.disposeEffect);
    return timeout;
  }
  const _excluded$R = ["item", "applyValue", "type", "apiRef", "focusElementRef", "tabIndex", "disabled", "isFilterActive", "clearButton", "InputProps"];
  function GridFilterInputValue(props) {
    var _item$value, _rootProps$slotProps;
    const {
      item,
      applyValue,
      type,
      apiRef: apiRef2,
      focusElementRef,
      tabIndex,
      disabled,
      clearButton,
      InputProps
    } = props, others = _objectWithoutPropertiesLoose(props, _excluded$R);
    const filterTimeout = useTimeout();
    const [filterValueState, setFilterValueState] = React__namespace.useState((_item$value = item.value) != null ? _item$value : "");
    const [applying, setIsApplying] = React__namespace.useState(false);
    const id = useId();
    const rootProps = useGridRootProps();
    const onFilterChange = React__namespace.useCallback((event) => {
      const {
        value
      } = event.target;
      setFilterValueState(String(value));
      setIsApplying(true);
      filterTimeout.start(rootProps.filterDebounceMs, () => {
        const newItem = _extends({}, item, {
          value,
          fromInput: id
        });
        applyValue(newItem);
        setIsApplying(false);
      });
    }, [id, applyValue, item, rootProps.filterDebounceMs, filterTimeout]);
    React__namespace.useEffect(() => {
      const itemPlusTag = item;
      if (itemPlusTag.fromInput !== id) {
        var _item$value2;
        setFilterValueState(String((_item$value2 = item.value) != null ? _item$value2 : ""));
      }
    }, [id, item]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends({
      id,
      label: apiRef2.current.getLocaleText("filterPanelInputLabel"),
      placeholder: apiRef2.current.getLocaleText("filterPanelInputPlaceholder"),
      value: filterValueState,
      onChange: onFilterChange,
      variant: "standard",
      type: type || "text",
      InputProps: _extends({}, applying || clearButton ? {
        endAdornment: applying ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
          fontSize: "small",
          color: "action"
        }) : clearButton
      } : {}, {
        disabled
      }, InputProps, {
        inputProps: _extends({
          tabIndex
        }, InputProps == null ? void 0 : InputProps.inputProps)
      }),
      InputLabelProps: {
        shrink: true
      },
      inputRef: focusElementRef
    }, others, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
  }
  const _excluded$Q = ["item", "applyValue", "type", "apiRef", "focusElementRef", "InputProps", "isFilterActive", "clearButton", "tabIndex", "disabled"];
  function GridFilterInputDate(props) {
    var _item$value, _rootProps$slotProps;
    const {
      item,
      applyValue,
      type,
      apiRef: apiRef2,
      focusElementRef,
      InputProps,
      clearButton,
      tabIndex,
      disabled
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Q);
    const filterTimeout = useTimeout();
    const [filterValueState, setFilterValueState] = React__namespace.useState((_item$value = item.value) != null ? _item$value : "");
    const [applying, setIsApplying] = React__namespace.useState(false);
    const id = useId();
    const rootProps = useGridRootProps();
    const onFilterChange = React__namespace.useCallback((event) => {
      const value = event.target.value;
      setFilterValueState(String(value));
      setIsApplying(true);
      filterTimeout.start(rootProps.filterDebounceMs, () => {
        applyValue(_extends({}, item, {
          value
        }));
        setIsApplying(false);
      });
    }, [applyValue, item, rootProps.filterDebounceMs, filterTimeout]);
    React__namespace.useEffect(() => {
      var _item$value2;
      const itemValue = (_item$value2 = item.value) != null ? _item$value2 : "";
      setFilterValueState(String(itemValue));
    }, [item.value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends({
      fullWidth: true,
      id,
      label: apiRef2.current.getLocaleText("filterPanelInputLabel"),
      placeholder: apiRef2.current.getLocaleText("filterPanelInputPlaceholder"),
      value: filterValueState,
      onChange: onFilterChange,
      variant: "standard",
      type: type || "text",
      InputLabelProps: {
        shrink: true
      },
      inputRef: focusElementRef,
      InputProps: _extends({}, applying || clearButton ? {
        endAdornment: applying ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
          fontSize: "small",
          color: "action"
        }) : clearButton
      } : {}, {
        disabled
      }, InputProps, {
        inputProps: _extends({
          max: type === "datetime-local" ? "9999-12-31T23:59" : "9999-12-31",
          tabIndex
        }, InputProps == null ? void 0 : InputProps.inputProps)
      })
    }, other, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
  }
  const _excluded$P = ["item", "applyValue", "type", "apiRef", "focusElementRef", "getOptionLabel", "getOptionValue", "placeholder", "tabIndex", "label", "isFilterActive", "clearButton"];
  const renderSingleSelectOptions = ({
    column: {
      valueOptions,
      field
    },
    OptionComponent,
    getOptionLabel,
    getOptionValue,
    isSelectNative,
    baseSelectOptionProps
  }) => {
    const iterableColumnValues = typeof valueOptions === "function" ? ["", ...valueOptions({
      field
    })] : ["", ...valueOptions || []];
    return iterableColumnValues.map((option) => {
      const value = getOptionValue(option);
      const label = getOptionLabel(option);
      return /* @__PURE__ */ React.createElement(OptionComponent, _extends({}, baseSelectOptionProps, {
        native: isSelectNative,
        key: value,
        value
      }), label);
    });
  };
  const SingleSelectOperatorContainer = styled$1("div")({
    display: "flex",
    alignItems: "flex-end",
    width: "100%",
    [`& button`]: {
      margin: "auto 0px 5px 5px"
    }
  });
  function GridFilterInputSingleSelect(props) {
    var _item$value, _rootProps$slotProps$, _rootProps$slotProps, _resolvedColumn, _resolvedColumn2, _rootProps$slotProps2, _rootProps$slotProps3, _rootProps$slotProps4;
    const {
      item,
      applyValue,
      type,
      apiRef: apiRef2,
      focusElementRef,
      getOptionLabel: getOptionLabelProp,
      getOptionValue: getOptionValueProp,
      placeholder,
      tabIndex,
      label: labelProp,
      clearButton
    } = props, others = _objectWithoutPropertiesLoose(props, _excluded$P);
    const [filterValueState, setFilterValueState] = React__namespace.useState((_item$value = item.value) != null ? _item$value : "");
    const id = useId();
    const labelId = useId();
    const rootProps = useGridRootProps();
    const isSelectNative = (_rootProps$slotProps$ = (_rootProps$slotProps = rootProps.slotProps) == null || (_rootProps$slotProps = _rootProps$slotProps.baseSelect) == null ? void 0 : _rootProps$slotProps.native) != null ? _rootProps$slotProps$ : true;
    let resolvedColumn = null;
    if (item.field) {
      const column2 = apiRef2.current.getColumn(item.field);
      if (isSingleSelectColDef(column2)) {
        resolvedColumn = column2;
      }
    }
    const getOptionValue = getOptionValueProp || ((_resolvedColumn = resolvedColumn) == null ? void 0 : _resolvedColumn.getOptionValue);
    const getOptionLabel = getOptionLabelProp || ((_resolvedColumn2 = resolvedColumn) == null ? void 0 : _resolvedColumn2.getOptionLabel);
    const currentValueOptions = React__namespace.useMemo(() => {
      if (!resolvedColumn) {
        return void 0;
      }
      return typeof resolvedColumn.valueOptions === "function" ? resolvedColumn.valueOptions({
        field: resolvedColumn.field
      }) : resolvedColumn.valueOptions;
    }, [resolvedColumn]);
    const onFilterChange = React__namespace.useCallback((event) => {
      let value = event.target.value;
      value = getValueFromValueOptions(value, currentValueOptions, getOptionValue);
      setFilterValueState(String(value));
      applyValue(_extends({}, item, {
        value
      }));
    }, [currentValueOptions, getOptionValue, applyValue, item]);
    React__namespace.useEffect(() => {
      var _itemValue;
      let itemValue;
      if (currentValueOptions !== void 0) {
        itemValue = getValueFromValueOptions(item.value, currentValueOptions, getOptionValue);
        if (itemValue !== item.value) {
          applyValue(_extends({}, item, {
            value: itemValue
          }));
          return;
        }
      } else {
        itemValue = item.value;
      }
      itemValue = (_itemValue = itemValue) != null ? _itemValue : "";
      setFilterValueState(String(itemValue));
    }, [item, currentValueOptions, applyValue, getOptionValue]);
    if (!isSingleSelectColDef(resolvedColumn)) {
      return null;
    }
    if (!isSingleSelectColDef(resolvedColumn)) {
      return null;
    }
    const label = labelProp != null ? labelProp : apiRef2.current.getLocaleText("filterPanelInputLabel");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SingleSelectOperatorContainer, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseFormControl, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseInputLabel, {
          id: labelId,
          htmlFor: id,
          shrink: true,
          variant: "standard",
          children: label
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends({
          id,
          label,
          labelId,
          value: filterValueState,
          onChange: onFilterChange,
          variant: "standard",
          type: type || "text",
          inputProps: {
            tabIndex,
            ref: focusElementRef,
            placeholder: placeholder != null ? placeholder : apiRef2.current.getLocaleText("filterPanelInputPlaceholder")
          },
          native: isSelectNative
        }, others, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseSelect, {
          children: renderSingleSelectOptions({
            column: resolvedColumn,
            OptionComponent: rootProps.slots.baseSelectOption,
            getOptionLabel,
            getOptionValue,
            isSelectNative,
            baseSelectOptionProps: (_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseSelectOption
          })
        }))]
      }), clearButton]
    });
  }
  const _excluded$O = ["item", "applyValue", "apiRef", "focusElementRef", "isFilterActive", "clearButton", "tabIndex", "label"];
  const BooleanOperatorContainer = styled$1("div")({
    display: "flex",
    alignItems: "center",
    width: "100%",
    [`& button`]: {
      margin: "auto 0px 5px 5px"
    }
  });
  function GridFilterInputBoolean(props) {
    var _rootProps$slotProps, _baseSelectProps$nati, _rootProps$slotProps2, _rootProps$slotProps3;
    const {
      item,
      applyValue,
      apiRef: apiRef2,
      focusElementRef,
      clearButton,
      tabIndex,
      label: labelProp
    } = props, others = _objectWithoutPropertiesLoose(props, _excluded$O);
    const [filterValueState, setFilterValueState] = React__namespace.useState(item.value || "");
    const rootProps = useGridRootProps();
    const labelId = useId();
    const selectId = useId();
    const baseSelectProps = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseSelect) || {};
    const isSelectNative = (_baseSelectProps$nati = baseSelectProps.native) != null ? _baseSelectProps$nati : true;
    const baseSelectOptionProps = ((_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSelectOption) || {};
    const onFilterChange = React__namespace.useCallback((event) => {
      const value = event.target.value;
      setFilterValueState(value);
      applyValue(_extends({}, item, {
        value
      }));
    }, [applyValue, item]);
    React__namespace.useEffect(() => {
      setFilterValueState(item.value || "");
    }, [item.value]);
    const label = labelProp != null ? labelProp : apiRef2.current.getLocaleText("filterPanelInputLabel");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(BooleanOperatorContainer, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseFormControl, {
        fullWidth: true,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends({}, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseInputLabel, {
          id: labelId,
          shrink: true,
          variant: "standard",
          children: label
        })), /* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseSelect, _extends({
          labelId,
          id: selectId,
          label,
          value: filterValueState,
          onChange: onFilterChange,
          variant: "standard",
          native: isSelectNative,
          displayEmpty: true,
          inputProps: {
            ref: focusElementRef,
            tabIndex
          }
        }, others, baseSelectProps, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends({}, baseSelectOptionProps, {
            native: isSelectNative,
            value: "",
            children: apiRef2.current.getLocaleText("filterValueAny")
          })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends({}, baseSelectOptionProps, {
            native: isSelectNative,
            value: "true",
            children: apiRef2.current.getLocaleText("filterValueTrue")
          })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends({}, baseSelectOptionProps, {
            native: isSelectNative,
            value: "false",
            children: apiRef2.current.getLocaleText("filterValueFalse")
          }))]
        }))]
      }), clearButton]
    });
  }
  const _excluded$N = ["logicOperators", "columnsSort", "filterFormProps", "getColumnForNewFilter", "children", "disableAddFilterButton", "disableRemoveAllButton"];
  const getGridFilter = (col) => ({
    field: col.field,
    operator: col.filterOperators[0].value,
    id: Math.round(Math.random() * 1e5)
  });
  const GridFilterPanel = /* @__PURE__ */ React__namespace.forwardRef(function GridFilterPanel2(props, ref) {
    var _rootProps$slotProps, _rootProps$slotProps2;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const filterModel2 = useGridSelector(apiRef2, gridFilterModelSelector);
    const filterableColumns = useGridSelector(apiRef2, gridFilterableColumnDefinitionsSelector);
    const lastFilterRef = React__namespace.useRef(null);
    const placeholderFilter = React__namespace.useRef(null);
    const {
      logicOperators = [GridLogicOperator.And, GridLogicOperator.Or],
      columnsSort,
      filterFormProps,
      getColumnForNewFilter,
      disableAddFilterButton = false,
      disableRemoveAllButton = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$N);
    const applyFilter = apiRef2.current.upsertFilterItem;
    const applyFilterLogicOperator = React__namespace.useCallback((operator) => {
      apiRef2.current.setFilterLogicOperator(operator);
    }, [apiRef2]);
    const getDefaultFilter = React__namespace.useCallback(() => {
      let nextColumnWithOperator;
      if (getColumnForNewFilter && typeof getColumnForNewFilter === "function") {
        const nextFieldName = getColumnForNewFilter({
          currentFilters: (filterModel2 == null ? void 0 : filterModel2.items) || [],
          columns: filterableColumns
        });
        if (nextFieldName === null) {
          return null;
        }
        nextColumnWithOperator = filterableColumns.find(({
          field
        }) => field === nextFieldName);
      } else {
        nextColumnWithOperator = filterableColumns.find((colDef) => {
          var _colDef$filterOperato;
          return (_colDef$filterOperato = colDef.filterOperators) == null ? void 0 : _colDef$filterOperato.length;
        });
      }
      if (!nextColumnWithOperator) {
        return null;
      }
      return getGridFilter(nextColumnWithOperator);
    }, [filterModel2 == null ? void 0 : filterModel2.items, filterableColumns, getColumnForNewFilter]);
    const getNewFilter = React__namespace.useCallback(() => {
      if (getColumnForNewFilter === void 0 || typeof getColumnForNewFilter !== "function") {
        return getDefaultFilter();
      }
      const currentFilters = filterModel2.items.length ? filterModel2.items : [getDefaultFilter()].filter(Boolean);
      const nextColumnFieldName = getColumnForNewFilter({
        currentFilters,
        columns: filterableColumns
      });
      if (nextColumnFieldName === null) {
        return null;
      }
      const nextColumnWithOperator = filterableColumns.find(({
        field
      }) => field === nextColumnFieldName);
      if (!nextColumnWithOperator) {
        return null;
      }
      return getGridFilter(nextColumnWithOperator);
    }, [filterModel2.items, filterableColumns, getColumnForNewFilter, getDefaultFilter]);
    const items2 = React__namespace.useMemo(() => {
      if (filterModel2.items.length) {
        return filterModel2.items;
      }
      if (!placeholderFilter.current) {
        placeholderFilter.current = getDefaultFilter();
      }
      return placeholderFilter.current ? [placeholderFilter.current] : [];
    }, [filterModel2.items, getDefaultFilter]);
    const hasMultipleFilters = items2.length > 1;
    const addNewFilter = () => {
      const newFilter = getNewFilter();
      if (!newFilter) {
        return;
      }
      apiRef2.current.upsertFilterItems([...items2, newFilter]);
    };
    const deleteFilter = React__namespace.useCallback((item) => {
      const shouldCloseFilterPanel = items2.length === 1;
      apiRef2.current.deleteFilterItem(item);
      if (shouldCloseFilterPanel) {
        apiRef2.current.hideFilterPanel();
      }
    }, [apiRef2, items2.length]);
    const handleRemoveAll = () => {
      if (items2.length === 1 && items2[0].value === void 0) {
        apiRef2.current.deleteFilterItem(items2[0]);
        apiRef2.current.hideFilterPanel();
      }
      apiRef2.current.setFilterModel(_extends({}, filterModel2, {
        items: []
      }));
    };
    React__namespace.useEffect(() => {
      if (logicOperators.length > 0 && filterModel2.logicOperator && !logicOperators.includes(filterModel2.logicOperator)) {
        applyFilterLogicOperator(logicOperators[0]);
      }
    }, [logicOperators, applyFilterLogicOperator, filterModel2.logicOperator]);
    React__namespace.useEffect(() => {
      if (items2.length > 0) {
        lastFilterRef.current.focus();
      }
    }, [items2.length]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelWrapper, _extends({
      ref
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContent, {
        children: items2.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridFilterForm, _extends({
          item,
          applyFilterChanges: applyFilter,
          deleteFilter,
          hasMultipleFilters,
          showMultiFilterOperators: index > 0,
          multiFilterOperator: filterModel2.logicOperator,
          disableMultiFilterOperator: index !== 1,
          applyMultiFilterOperatorChanges: applyFilterLogicOperator,
          focusElementRef: index === items2.length - 1 ? lastFilterRef : null,
          logicOperators,
          columnsSort
        }, filterFormProps), item.id == null ? index : item.id))
      }), !rootProps.disableMultipleColumnsFiltering && !(disableAddFilterButton && disableRemoveAllButton) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelFooter, {
        children: [!disableAddFilterButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
          onClick: addNewFilter,
          startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelAddIcon, {})
        }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseButton, {
          children: apiRef2.current.getLocaleText("filterPanelAddFilter")
        })) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), !disableRemoveAllButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
          onClick: handleRemoveAll,
          startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelRemoveAllIcon, {})
        }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseButton, {
          children: apiRef2.current.getLocaleText("filterPanelRemoveAll")
        })) : null]
      }) : null]
    }));
  });
  function getListSubheaderUtilityClass(slot) {
    return generateUtilityClass("MuiListSubheader", slot);
  }
  generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
  const _excluded$M = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
  const useUtilityClasses$x = (ownerState) => {
    const {
      classes,
      color: color2,
      disableGutters,
      inset,
      disableSticky
    } = ownerState;
    const slots = {
      root: ["root", color2 !== "default" && `color${capitalize(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
    };
    return composeClasses(slots, getListSubheaderUtilityClass, classes);
  };
  const ListSubheaderRoot = styled$1("li", {
    name: "MuiListSubheader",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    boxSizing: "border-box",
    lineHeight: "48px",
    listStyle: "none",
    color: (theme.vars || theme).palette.text.secondary,
    fontFamily: theme.typography.fontFamily,
    fontWeight: theme.typography.fontWeightMedium,
    fontSize: theme.typography.pxToRem(14)
  }, ownerState.color === "primary" && {
    color: (theme.vars || theme).palette.primary.main
  }, ownerState.color === "inherit" && {
    color: "inherit"
  }, !ownerState.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, ownerState.inset && {
    paddingLeft: 72
  }, !ownerState.disableSticky && {
    position: "sticky",
    top: 0,
    zIndex: 1,
    backgroundColor: (theme.vars || theme).palette.background.paper
  }));
  const ListSubheader = /* @__PURE__ */ React__namespace.forwardRef(function ListSubheader2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiListSubheader"
    });
    const {
      className,
      color: color2 = "default",
      component = "li",
      disableGutters = false,
      disableSticky = false,
      inset = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$M);
    const ownerState = _extends({}, props, {
      color: color2,
      component,
      disableGutters,
      disableSticky,
      inset
    });
    const classes = useUtilityClasses$x(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListSubheaderRoot, _extends({
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState
    }, other));
  });
  ListSubheader.muiSkipListHighlight = true;
  const ListSubheader$1 = ListSubheader;
  const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
  }), "Cancel");
  function getChipUtilityClass(slot) {
    return generateUtilityClass("MuiChip", slot);
  }
  const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
  const chipClasses$1 = chipClasses;
  const _excluded$L = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
  const useUtilityClasses$w = (ownerState) => {
    const {
      classes,
      disabled,
      size,
      color: color2,
      iconColor,
      onDelete,
      clickable,
      variant
    } = ownerState;
    const slots = {
      root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
      label: ["label", `label${capitalize(size)}`],
      avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
      icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
      deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
    };
    return composeClasses(slots, getChipUtilityClass, classes);
  };
  const ChipRoot = styled$1("div", {
    name: "MuiChip",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      const {
        color: color2,
        iconColor,
        clickable,
        onDelete,
        size,
        variant
      } = ownerState;
      return [{
        [`& .${chipClasses$1.avatar}`]: styles2.avatar
      }, {
        [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`]
      }, {
        [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
      }, {
        [`& .${chipClasses$1.icon}`]: styles2.icon
      }, {
        [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`]
      }, {
        [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
      }, {
        [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
      }, {
        [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
      }, {
        [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
      }, {
        [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
      }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
    return _extends({
      maxWidth: "100%",
      fontFamily: theme.typography.fontFamily,
      fontSize: theme.typography.pxToRem(13),
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      height: 32,
      color: (theme.vars || theme).palette.text.primary,
      backgroundColor: (theme.vars || theme).palette.action.selected,
      borderRadius: 32 / 2,
      whiteSpace: "nowrap",
      transition: theme.transitions.create(["background-color", "box-shadow"]),
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      textDecoration: "none",
      border: 0,
      // Remove `button` border
      padding: 0,
      // Remove `button` padding
      verticalAlign: "middle",
      boxSizing: "border-box",
      [`&.${chipClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity,
        pointerEvents: "none"
      },
      [`& .${chipClasses$1.avatar}`]: {
        marginLeft: 5,
        marginRight: -6,
        width: 24,
        height: 24,
        color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
        fontSize: theme.typography.pxToRem(12)
      },
      [`& .${chipClasses$1.avatarColorPrimary}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.dark
      },
      [`& .${chipClasses$1.avatarColorSecondary}`]: {
        color: (theme.vars || theme).palette.secondary.contrastText,
        backgroundColor: (theme.vars || theme).palette.secondary.dark
      },
      [`& .${chipClasses$1.avatarSmall}`]: {
        marginLeft: 4,
        marginRight: -4,
        width: 18,
        height: 18,
        fontSize: theme.typography.pxToRem(10)
      },
      [`& .${chipClasses$1.icon}`]: _extends({
        marginLeft: 5,
        marginRight: -6
      }, ownerState.size === "small" && {
        fontSize: 18,
        marginLeft: 4,
        marginRight: -4
      }, ownerState.iconColor === ownerState.color && _extends({
        color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
      }, ownerState.color !== "default" && {
        color: "inherit"
      })),
      [`& .${chipClasses$1.deleteIcon}`]: _extends({
        WebkitTapHighlightColor: "transparent",
        color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme.palette.text.primary, 0.26),
        fontSize: 22,
        cursor: "pointer",
        margin: "0 5px 0 -6px",
        "&:hover": {
          color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme.palette.text.primary, 0.4)
        }
      }, ownerState.size === "small" && {
        fontSize: 16,
        marginRight: 4,
        marginLeft: -4
      }, ownerState.color !== "default" && {
        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme.palette[ownerState.color].contrastText, 0.7),
        "&:hover, &:active": {
          color: (theme.vars || theme).palette[ownerState.color].contrastText
        }
      })
    }, ownerState.size === "small" && {
      height: 24
    }, ownerState.color !== "default" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
      color: (theme.vars || theme).palette[ownerState.color].contrastText
    }, ownerState.onDelete && {
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    }, ownerState.onDelete && ownerState.color !== "default" && {
      [`&.${chipClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
      }
    });
  }, ({
    theme,
    ownerState
  }) => _extends({}, ownerState.clickable && {
    userSelect: "none",
    WebkitTapHighlightColor: "transparent",
    cursor: "pointer",
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
    },
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    },
    "&:active": {
      boxShadow: (theme.vars || theme).shadows[1]
    }
  }, ownerState.clickable && ownerState.color !== "default" && {
    [`&:hover, &.${chipClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
    }
  }), ({
    theme,
    ownerState
  }) => _extends({}, ownerState.variant === "outlined" && {
    backgroundColor: "transparent",
    border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
    [`&.${chipClasses$1.clickable}:hover`]: {
      backgroundColor: (theme.vars || theme).palette.action.hover
    },
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`& .${chipClasses$1.avatar}`]: {
      marginLeft: 4
    },
    [`& .${chipClasses$1.avatarSmall}`]: {
      marginLeft: 2
    },
    [`& .${chipClasses$1.icon}`]: {
      marginLeft: 4
    },
    [`& .${chipClasses$1.iconSmall}`]: {
      marginLeft: 2
    },
    [`& .${chipClasses$1.deleteIcon}`]: {
      marginRight: 5
    },
    [`& .${chipClasses$1.deleteIconSmall}`]: {
      marginRight: 3
    }
  }, ownerState.variant === "outlined" && ownerState.color !== "default" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7)}`,
    [`&.${chipClasses$1.clickable}:hover`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
    },
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
    },
    [`& .${chipClasses$1.deleteIcon}`]: {
      color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7),
      "&:hover, &:active": {
        color: (theme.vars || theme).palette[ownerState.color].main
      }
    }
  }));
  const ChipLabel = styled$1("span", {
    name: "MuiChip",
    slot: "Label",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      const {
        size
      } = ownerState;
      return [styles2.label, styles2[`label${capitalize(size)}`]];
    }
  })(({
    ownerState
  }) => _extends({
    overflow: "hidden",
    textOverflow: "ellipsis",
    paddingLeft: 12,
    paddingRight: 12,
    whiteSpace: "nowrap"
  }, ownerState.size === "small" && {
    paddingLeft: 8,
    paddingRight: 8
  }));
  function isDeleteKeyboardEvent(keyboardEvent) {
    return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
  }
  const Chip = /* @__PURE__ */ React__namespace.forwardRef(function Chip2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiChip"
    });
    const {
      avatar: avatarProp,
      className,
      clickable: clickableProp,
      color: color2 = "default",
      component: ComponentProp,
      deleteIcon: deleteIconProp,
      disabled = false,
      icon: iconProp,
      label,
      onClick,
      onDelete,
      onKeyDown,
      onKeyUp,
      size = "medium",
      variant = "filled",
      tabIndex,
      skipFocusWhenDisabled = false
      // TODO v6: Rename to `focusableWhenDisabled`.
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$L);
    const chipRef = React__namespace.useRef(null);
    const handleRef = useForkRef(chipRef, ref);
    const handleDeleteIconClick = (event) => {
      event.stopPropagation();
      if (onDelete) {
        onDelete(event);
      }
    };
    const handleKeyDown2 = (event) => {
      if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
    };
    const handleKeyUp = (event) => {
      if (event.currentTarget === event.target) {
        if (onDelete && isDeleteKeyboardEvent(event)) {
          onDelete(event);
        } else if (event.key === "Escape" && chipRef.current) {
          chipRef.current.blur();
        }
      }
      if (onKeyUp) {
        onKeyUp(event);
      }
    };
    const clickable = clickableProp !== false && onClick ? true : clickableProp;
    const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
    const ownerState = _extends({}, props, {
      component,
      disabled,
      size,
      color: color2,
      iconColor: /* @__PURE__ */ React__namespace.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
      onDelete: !!onDelete,
      clickable,
      variant
    });
    const classes = useUtilityClasses$w(ownerState);
    const moreProps = component === ButtonBase$1 ? _extends({
      component: ComponentProp || "div",
      focusVisibleClassName: classes.focusVisible
    }, onDelete && {
      disableRipple: true
    }) : {};
    let deleteIcon = null;
    if (onDelete) {
      deleteIcon = deleteIconProp && /* @__PURE__ */ React__namespace.isValidElement(deleteIconProp) ? /* @__PURE__ */ React__namespace.cloneElement(deleteIconProp, {
        className: clsx(deleteIconProp.props.className, classes.deleteIcon),
        onClick: handleDeleteIconClick
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
        className: clsx(classes.deleteIcon),
        onClick: handleDeleteIconClick
      });
    }
    let avatar = null;
    if (avatarProp && /* @__PURE__ */ React__namespace.isValidElement(avatarProp)) {
      avatar = /* @__PURE__ */ React__namespace.cloneElement(avatarProp, {
        className: clsx(classes.avatar, avatarProp.props.className)
      });
    }
    let icon = null;
    if (iconProp && /* @__PURE__ */ React__namespace.isValidElement(iconProp)) {
      icon = /* @__PURE__ */ React__namespace.cloneElement(iconProp, {
        className: clsx(classes.icon, iconProp.props.className)
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends({
      as: component,
      className: clsx(classes.root, className),
      disabled: clickable && disabled ? true : void 0,
      onClick,
      onKeyDown: handleKeyDown2,
      onKeyUp: handleKeyUp,
      ref: handleRef,
      tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
      ownerState
    }, moreProps, other, {
      children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
        className: clsx(classes.label),
        ownerState,
        children: label
      }), deleteIcon]
    }));
  });
  const MUIChip = Chip;
  function getInputUtilityClass(slot) {
    return generateUtilityClass("MuiInput", slot);
  }
  const inputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
  const inputClasses$1 = inputClasses;
  function getOutlinedInputUtilityClass(slot) {
    return generateUtilityClass("MuiOutlinedInput", slot);
  }
  const outlinedInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
  const outlinedInputClasses$1 = outlinedInputClasses;
  function getFilledInputUtilityClass(slot) {
    return generateUtilityClass("MuiFilledInput", slot);
  }
  const filledInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
  const filledInputClasses$1 = filledInputClasses;
  const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), "Close");
  const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M7 10l5 5 5-5z"
  }), "ArrowDropDown");
  function getAutocompleteUtilityClass(slot) {
    return generateUtilityClass("MuiAutocomplete", slot);
  }
  const autocompleteClasses = generateUtilityClasses("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
  const autocompleteClasses$1 = autocompleteClasses;
  var _ClearIcon, _ArrowDropDownIcon;
  const _excluded$K = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"], _excluded2$7 = ["ref"];
  const useUtilityClasses$v = (ownerState) => {
    const {
      classes,
      disablePortal,
      expanded,
      focused,
      fullWidth,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      popupOpen,
      size
    } = ownerState;
    const slots = {
      root: ["root", expanded && "expanded", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
      inputRoot: ["inputRoot"],
      input: ["input", inputFocused && "inputFocused"],
      tag: ["tag", `tagSize${capitalize(size)}`],
      endAdornment: ["endAdornment"],
      clearIndicator: ["clearIndicator"],
      popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
      popper: ["popper", disablePortal && "popperDisablePortal"],
      paper: ["paper"],
      listbox: ["listbox"],
      loading: ["loading"],
      noOptions: ["noOptions"],
      option: ["option"],
      groupLabel: ["groupLabel"],
      groupUl: ["groupUl"]
    };
    return composeClasses(slots, getAutocompleteUtilityClass, classes);
  };
  const AutocompleteRoot = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      const {
        fullWidth,
        hasClearIcon,
        hasPopupIcon,
        inputFocused,
        size
      } = ownerState;
      return [{
        [`& .${autocompleteClasses$1.tag}`]: styles2.tag
      }, {
        [`& .${autocompleteClasses$1.tag}`]: styles2[`tagSize${capitalize(size)}`]
      }, {
        [`& .${autocompleteClasses$1.inputRoot}`]: styles2.inputRoot
      }, {
        [`& .${autocompleteClasses$1.input}`]: styles2.input
      }, {
        [`& .${autocompleteClasses$1.input}`]: inputFocused && styles2.inputFocused
      }, styles2.root, fullWidth && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
    }
  })(({
    ownerState
  }) => _extends({
    [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
      visibility: "visible"
    },
    /* Avoid double tap issue on iOS */
    "@media (pointer: fine)": {
      [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
        visibility: "visible"
      }
    }
  }, ownerState.fullWidth && {
    width: "100%"
  }, {
    [`& .${autocompleteClasses$1.tag}`]: _extends({
      margin: 3,
      maxWidth: "calc(100% - 6px)"
    }, ownerState.size === "small" && {
      margin: 2,
      maxWidth: "calc(100% - 4px)"
    }),
    [`& .${autocompleteClasses$1.inputRoot}`]: {
      flexWrap: "wrap",
      [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
        paddingRight: 26 + 4
      },
      [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
        paddingRight: 52 + 4
      },
      [`& .${autocompleteClasses$1.input}`]: {
        width: 0,
        minWidth: 30
      }
    },
    [`& .${inputClasses$1.root}`]: {
      paddingBottom: 1,
      "& .MuiInput-input": {
        padding: "4px 4px 4px 0px"
      }
    },
    [`& .${inputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
      [`& .${inputClasses$1.input}`]: {
        padding: "2px 4px 3px 0"
      }
    },
    [`& .${outlinedInputClasses$1.root}`]: {
      padding: 9,
      [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
        paddingRight: 26 + 4 + 9
      },
      [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
        paddingRight: 52 + 4 + 9
      },
      [`& .${autocompleteClasses$1.input}`]: {
        padding: "7.5px 4px 7.5px 5px"
      },
      [`& .${autocompleteClasses$1.endAdornment}`]: {
        right: 9
      }
    },
    [`& .${outlinedInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
      // Don't specify paddingRight, as it overrides the default value set when there is only
      // one of the popup or clear icon as the specificity is equal so the latter one wins
      paddingTop: 6,
      paddingBottom: 6,
      paddingLeft: 6,
      [`& .${autocompleteClasses$1.input}`]: {
        padding: "2.5px 4px 2.5px 8px"
      }
    },
    [`& .${filledInputClasses$1.root}`]: {
      paddingTop: 19,
      paddingLeft: 8,
      [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
        paddingRight: 26 + 4 + 9
      },
      [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
        paddingRight: 52 + 4 + 9
      },
      [`& .${filledInputClasses$1.input}`]: {
        padding: "7px 4px"
      },
      [`& .${autocompleteClasses$1.endAdornment}`]: {
        right: 9
      }
    },
    [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
      paddingBottom: 1,
      [`& .${filledInputClasses$1.input}`]: {
        padding: "2.5px 4px"
      }
    },
    [`& .${inputBaseClasses$1.hiddenLabel}`]: {
      paddingTop: 8
    },
    [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.hiddenLabel}`]: {
      paddingTop: 0,
      paddingBottom: 0,
      [`& .${autocompleteClasses$1.input}`]: {
        paddingTop: 16,
        paddingBottom: 17
      }
    },
    [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.hiddenLabel}.${inputBaseClasses$1.sizeSmall}`]: {
      [`& .${autocompleteClasses$1.input}`]: {
        paddingTop: 8,
        paddingBottom: 9
      }
    },
    [`& .${autocompleteClasses$1.input}`]: _extends({
      flexGrow: 1,
      textOverflow: "ellipsis",
      opacity: 0
    }, ownerState.inputFocused && {
      opacity: 1
    })
  }));
  const AutocompleteEndAdornment = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "EndAdornment",
    overridesResolver: (props, styles2) => styles2.endAdornment
  })({
    // We use a position absolute to support wrapping tags.
    position: "absolute",
    right: 0,
    top: "calc(50% - 14px)"
    // Center vertically
  });
  const AutocompleteClearIndicator = styled$1(MUIIconButton, {
    name: "MuiAutocomplete",
    slot: "ClearIndicator",
    overridesResolver: (props, styles2) => styles2.clearIndicator
  })({
    marginRight: -2,
    padding: 4,
    visibility: "hidden"
  });
  const AutocompletePopupIndicator = styled$1(MUIIconButton, {
    name: "MuiAutocomplete",
    slot: "PopupIndicator",
    overridesResolver: ({
      ownerState
    }, styles2) => _extends({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
  })(({
    ownerState
  }) => _extends({
    padding: 2,
    marginRight: -2
  }, ownerState.popupOpen && {
    transform: "rotate(180deg)"
  }));
  const AutocompletePopper = styled$1(MUIPopper, {
    name: "MuiAutocomplete",
    slot: "Popper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${autocompleteClasses$1.option}`]: styles2.option
      }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    zIndex: (theme.vars || theme).zIndex.modal
  }, ownerState.disablePortal && {
    position: "absolute"
  }));
  const AutocompletePaper = styled$1(PaperBase, {
    name: "MuiAutocomplete",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper
  })(({
    theme
  }) => _extends({}, theme.typography.body1, {
    overflow: "auto"
  }));
  const AutocompleteLoading = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "Loading",
    overridesResolver: (props, styles2) => styles2.loading
  })(({
    theme
  }) => ({
    color: (theme.vars || theme).palette.text.secondary,
    padding: "14px 16px"
  }));
  const AutocompleteNoOptions = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "NoOptions",
    overridesResolver: (props, styles2) => styles2.noOptions
  })(({
    theme
  }) => ({
    color: (theme.vars || theme).palette.text.secondary,
    padding: "14px 16px"
  }));
  const AutocompleteListbox = styled$1("div", {
    name: "MuiAutocomplete",
    slot: "Listbox",
    overridesResolver: (props, styles2) => styles2.listbox
  })(({
    theme
  }) => ({
    listStyle: "none",
    margin: 0,
    padding: "8px 0",
    maxHeight: "40vh",
    overflow: "auto",
    position: "relative",
    [`& .${autocompleteClasses$1.option}`]: {
      minHeight: 48,
      display: "flex",
      overflow: "hidden",
      justifyContent: "flex-start",
      alignItems: "center",
      cursor: "pointer",
      paddingTop: 6,
      boxSizing: "border-box",
      outline: "0",
      WebkitTapHighlightColor: "transparent",
      paddingBottom: 6,
      paddingLeft: 16,
      paddingRight: 16,
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      },
      [`&.${autocompleteClasses$1.focused}`]: {
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      '&[aria-disabled="true"]': {
        opacity: (theme.vars || theme).palette.action.disabledOpacity,
        pointerEvents: "none"
      },
      [`&.${autocompleteClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      '&[aria-selected="true"]': {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${autocompleteClasses$1.focused}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette.action.selected
          }
        },
        [`&.${autocompleteClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      }
    }
  }));
  const AutocompleteGroupLabel = styled$1(ListSubheader$1, {
    name: "MuiAutocomplete",
    slot: "GroupLabel",
    overridesResolver: (props, styles2) => styles2.groupLabel
  })(({
    theme
  }) => ({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    top: -8
  }));
  const AutocompleteGroupUl = styled$1("ul", {
    name: "MuiAutocomplete",
    slot: "GroupUl",
    overridesResolver: (props, styles2) => styles2.groupUl
  })({
    padding: 0,
    [`& .${autocompleteClasses$1.option}`]: {
      paddingLeft: 24
    }
  });
  const Autocomplete = /* @__PURE__ */ React__namespace.forwardRef(function Autocomplete2(inProps, ref) {
    var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
    const props = useThemeProps({
      props: inProps,
      name: "MuiAutocomplete"
    });
    const {
      autoComplete = false,
      autoHighlight = false,
      autoSelect = false,
      blurOnSelect = false,
      ChipProps,
      className,
      clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon, {
        fontSize: "small"
      })),
      clearOnBlur = !props.freeSolo,
      clearOnEscape = false,
      clearText = "Clear",
      closeText = "Close",
      componentsProps = {},
      defaultValue = props.multiple ? [] : null,
      disableClearable = false,
      disableCloseOnSelect = false,
      disabled = false,
      disabledItemsFocusable = false,
      disableListWrap = false,
      disablePortal = false,
      filterSelectedOptions = false,
      forcePopupIcon = "auto",
      freeSolo = false,
      fullWidth = false,
      getLimitTagsText = (more) => `+${more}`,
      getOptionLabel: getOptionLabelProp,
      groupBy,
      handleHomeEndKeys = !props.freeSolo,
      includeInputInList = false,
      limitTags = -1,
      ListboxComponent = "ul",
      ListboxProps,
      loading = false,
      loadingText = "Loading…",
      multiple = false,
      noOptionsText = "No options",
      openOnFocus = false,
      openText = "Open",
      PaperComponent = PaperBase,
      PopperComponent = MUIPopper,
      popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, {})),
      readOnly = false,
      renderGroup: renderGroupProp,
      renderInput,
      renderOption: renderOptionProp,
      renderTags,
      selectOnFocus = !props.freeSolo,
      size = "medium",
      slotProps = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$K);
    const {
      getRootProps,
      getInputProps,
      getInputLabelProps,
      getPopupIndicatorProps,
      getClearProps,
      getTagProps,
      getListboxProps,
      getOptionProps,
      value,
      dirty,
      expanded,
      id,
      popupOpen,
      focused,
      focusedTag,
      anchorEl,
      setAnchorEl,
      inputValue,
      groupedOptions
    } = useAutocomplete(_extends({}, props, {
      componentName: "Autocomplete"
    }));
    const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
    const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
    const {
      onMouseDown: handleInputMouseDown
    } = getInputProps();
    const {
      ref: externalListboxRef
    } = ListboxProps != null ? ListboxProps : {};
    const _getListboxProps = getListboxProps(), {
      ref: listboxRef
    } = _getListboxProps, otherListboxProps = _objectWithoutPropertiesLoose(_getListboxProps, _excluded2$7);
    const combinedListboxRef = useForkRef(listboxRef, externalListboxRef);
    const defaultGetOptionLabel2 = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    };
    const getOptionLabel = getOptionLabelProp || defaultGetOptionLabel2;
    const ownerState = _extends({}, props, {
      disablePortal,
      expanded,
      focused,
      fullWidth,
      getOptionLabel,
      hasClearIcon,
      hasPopupIcon,
      inputFocused: focusedTag === -1,
      popupOpen,
      size
    });
    const classes = useUtilityClasses$v(ownerState);
    let startAdornment;
    if (multiple && value.length > 0) {
      const getCustomizedTagProps = (params) => _extends({
        className: classes.tag,
        disabled
      }, getTagProps(params));
      if (renderTags) {
        startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
      } else {
        startAdornment = value.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(MUIChip, _extends({
          label: getOptionLabel(option),
          size
        }, getCustomizedTagProps({
          index
        }), ChipProps)));
      }
    }
    if (limitTags > -1 && Array.isArray(startAdornment)) {
      const more = startAdornment.length - limitTags;
      if (!focused && more > 0) {
        startAdornment = startAdornment.splice(0, limitTags);
        startAdornment.push(/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.tag,
          children: getLimitTagsText(more)
        }, startAdornment.length));
      }
    }
    const defaultRenderGroup = (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
        className: classes.groupLabel,
        ownerState,
        component: "div",
        children: params.group
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
        className: classes.groupUl,
        ownerState,
        children: params.children
      })]
    }, params.key);
    const renderGroup = renderGroupProp || defaultRenderGroup;
    const defaultRenderOption = (props2, option) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", _extends({}, props2, {
      children: getOptionLabel(option)
    }));
    const renderOption = renderOptionProp || defaultRenderOption;
    const renderListOption = (option, index) => {
      const optionProps = getOptionProps({
        option,
        index
      });
      return renderOption(_extends({}, optionProps, {
        className: classes.option
      }), option, {
        selected: optionProps["aria-selected"],
        index,
        inputValue
      }, ownerState);
    };
    const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
    const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
    const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
    const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteRoot, _extends({
        ref,
        className: clsx(classes.root, className),
        ownerState
      }, getRootProps(other), {
        children: renderInput({
          id,
          disabled,
          fullWidth: true,
          size: size === "small" ? "small" : void 0,
          InputLabelProps: getInputLabelProps(),
          InputProps: _extends({
            ref: setAnchorEl,
            className: classes.inputRoot,
            startAdornment,
            onClick: (event) => {
              if (event.target === event.currentTarget) {
                handleInputMouseDown(event);
              }
            }
          }, (hasClearIcon || hasPopupIcon) && {
            endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
              className: classes.endAdornment,
              ownerState,
              children: [hasClearIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends({}, getClearProps(), {
                "aria-label": clearText,
                title: clearText,
                ownerState
              }, clearIndicatorSlotProps, {
                className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
                children: clearIcon
              })) : null, hasPopupIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends({}, getPopupIndicatorProps(), {
                disabled,
                "aria-label": popupOpen ? closeText : openText,
                title: popupOpen ? closeText : openText,
                ownerState
              }, popupIndicatorSlotProps, {
                className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
                children: popupIcon
              })) : null]
            })
          }),
          inputProps: _extends({
            className: classes.input,
            disabled,
            readOnly
          }, getInputProps())
        })
      })), anchorEl ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopper, _extends({
        as: PopperComponent,
        disablePortal,
        style: {
          width: anchorEl ? anchorEl.clientWidth : null
        },
        ownerState,
        role: "presentation",
        anchorEl,
        open: popupOpen
      }, popperSlotProps, {
        className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompletePaper, _extends({
          ownerState,
          as: PaperComponent
        }, paperSlotProps, {
          className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
          children: [loading && groupedOptions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
            className: classes.loading,
            ownerState,
            children: loadingText
          }) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
            className: classes.noOptions,
            ownerState,
            role: "presentation",
            onMouseDown: (event) => {
              event.preventDefault();
            },
            children: noOptionsText
          }) : null, groupedOptions.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteListbox, _extends({
            as: ListboxComponent,
            className: classes.listbox,
            ownerState
          }, otherListboxProps, ListboxProps, {
            ref: combinedListboxRef,
            children: groupedOptions.map((option, index) => {
              if (groupBy) {
                return renderGroup({
                  key: option.key,
                  group: option.group,
                  children: option.options.map((option2, index2) => renderListOption(option2, option.index + index2))
                });
              }
              return renderListOption(option, index);
            })
          })) : null]
        }))
      })) : null]
    });
  });
  const Autocomplete$1 = Autocomplete;
  const _excluded$J = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant"];
  function GridFilterInputMultipleValue(props) {
    const {
      item,
      applyValue,
      type,
      apiRef: apiRef2,
      focusElementRef,
      color: color2,
      error,
      helperText,
      size,
      variant
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$J);
    const TextFieldProps = {
      color: color2,
      error,
      helperText,
      size,
      variant
    };
    const [filterValueState, setFilterValueState] = React__namespace.useState(item.value || []);
    const id = useId();
    const rootProps = useGridRootProps();
    React__namespace.useEffect(() => {
      var _item$value;
      const itemValue = (_item$value = item.value) != null ? _item$value : [];
      setFilterValueState(itemValue.map(String));
    }, [item.value]);
    const handleChange = React__namespace.useCallback((event, value) => {
      setFilterValueState(value.map(String));
      applyValue(_extends({}, item, {
        value: [...value]
      }));
    }, [applyValue, item]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, _extends({
      multiple: true,
      freeSolo: true,
      options: [],
      filterOptions: (options, params) => {
        const {
          inputValue
        } = params;
        return inputValue == null || inputValue === "" ? [] : [inputValue];
      },
      id,
      value: filterValueState,
      onChange: handleChange,
      renderTags: (value, getTagProps) => value.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseChip, _extends({
        variant: "outlined",
        size: "small",
        label: option
      }, getTagProps({
        index
      })))),
      renderInput: (params) => {
        var _rootProps$slotProps;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends({}, params, {
          label: apiRef2.current.getLocaleText("filterPanelInputLabel"),
          placeholder: apiRef2.current.getLocaleText("filterPanelInputPlaceholder"),
          InputLabelProps: _extends({}, params.InputLabelProps, {
            shrink: true
          }),
          inputRef: focusElementRef,
          type: type || "text"
        }, TextFieldProps, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
      }
    }, other));
  }
  const _excluded$I = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant", "getOptionLabel", "getOptionValue"];
  const filter = createFilterOptions();
  function GridFilterInputMultipleSingleSelect(props) {
    var _resolvedColumn, _resolvedColumn2;
    const {
      item,
      applyValue,
      apiRef: apiRef2,
      focusElementRef,
      color: color2,
      error,
      helperText,
      size,
      variant = "standard",
      getOptionLabel: getOptionLabelProp,
      getOptionValue: getOptionValueProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$I);
    const TextFieldProps = {
      color: color2,
      error,
      helperText,
      size,
      variant
    };
    const id = useId();
    const rootProps = useGridRootProps();
    let resolvedColumn = null;
    if (item.field) {
      const column2 = apiRef2.current.getColumn(item.field);
      if (isSingleSelectColDef(column2)) {
        resolvedColumn = column2;
      }
    }
    const getOptionValue = getOptionValueProp || ((_resolvedColumn = resolvedColumn) == null ? void 0 : _resolvedColumn.getOptionValue);
    const getOptionLabel = getOptionLabelProp || ((_resolvedColumn2 = resolvedColumn) == null ? void 0 : _resolvedColumn2.getOptionLabel);
    const isOptionEqualToValue = React__namespace.useCallback((option, value) => getOptionValue(option) === getOptionValue(value), [getOptionValue]);
    const resolvedValueOptions = React__namespace.useMemo(() => {
      var _resolvedColumn3;
      if (!((_resolvedColumn3 = resolvedColumn) != null && _resolvedColumn3.valueOptions)) {
        return [];
      }
      if (typeof resolvedColumn.valueOptions === "function") {
        return resolvedColumn.valueOptions({
          field: resolvedColumn.field
        });
      }
      return resolvedColumn.valueOptions;
    }, [resolvedColumn]);
    const resolvedFormattedValueOptions = React__namespace.useMemo(() => {
      return resolvedValueOptions == null ? void 0 : resolvedValueOptions.map(getOptionValue);
    }, [resolvedValueOptions, getOptionValue]);
    const filteredValues = React__namespace.useMemo(() => {
      if (!Array.isArray(item.value)) {
        return [];
      }
      if (resolvedValueOptions !== void 0) {
        const itemValueIndexes = item.value.map((element) => {
          return resolvedFormattedValueOptions == null ? void 0 : resolvedFormattedValueOptions.findIndex((formattedOption) => formattedOption === element);
        });
        return itemValueIndexes.filter((index) => index >= 0).map((index) => resolvedValueOptions[index]);
      }
      return item.value;
    }, [item.value, resolvedValueOptions, resolvedFormattedValueOptions]);
    React__namespace.useEffect(() => {
      if (!Array.isArray(item.value) || filteredValues.length !== item.value.length) {
        applyValue(_extends({}, item, {
          value: filteredValues.map(getOptionValue)
        }));
      }
    }, [item, filteredValues, applyValue, getOptionValue]);
    const handleChange = React__namespace.useCallback((event, value) => {
      applyValue(_extends({}, item, {
        value: value.map(getOptionValue)
      }));
    }, [applyValue, item, getOptionValue]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, _extends({
      multiple: true,
      options: resolvedValueOptions,
      isOptionEqualToValue,
      filterOptions: filter,
      id,
      value: filteredValues,
      onChange: handleChange,
      getOptionLabel,
      renderTags: (value, getTagProps) => value.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseChip, _extends({
        variant: "outlined",
        size: "small",
        label: getOptionLabel(option)
      }, getTagProps({
        index
      })))),
      renderInput: (params) => {
        var _rootProps$slotProps;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends({}, params, {
          label: apiRef2.current.getLocaleText("filterPanelInputLabel"),
          placeholder: apiRef2.current.getLocaleText("filterPanelInputPlaceholder"),
          InputLabelProps: _extends({}, params.InputLabelProps, {
            shrink: true
          }),
          inputRef: focusElementRef,
          type: "singleSelect"
        }, TextFieldProps, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
      }
    }, other));
  }
  const _excluded$H = ["onClick"];
  const GridToolbarColumnsButton = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbarColumnsButton2(props, ref) {
    var _rootProps$slotProps;
    const {
      onClick
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$H);
    const columnButtonId = useId();
    const columnPanelId = useId();
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const preferencePanel = useGridSelector(apiRef2, gridPreferencePanelStateSelector);
    const showColumns = (event) => {
      if (preferencePanel.open && preferencePanel.openedPanelValue === GridPreferencePanelsValue.columns) {
        apiRef2.current.hidePreferences();
      } else {
        apiRef2.current.showPreferences(GridPreferencePanelsValue.columns, columnPanelId, columnButtonId);
      }
      onClick == null ? void 0 : onClick(event);
    };
    if (rootProps.disableColumnSelector) {
      return null;
    }
    const isOpen = preferencePanel.open && preferencePanel.panelId === columnPanelId;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
      ref,
      id: columnButtonId,
      size: "small",
      "aria-label": apiRef2.current.getLocaleText("toolbarColumnsLabel"),
      "aria-haspopup": "menu",
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? columnPanelId : void 0,
      startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnSelectorIcon, {})
    }, other, {
      onClick: showColumns
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseButton, {
      children: apiRef2.current.getLocaleText("toolbarColumns")
    }));
  });
  const _excluded$G = ["onClick"];
  const GridToolbarDensitySelector = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbarDensitySelector2(props, ref) {
    var _rootProps$slotProps;
    const {
      onClick
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$G);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const densityValue = useGridSelector(apiRef2, gridDensityValueSelector);
    const densityButtonId = useId();
    const densityMenuId = useId();
    const [open, setOpen] = React__namespace.useState(false);
    const buttonRef = React__namespace.useRef(null);
    const handleRef = useForkRef(ref, buttonRef);
    const densityOptions = [{
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.densityCompactIcon, {}),
      label: apiRef2.current.getLocaleText("toolbarDensityCompact"),
      value: "compact"
    }, {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.densityStandardIcon, {}),
      label: apiRef2.current.getLocaleText("toolbarDensityStandard"),
      value: "standard"
    }, {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.densityComfortableIcon, {}),
      label: apiRef2.current.getLocaleText("toolbarDensityComfortable"),
      value: "comfortable"
    }];
    const startIcon = React__namespace.useMemo(() => {
      switch (densityValue) {
        case "compact":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.densityCompactIcon, {});
        case "comfortable":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.densityComfortableIcon, {});
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.densityStandardIcon, {});
      }
    }, [densityValue, rootProps]);
    const handleDensitySelectorOpen = (event) => {
      setOpen((prevOpen) => !prevOpen);
      onClick == null ? void 0 : onClick(event);
    };
    const handleDensitySelectorClickAway = (event) => {
      var _buttonRef$current;
      if (buttonRef.current === event.target || // if user clicked on the icon
      (_buttonRef$current = buttonRef.current) != null && _buttonRef$current.contains(event.target)) {
        return;
      }
      setOpen(false);
    };
    const handleDensityUpdate = (newDensity) => {
      apiRef2.current.setDensity(newDensity);
      setOpen(false);
    };
    const handleListKeyDown = (event) => {
      if (isTabKey(event.key)) {
        event.preventDefault();
      }
      if (isHideMenuKey(event.key)) {
        setOpen(false);
      }
    };
    if (rootProps.disableDensitySelector) {
      return null;
    }
    const densityElements = densityOptions.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(MUIMenuItem, {
      onClick: () => handleDensityUpdate(option.value),
      selected: option.value === densityValue,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
        children: option.icon
      }), option.label]
    }, index));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
        ref: handleRef,
        size: "small",
        startIcon,
        "aria-label": apiRef2.current.getLocaleText("toolbarDensityLabel"),
        "aria-haspopup": "menu",
        "aria-expanded": open,
        "aria-controls": open ? densityMenuId : void 0,
        id: densityButtonId
      }, other, {
        onClick: handleDensitySelectorOpen
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseButton, {
        children: apiRef2.current.getLocaleText("toolbarDensity")
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
        open,
        target: buttonRef.current,
        onClickAway: handleDensitySelectorClickAway,
        position: "bottom-start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList$1, {
          id: densityMenuId,
          className: gridClasses.menuList,
          "aria-labelledby": densityButtonId,
          onKeyDown: handleListKeyDown,
          autoFocusItem: open,
          children: densityElements
        })
      })]
    });
  });
  const _excluded$F = ["componentsProps"];
  const useUtilityClasses$u = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["toolbarFilterList"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridToolbarFilterListRoot = styled$1("ul", {
    name: "MuiDataGrid",
    slot: "ToolbarFilterList",
    overridesResolver: (_props, styles2) => styles2.toolbarFilterList
  })(({
    theme
  }) => ({
    margin: theme.spacing(1, 1, 0.5),
    padding: theme.spacing(0, 1)
  }));
  const GridToolbarFilterButton = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbarFilterButton2(props, ref) {
    var _rootProps$slotProps, _rootProps$slotProps2;
    const {
      componentsProps = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$F);
    const buttonProps = componentsProps.button || {};
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const activeFilters = useGridSelector(apiRef2, gridFilterActiveItemsSelector);
    const lookup = useGridSelector(apiRef2, gridColumnLookupSelector);
    const preferencePanel = useGridSelector(apiRef2, gridPreferencePanelStateSelector);
    const classes = useUtilityClasses$u(rootProps);
    const filterButtonId = useId();
    const filterPanelId = useId();
    const tooltipContentNode = React__namespace.useMemo(() => {
      if (preferencePanel.open) {
        return apiRef2.current.getLocaleText("toolbarFiltersTooltipHide");
      }
      if (activeFilters.length === 0) {
        return apiRef2.current.getLocaleText("toolbarFiltersTooltipShow");
      }
      const getOperatorLabel = (item) => lookup[item.field].filterOperators.find((operator) => operator.value === item.operator).label || apiRef2.current.getLocaleText(`filterOperator${capitalize(item.operator)}`).toString();
      const getFilterItemValue = (item) => {
        const {
          getValueAsString
        } = lookup[item.field].filterOperators.find((operator) => operator.value === item.operator);
        return getValueAsString ? getValueAsString(item.value) : item.value;
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        children: [apiRef2.current.getLocaleText("toolbarFiltersTooltipActive")(activeFilters.length), /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarFilterListRoot, {
          className: classes.root,
          ownerState: rootProps,
          children: activeFilters.map((item, index) => _extends({}, lookup[item.field] && /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
            children: `${lookup[item.field].headerName || item.field}
                  ${getOperatorLabel(item)}
                  ${// implicit check for null and undefined
          item.value != null ? getFilterItemValue(item) : ""}`
          }, index)))
        })]
      });
    }, [apiRef2, rootProps, preferencePanel.open, activeFilters, lookup, classes]);
    const toggleFilter = (event) => {
      var _buttonProps$onClick;
      const {
        open,
        openedPanelValue
      } = preferencePanel;
      if (open && openedPanelValue === GridPreferencePanelsValue.filters) {
        apiRef2.current.hidePreferences();
      } else {
        apiRef2.current.showPreferences(GridPreferencePanelsValue.filters, filterPanelId, filterButtonId);
      }
      (_buttonProps$onClick = buttonProps.onClick) == null ? void 0 : _buttonProps$onClick.call(buttonProps, event);
    };
    if (rootProps.disableColumnFilter) {
      return null;
    }
    const isOpen = preferencePanel.open && preferencePanel.panelId === filterPanelId;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends({
      title: tooltipContentNode,
      enterDelay: 1e3
    }, other, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTooltip, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
        ref,
        id: filterButtonId,
        size: "small",
        "aria-label": apiRef2.current.getLocaleText("toolbarFiltersLabel"),
        "aria-controls": isOpen ? filterPanelId : void 0,
        "aria-expanded": isOpen,
        "aria-haspopup": true,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, {
          badgeContent: activeFilters.length,
          color: "primary",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.openFilterButtonIcon, {})
        })
      }, buttonProps, {
        onClick: toggleFilter
      }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseButton, {
        children: apiRef2.current.getLocaleText("toolbarFilters")
      }))
    }));
  });
  const _excluded$E = ["children", "onClick"];
  const GridToolbarExportContainer = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbarExportContainer2(props, ref) {
    var _rootProps$slotProps;
    const {
      children,
      onClick
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$E);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const exportButtonId = useId();
    const exportMenuId = useId();
    const [open, setOpen] = React__namespace.useState(false);
    const buttonRef = React__namespace.useRef(null);
    const handleRef = useForkRef(ref, buttonRef);
    const handleMenuOpen = (event) => {
      setOpen((prevOpen) => !prevOpen);
      onClick == null ? void 0 : onClick(event);
    };
    const handleMenuClose = () => setOpen(false);
    const handleListKeyDown = (event) => {
      if (isTabKey(event.key)) {
        event.preventDefault();
      }
      if (isHideMenuKey(event.key)) {
        handleMenuClose();
      }
    };
    const handleMenuClickAway = (event) => {
      var _buttonRef$current;
      if (buttonRef.current === event.target || // if user clicked on the icon
      (_buttonRef$current = buttonRef.current) != null && _buttonRef$current.contains(event.target)) {
        return;
      }
      setOpen(false);
    };
    if (children == null) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends({
        ref: handleRef,
        size: "small",
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.exportIcon, {}),
        "aria-expanded": open,
        "aria-label": apiRef2.current.getLocaleText("toolbarExportLabel"),
        "aria-haspopup": "menu",
        "aria-controls": open ? exportMenuId : void 0,
        id: exportButtonId
      }, other, {
        onClick: handleMenuOpen
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseButton, {
        children: apiRef2.current.getLocaleText("toolbarExport")
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
        open,
        target: buttonRef.current,
        onClickAway: handleMenuClickAway,
        position: "bottom-start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList$1, {
          id: exportMenuId,
          className: gridClasses.menuList,
          "aria-labelledby": exportButtonId,
          onKeyDown: handleListKeyDown,
          autoFocusItem: open,
          children: React__namespace.Children.map(children, (child) => {
            if (!/* @__PURE__ */ React__namespace.isValidElement(child)) {
              return child;
            }
            return /* @__PURE__ */ React__namespace.cloneElement(child, {
              hideMenu: handleMenuClose
            });
          })
        })
      })]
    });
  });
  const _excluded$D = ["hideMenu", "options"], _excluded2$6 = ["hideMenu", "options"], _excluded3$1 = ["csvOptions", "printOptions", "excelOptions"];
  function GridCsvExportMenuItem(props) {
    const apiRef2 = useGridApiContext();
    const {
      hideMenu,
      options
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$D);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MUIMenuItem, _extends({
      onClick: () => {
        apiRef2.current.exportDataAsCsv(options);
        hideMenu == null ? void 0 : hideMenu();
      }
    }, other, {
      children: apiRef2.current.getLocaleText("toolbarExportCSV")
    }));
  }
  function GridPrintExportMenuItem(props) {
    const apiRef2 = useGridApiContext();
    const {
      hideMenu,
      options
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded2$6);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MUIMenuItem, _extends({
      onClick: () => {
        apiRef2.current.exportDataAsPrint(options);
        hideMenu == null ? void 0 : hideMenu();
      }
    }, other, {
      children: apiRef2.current.getLocaleText("toolbarExportPrint")
    }));
  }
  const GridToolbarExport = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbarExport2(props, ref) {
    const {
      csvOptions = {},
      printOptions = {},
      excelOptions
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded3$1);
    const apiRef2 = useGridApiContext();
    const preProcessedButtons = apiRef2.current.unstable_applyPipeProcessors("exportMenu", [], {
      excelOptions,
      csvOptions,
      printOptions
    }).sort((a, b2) => a.componentName > b2.componentName ? 1 : -1);
    if (preProcessedButtons.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarExportContainer, _extends({}, other, {
      ref,
      children: preProcessedButtons.map((button, index) => /* @__PURE__ */ React__namespace.cloneElement(button.component, {
        key: index
      }))
    }));
  });
  const _excluded$C = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
  const useUtilityClasses$t = (ownerState) => {
    const {
      classes,
      disableUnderline
    } = ownerState;
    const slots = {
      root: ["root", !disableUnderline && "underline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const InputRoot = styled$1(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
    }
  })(({
    theme,
    ownerState
  }) => {
    const light2 = theme.palette.mode === "light";
    let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    if (theme.vars) {
      bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
    }
    return _extends({
      position: "relative"
    }, ownerState.formControl && {
      "label + &": {
        marginTop: 16
      }
    }, !ownerState.disableUnderline && {
      "&:after": {
        borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: theme.transitions.create("transform", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&.${inputClasses$1.focused}:after`]: {
        // translateX(0) is a workaround for Safari transform scale bug
        // See https://github.com/mui/material-ui/issues/31766
        transform: "scaleX(1) translateX(0)"
      },
      [`&.${inputClasses$1.error}`]: {
        "&:before, &:after": {
          borderBottomColor: (theme.vars || theme).palette.error.main
        }
      },
      "&:before": {
        borderBottom: `1px solid ${bottomLineColor}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: theme.transitions.create("border-bottom-color", {
          duration: theme.transitions.duration.shorter
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
        borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          borderBottom: `1px solid ${bottomLineColor}`
        }
      },
      [`&.${inputClasses$1.disabled}:before`]: {
        borderBottomStyle: "dotted"
      }
    });
  });
  const InputInput = styled$1(InputBaseComponent, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })({});
  const Input = /* @__PURE__ */ React__namespace.forwardRef(function Input2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input;
    const props = useThemeProps({
      props: inProps,
      name: "MuiInput"
    });
    const {
      disableUnderline,
      components = {},
      componentsProps: componentsPropsProp,
      fullWidth = false,
      inputComponent = "input",
      multiline = false,
      slotProps,
      slots = {},
      type = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$C);
    const classes = useUtilityClasses$t(props);
    const ownerState = {
      disableUnderline
    };
    const inputComponentsProps = {
      root: {
        ownerState
      }
    };
    const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends({
      slots: {
        root: RootSlot,
        input: InputSlot
      },
      slotProps: componentsProps,
      fullWidth,
      inputComponent,
      multiline,
      ref,
      type
    }, other, {
      classes
    }));
  });
  Input.muiName = "Input";
  const Input$1 = Input;
  const _excluded$B = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
  const useUtilityClasses$s = (ownerState) => {
    const {
      classes,
      disableUnderline
    } = ownerState;
    const slots = {
      root: ["root", !disableUnderline && "underline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const FilledInputRoot = styled$1(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _palette;
    const light2 = theme.palette.mode === "light";
    const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
    const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
    const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return _extends({
      position: "relative",
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
      borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
      borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        }
      },
      [`&.${filledInputClasses$1.focused}`]: {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      },
      [`&.${filledInputClasses$1.disabled}`]: {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
      }
    }, !ownerState.disableUnderline && {
      "&:after": {
        borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: theme.transitions.create("transform", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&.${filledInputClasses$1.focused}:after`]: {
        // translateX(0) is a workaround for Safari transform scale bug
        // See https://github.com/mui/material-ui/issues/31766
        transform: "scaleX(1) translateX(0)"
      },
      [`&.${filledInputClasses$1.error}`]: {
        "&:before, &:after": {
          borderBottomColor: (theme.vars || theme).palette.error.main
        }
      },
      "&:before": {
        borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: theme.transitions.create("border-bottom-color", {
          duration: theme.transitions.duration.shorter
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
        borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
      },
      [`&.${filledInputClasses$1.disabled}:before`]: {
        borderBottomStyle: "dotted"
      }
    }, ownerState.startAdornment && {
      paddingLeft: 12
    }, ownerState.endAdornment && {
      paddingRight: 12
    }, ownerState.multiline && _extends({
      padding: "25px 12px 8px"
    }, ownerState.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, ownerState.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }));
  });
  const FilledInputInput = styled$1(InputBaseComponent, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })(({
    theme,
    ownerState
  }) => _extends({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12
  }, !theme.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
      caretColor: theme.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  }, theme.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [theme.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }, ownerState.multiline && {
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0
  }, ownerState.startAdornment && {
    paddingLeft: 0
  }, ownerState.endAdornment && {
    paddingRight: 0
  }, ownerState.hiddenLabel && ownerState.size === "small" && {
    paddingTop: 8,
    paddingBottom: 9
  }));
  const FilledInput = /* @__PURE__ */ React__namespace.forwardRef(function FilledInput2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input;
    const props = useThemeProps({
      props: inProps,
      name: "MuiFilledInput"
    });
    const {
      components = {},
      componentsProps: componentsPropsProp,
      fullWidth = false,
      // declare here to prevent spreading to DOM
      inputComponent = "input",
      multiline = false,
      slotProps,
      slots = {},
      type = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$B);
    const ownerState = _extends({}, props, {
      fullWidth,
      inputComponent,
      multiline,
      type
    });
    const classes = useUtilityClasses$s(props);
    const filledInputComponentsProps = {
      root: {
        ownerState
      },
      input: {
        ownerState
      }
    };
    const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends({
      slots: {
        root: RootSlot,
        input: InputSlot
      },
      componentsProps,
      fullWidth,
      inputComponent,
      multiline,
      ref,
      type
    }, other, {
      classes
    }));
  });
  FilledInput.muiName = "Input";
  const FilledInput$1 = FilledInput;
  var _span$3;
  const _excluded$A = ["children", "classes", "className", "label", "notched"];
  const NotchedOutlineRoot$1 = styled$1("fieldset")({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
  });
  const NotchedOutlineLegend = styled$1("legend")(({
    ownerState,
    theme
  }) => _extends({
    float: "unset",
    // Fix conflict with bootstrap
    width: "auto",
    // Fix conflict with bootstrap
    overflow: "hidden"
  }, !ownerState.withLabel && {
    padding: 0,
    lineHeight: "11px",
    // sync with `height` in `legend` styles
    transition: theme.transitions.create("width", {
      duration: 150,
      easing: theme.transitions.easing.easeOut
    })
  }, ownerState.withLabel && _extends({
    display: "block",
    // Fix conflict with normalize.css and sanitize.css
    padding: 0,
    height: 11,
    // sync with `lineHeight` in `legend` styles
    fontSize: "0.75em",
    visibility: "hidden",
    maxWidth: 0.01,
    transition: theme.transitions.create("max-width", {
      duration: 50,
      easing: theme.transitions.easing.easeOut
    }),
    whiteSpace: "nowrap",
    "& > span": {
      paddingLeft: 5,
      paddingRight: 5,
      display: "inline-block",
      opacity: 0,
      visibility: "visible"
    }
  }, ownerState.notched && {
    maxWidth: "100%",
    transition: theme.transitions.create("max-width", {
      duration: 100,
      easing: theme.transitions.easing.easeOut,
      delay: 50
    })
  })));
  function NotchedOutline(props) {
    const {
      className,
      label,
      notched
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$A);
    const withLabel = label != null && label !== "";
    const ownerState = _extends({}, props, {
      notched,
      withLabel
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends({
      "aria-hidden": true,
      className,
      ownerState
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
        ownerState,
        children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          children: label
        }) : (
          // notranslate needed while Google Translate will not fix zero-width space issue
          _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        )
      })
    }));
  }
  const _excluded$z = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
  const useUtilityClasses$r = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const OutlinedInputRoot = styled$1(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: rootOverridesResolver
  })(({
    theme,
    ownerState
  }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return _extends({
      position: "relative",
      borderRadius: (theme.vars || theme).shape.borderRadius,
      [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
        }
      },
      [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette[ownerState.color].main,
        borderWidth: 2
      },
      [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.error.main
      },
      [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.action.disabled
      }
    }, ownerState.startAdornment && {
      paddingLeft: 14
    }, ownerState.endAdornment && {
      paddingRight: 14
    }, ownerState.multiline && _extends({
      padding: "16.5px 14px"
    }, ownerState.size === "small" && {
      padding: "8.5px 14px"
    }));
  });
  const NotchedOutlineRoot = styled$1(NotchedOutline, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (props, styles2) => styles2.notchedOutline
  })(({
    theme
  }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
    };
  });
  const OutlinedInputInput = styled$1(InputBaseComponent, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })(({
    theme,
    ownerState
  }) => _extends({
    padding: "16.5px 14px"
  }, !theme.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
      caretColor: theme.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  }, theme.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [theme.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }, ownerState.multiline && {
    padding: 0
  }, ownerState.startAdornment && {
    paddingLeft: 0
  }, ownerState.endAdornment && {
    paddingRight: 0
  }));
  const OutlinedInput = /* @__PURE__ */ React__namespace.forwardRef(function OutlinedInput2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
    const props = useThemeProps({
      props: inProps,
      name: "MuiOutlinedInput"
    });
    const {
      components = {},
      fullWidth = false,
      inputComponent = "input",
      label,
      multiline = false,
      notched,
      slots = {},
      type = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$z);
    const classes = useUtilityClasses$r(props);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    });
    const ownerState = _extends({}, props, {
      color: fcs.color || "primary",
      disabled: fcs.disabled,
      error: fcs.error,
      focused: fcs.focused,
      formControl: muiFormControl,
      fullWidth,
      hiddenLabel: fcs.hiddenLabel,
      multiline,
      size: fcs.size,
      type
    });
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends({
      slots: {
        root: RootSlot,
        input: InputSlot
      },
      renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
        ownerState,
        className: classes.notchedOutline,
        label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
          children: [label, " ", "*"]
        })) : label,
        notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
      }),
      fullWidth,
      inputComponent,
      multiline,
      ref,
      type
    }, other, {
      classes: _extends({}, classes, {
        notchedOutline: null
      })
    }));
  });
  OutlinedInput.muiName = "Input";
  const OutlinedInput$1 = OutlinedInput;
  function getFormLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiFormLabel", slot);
  }
  const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
  const formLabelClasses$1 = formLabelClasses;
  const _excluded$y = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
  const useUtilityClasses$q = (ownerState) => {
    const {
      classes,
      color: color2,
      focused,
      disabled,
      error,
      filled,
      required
    } = ownerState;
    const slots = {
      root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
      asterisk: ["asterisk", error && "error"]
    };
    return composeClasses(slots, getFormLabelUtilityClasses, classes);
  };
  const FormLabelRoot = styled$1("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({
      ownerState
    }, styles2) => {
      return _extends({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    color: (theme.vars || theme).palette.text.secondary
  }, theme.typography.body1, {
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    [`&.${formLabelClasses$1.focused}`]: {
      color: (theme.vars || theme).palette[ownerState.color].main
    },
    [`&.${formLabelClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    },
    [`&.${formLabelClasses$1.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }));
  const AsteriskComponent = styled$1("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (props, styles2) => styles2.asterisk
  })(({
    theme
  }) => ({
    [`&.${formLabelClasses$1.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }));
  const FormLabel = /* @__PURE__ */ React__namespace.forwardRef(function FormLabel2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiFormLabel"
    });
    const {
      children,
      className,
      component = "label"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$y);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["color", "required", "focused", "disabled", "error", "filled"]
    });
    const ownerState = _extends({}, props, {
      color: fcs.color || "primary",
      component,
      disabled: fcs.disabled,
      error: fcs.error,
      filled: fcs.filled,
      focused: fcs.focused,
      required: fcs.required
    });
    const classes = useUtilityClasses$q(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
        ownerState,
        "aria-hidden": true,
        className: classes.asterisk,
        children: [" ", "*"]
      })]
    }));
  });
  const FormLabel$1 = FormLabel;
  function getInputLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiInputLabel", slot);
  }
  generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
  const _excluded$x = ["disableAnimation", "margin", "shrink", "variant", "className"];
  const useUtilityClasses$p = (ownerState) => {
    const {
      classes,
      formControl,
      size,
      shrink,
      disableAnimation,
      variant,
      required
    } = ownerState;
    const slots = {
      root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size === "small" && "sizeSmall", variant],
      asterisk: [required && "asterisk"]
    };
    const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
    return _extends({}, classes, composedClasses);
  };
  const InputLabelRoot = styled$1(FormLabel$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
      }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, styles2[ownerState.variant]];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    display: "block",
    transformOrigin: "top left",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    maxWidth: "100%"
  }, ownerState.formControl && {
    position: "absolute",
    left: 0,
    top: 0,
    // slight alteration to spec spacing to match visual spec result
    transform: "translate(0, 20px) scale(1)"
  }, ownerState.size === "small" && {
    // Compensation for the `Input.inputSizeSmall` style.
    transform: "translate(0, 17px) scale(1)"
  }, ownerState.shrink && {
    transform: "translate(0, -1.5px) scale(0.75)",
    transformOrigin: "top left",
    maxWidth: "133%"
  }, !ownerState.disableAnimation && {
    transition: theme.transitions.create(["color", "transform", "max-width"], {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    })
  }, ownerState.variant === "filled" && _extends({
    // Chrome's autofill feature gives the input field a yellow background.
    // Since the input field is behind the label in the HTML tree,
    // the input field is drawn last and hides the label with an opaque background color.
    // zIndex: 1 will raise the label above opaque background-colors of input.
    zIndex: 1,
    pointerEvents: "none",
    transform: "translate(12px, 16px) scale(1)",
    maxWidth: "calc(100% - 24px)"
  }, ownerState.size === "small" && {
    transform: "translate(12px, 13px) scale(1)"
  }, ownerState.shrink && _extends({
    userSelect: "none",
    pointerEvents: "auto",
    transform: "translate(12px, 7px) scale(0.75)",
    maxWidth: "calc(133% - 24px)"
  }, ownerState.size === "small" && {
    transform: "translate(12px, 4px) scale(0.75)"
  })), ownerState.variant === "outlined" && _extends({
    // see comment above on filled.zIndex
    zIndex: 1,
    pointerEvents: "none",
    transform: "translate(14px, 16px) scale(1)",
    maxWidth: "calc(100% - 24px)"
  }, ownerState.size === "small" && {
    transform: "translate(14px, 9px) scale(1)"
  }, ownerState.shrink && {
    userSelect: "none",
    pointerEvents: "auto",
    // Theoretically, we should have (8+5)*2/0.75 = 34px
    // but it feels a better when it bleeds a bit on the left, so 32px.
    maxWidth: "calc(133% - 32px)",
    transform: "translate(14px, -9px) scale(0.75)"
  })));
  const InputLabel = /* @__PURE__ */ React__namespace.forwardRef(function InputLabel2(inProps, ref) {
    const props = useThemeProps({
      name: "MuiInputLabel",
      props: inProps
    });
    const {
      disableAnimation = false,
      shrink: shrinkProp,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$x);
    const muiFormControl = useFormControl();
    let shrink = shrinkProp;
    if (typeof shrink === "undefined" && muiFormControl) {
      shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
    }
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["size", "variant", "required"]
    });
    const ownerState = _extends({}, props, {
      disableAnimation,
      formControl: muiFormControl,
      shrink,
      size: fcs.size,
      variant: fcs.variant,
      required: fcs.required
    });
    const classes = useUtilityClasses$p(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends({
      "data-shrink": shrink,
      ownerState,
      ref,
      className: clsx(classes.root, className)
    }, other, {
      classes
    }));
  });
  const MUIInputLabel = InputLabel;
  function getFormHelperTextUtilityClasses(slot) {
    return generateUtilityClass("MuiFormHelperText", slot);
  }
  const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
  const formHelperTextClasses$1 = formHelperTextClasses;
  var _span$2;
  const _excluded$w = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
  const useUtilityClasses$o = (ownerState) => {
    const {
      classes,
      contained,
      size,
      disabled,
      error,
      filled,
      focused,
      required
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
    };
    return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
  };
  const FormHelperTextRoot = styled$1("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    color: (theme.vars || theme).palette.text.secondary
  }, theme.typography.caption, {
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${formHelperTextClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    },
    [`&.${formHelperTextClasses$1.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }, ownerState.size === "small" && {
    marginTop: 4
  }, ownerState.contained && {
    marginLeft: 14,
    marginRight: 14
  }));
  const FormHelperText = /* @__PURE__ */ React__namespace.forwardRef(function FormHelperText2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiFormHelperText"
    });
    const {
      children,
      className,
      component = "p"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
    });
    const ownerState = _extends({}, props, {
      component,
      contained: fcs.variant === "filled" || fcs.variant === "outlined",
      variant: fcs.variant,
      size: fcs.size,
      disabled: fcs.disabled,
      error: fcs.error,
      filled: fcs.filled,
      focused: fcs.focused,
      required: fcs.required
    });
    const classes = useUtilityClasses$o(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children: children === " " ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : children
    }));
  });
  const FormHelperText$1 = FormHelperText;
  function getPopoverUtilityClass(slot) {
    return generateUtilityClass("MuiPopover", slot);
  }
  generateUtilityClasses("MuiPopover", ["root", "paper"]);
  const _excluded$v = ["onEntering"], _excluded2$5 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"], _excluded3 = ["slotProps"];
  function getOffsetTop(rect, vertical) {
    let offset2 = 0;
    if (typeof vertical === "number") {
      offset2 = vertical;
    } else if (vertical === "center") {
      offset2 = rect.height / 2;
    } else if (vertical === "bottom") {
      offset2 = rect.height;
    }
    return offset2;
  }
  function getOffsetLeft(rect, horizontal) {
    let offset2 = 0;
    if (typeof horizontal === "number") {
      offset2 = horizontal;
    } else if (horizontal === "center") {
      offset2 = rect.width / 2;
    } else if (horizontal === "right") {
      offset2 = rect.width;
    }
    return offset2;
  }
  function getTransformOriginValue(transformOrigin2) {
    return [transformOrigin2.horizontal, transformOrigin2.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
  }
  function resolveAnchorEl(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
  }
  const useUtilityClasses$n = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"]
    };
    return composeClasses(slots, getPopoverUtilityClass, classes);
  };
  const PopoverRoot = styled$1(Modal$1, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const PopoverPaper = styled$1(PaperBase, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  });
  const Popover = /* @__PURE__ */ React__namespace.forwardRef(function Popover2(inProps, ref) {
    var _slotProps$paper, _slots$root, _slots$paper;
    const props = useThemeProps({
      props: inProps,
      name: "MuiPopover"
    });
    const {
      action,
      anchorEl,
      anchorOrigin = {
        vertical: "top",
        horizontal: "left"
      },
      anchorPosition,
      anchorReference = "anchorEl",
      children,
      className,
      container: containerProp,
      elevation = 8,
      marginThreshold = 16,
      open,
      PaperProps: PaperPropsProp = {},
      slots,
      slotProps,
      transformOrigin: transformOrigin2 = {
        vertical: "top",
        horizontal: "left"
      },
      TransitionComponent = Grow$1,
      transitionDuration: transitionDurationProp = "auto",
      TransitionProps: {
        onEntering
      } = {}
    } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$v), other = _objectWithoutPropertiesLoose(props, _excluded2$5);
    const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
    const paperRef = React__namespace.useRef();
    const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
    const ownerState = _extends({}, props, {
      anchorOrigin,
      anchorReference,
      elevation,
      marginThreshold,
      externalPaperSlotProps,
      transformOrigin: transformOrigin2,
      TransitionComponent,
      transitionDuration: transitionDurationProp,
      TransitionProps
    });
    const classes = useUtilityClasses$n(ownerState);
    const getAnchorOffset = React__namespace.useCallback(() => {
      if (anchorReference === "anchorPosition") {
        return anchorPosition;
      }
      const resolvedAnchorEl = resolveAnchorEl(anchorEl);
      const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
      const anchorRect = anchorElement.getBoundingClientRect();
      return {
        top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
        left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
      };
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
    const getTransformOrigin = React__namespace.useCallback((elemRect) => {
      return {
        vertical: getOffsetTop(elemRect, transformOrigin2.vertical),
        horizontal: getOffsetLeft(elemRect, transformOrigin2.horizontal)
      };
    }, [transformOrigin2.horizontal, transformOrigin2.vertical]);
    const getPositioningStyle = React__namespace.useCallback((element) => {
      const elemRect = {
        width: element.offsetWidth,
        height: element.offsetHeight
      };
      const elemTransformOrigin = getTransformOrigin(elemRect);
      if (anchorReference === "none") {
        return {
          top: null,
          left: null,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      }
      const anchorOffset = getAnchorOffset();
      let top2 = anchorOffset.top - elemTransformOrigin.vertical;
      let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
      const bottom2 = top2 + elemRect.height;
      const right2 = left2 + elemRect.width;
      const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
      const heightThreshold = containerWindow.innerHeight - marginThreshold;
      const widthThreshold = containerWindow.innerWidth - marginThreshold;
      if (top2 < marginThreshold) {
        const diff = top2 - marginThreshold;
        top2 -= diff;
        elemTransformOrigin.vertical += diff;
      } else if (bottom2 > heightThreshold) {
        const diff = bottom2 - heightThreshold;
        top2 -= diff;
        elemTransformOrigin.vertical += diff;
      }
      if (left2 < marginThreshold) {
        const diff = left2 - marginThreshold;
        left2 -= diff;
        elemTransformOrigin.horizontal += diff;
      } else if (right2 > widthThreshold) {
        const diff = right2 - widthThreshold;
        left2 -= diff;
        elemTransformOrigin.horizontal += diff;
      }
      return {
        top: `${Math.round(top2)}px`,
        left: `${Math.round(left2)}px`,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
    const [isPositioned, setIsPositioned] = React__namespace.useState(open);
    const setPositioningStyles = React__namespace.useCallback(() => {
      const element = paperRef.current;
      if (!element) {
        return;
      }
      const positioning = getPositioningStyle(element);
      if (positioning.top !== null) {
        element.style.top = positioning.top;
      }
      if (positioning.left !== null) {
        element.style.left = positioning.left;
      }
      element.style.transformOrigin = positioning.transformOrigin;
      setIsPositioned(true);
    }, [getPositioningStyle]);
    const handleEntering = (element, isAppearing) => {
      if (onEntering) {
        onEntering(element, isAppearing);
      }
      setPositioningStyles();
    };
    const handleExited = () => {
      setIsPositioned(false);
    };
    React__namespace.useEffect(() => {
      if (open) {
        setPositioningStyles();
      }
    });
    React__namespace.useImperativeHandle(action, () => open ? {
      updatePosition: () => {
        setPositioningStyles();
      }
    } : null, [open, setPositioningStyles]);
    React__namespace.useEffect(() => {
      if (!open) {
        return void 0;
      }
      const handleResize = debounce$1(() => {
        setPositioningStyles();
      });
      const containerWindow = ownerWindow(anchorEl);
      containerWindow.addEventListener("resize", handleResize);
      return () => {
        handleResize.clear();
        containerWindow.removeEventListener("resize", handleResize);
      };
    }, [anchorEl, open, setPositioningStyles]);
    let transitionDuration = transitionDurationProp;
    if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
      transitionDuration = void 0;
    }
    const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
    const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
    const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
    const paperProps = useSlotProps({
      elementType: PaperSlot,
      externalSlotProps: _extends({}, externalPaperSlotProps, {
        style: isPositioned ? externalPaperSlotProps.style : _extends({}, externalPaperSlotProps.style, {
          opacity: 0
        })
      }),
      additionalProps: {
        elevation,
        ref: handlePaperRef
      },
      ownerState,
      className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
    });
    const _useSlotProps = useSlotProps({
      elementType: RootSlot,
      externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
      externalForwardedProps: other,
      additionalProps: {
        ref,
        slotProps: {
          backdrop: {
            invisible: true
          }
        },
        container,
        open
      },
      ownerState,
      className: clsx(classes.root, className)
    }), {
      slotProps: rootSlotPropsProp
    } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded3);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends({}, rootProps, !isHostComponent(RootSlot) && {
      slotProps: rootSlotPropsProp
    }, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
        appear: true,
        in: open,
        onEntering: handleEntering,
        onExited: handleExited,
        timeout: transitionDuration
      }, TransitionProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends({}, paperProps, {
          children
        }))
      }))
    }));
  });
  const Popover$1 = Popover;
  function getMenuUtilityClass(slot) {
    return generateUtilityClass("MuiMenu", slot);
  }
  generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
  const _excluded$u = ["onEntering"], _excluded2$4 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
  const RTL_ORIGIN = {
    vertical: "top",
    horizontal: "right"
  };
  const LTR_ORIGIN = {
    vertical: "top",
    horizontal: "left"
  };
  const useUtilityClasses$m = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"],
      list: ["list"]
    };
    return composeClasses(slots, getMenuUtilityClass, classes);
  };
  const MenuRoot = styled$1(Popover$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const MenuPaper = styled$1(PopoverPaper, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch"
  });
  const MenuMenuList = styled$1(MenuList$1, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (props, styles2) => styles2.list
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  });
  const Menu = /* @__PURE__ */ React__namespace.forwardRef(function Menu2(inProps, ref) {
    var _slots$paper, _slotProps$paper;
    const props = useThemeProps({
      props: inProps,
      name: "MuiMenu"
    });
    const {
      autoFocus = true,
      children,
      className,
      disableAutoFocusItem = false,
      MenuListProps = {},
      onClose,
      open,
      PaperProps = {},
      PopoverClasses,
      transitionDuration = "auto",
      TransitionProps: {
        onEntering
      } = {},
      variant = "selectedMenu",
      slots = {},
      slotProps = {}
    } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$u), other = _objectWithoutPropertiesLoose(props, _excluded2$4);
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const ownerState = _extends({}, props, {
      autoFocus,
      disableAutoFocusItem,
      MenuListProps,
      onEntering,
      PaperProps,
      transitionDuration,
      TransitionProps,
      variant
    });
    const classes = useUtilityClasses$m(ownerState);
    const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
    const menuListActionsRef = React__namespace.useRef(null);
    const handleEntering = (element, isAppearing) => {
      if (menuListActionsRef.current) {
        menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
      }
      if (onEntering) {
        onEntering(element, isAppearing);
      }
    };
    const handleListKeyDown = (event) => {
      if (event.key === "Tab") {
        event.preventDefault();
        if (onClose) {
          onClose(event, "tabKeyDown");
        }
      }
    };
    let activeItemIndex = -1;
    React__namespace.Children.map(children, (child, index) => {
      if (!/* @__PURE__ */ React__namespace.isValidElement(child)) {
        return;
      }
      if (!child.props.disabled) {
        if (variant === "selectedMenu" && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
    });
    const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
    const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
    const rootSlotProps = useSlotProps({
      elementType: slots.root,
      externalSlotProps: slotProps.root,
      ownerState,
      className: [classes.root, className]
    });
    const paperSlotProps = useSlotProps({
      elementType: PaperSlot,
      externalSlotProps: paperExternalSlotProps,
      ownerState,
      className: classes.paper
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends({
      onClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: isRtl ? "right" : "left"
      },
      transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
      slots: {
        paper: PaperSlot,
        root: slots.root
      },
      slotProps: {
        root: rootSlotProps,
        paper: paperSlotProps
      },
      open,
      ref,
      transitionDuration,
      TransitionProps: _extends({
        onEntering: handleEntering
      }, TransitionProps),
      ownerState
    }, other, {
      classes: PopoverClasses,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends({
        onKeyDown: handleListKeyDown,
        actions: menuListActionsRef,
        autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
        autoFocusItem,
        variant
      }, MenuListProps, {
        className: clsx(classes.list, MenuListProps.className),
        children
      }))
    }));
  });
  const Menu$1 = Menu;
  function getNativeSelectUtilityClasses(slot) {
    return generateUtilityClass("MuiNativeSelect", slot);
  }
  const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  const nativeSelectClasses$1 = nativeSelectClasses;
  const _excluded$t = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
  const useUtilityClasses$l = (ownerState) => {
    const {
      classes,
      variant,
      disabled,
      multiple,
      open,
      error
    } = ownerState;
    const slots = {
      select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
      icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
    };
    return composeClasses(slots, getNativeSelectUtilityClasses, classes);
  };
  const nativeSelectSelectStyles = ({
    ownerState,
    theme
  }) => _extends({
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    // When interacting quickly, the text can end up selected.
    // Native select can't be selected either.
    userSelect: "none",
    borderRadius: 0,
    // Reset
    cursor: "pointer",
    "&:focus": _extends({}, theme.vars ? {
      backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
    } : {
      backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }, {
      borderRadius: 0
      // Reset Chrome style
    }),
    // Remove IE11 arrow
    "&::-ms-expand": {
      display: "none"
    },
    [`&.${nativeSelectClasses$1.disabled}`]: {
      cursor: "default"
    },
    "&[multiple]": {
      height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (theme.vars || theme).palette.background.paper
    },
    // Bump specificity to allow extending custom inputs
    "&&&": {
      paddingRight: 24,
      minWidth: 16
      // So it doesn't collapse.
    }
  }, ownerState.variant === "filled" && {
    "&&&": {
      paddingRight: 32
    }
  }, ownerState.variant === "outlined" && {
    borderRadius: (theme.vars || theme).shape.borderRadius,
    "&:focus": {
      borderRadius: (theme.vars || theme).shape.borderRadius
      // Reset the reset for Chrome style
    },
    "&&&": {
      paddingRight: 32
    }
  });
  const NativeSelectSelect = styled$1("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: rootShouldForwardProp,
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
        [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
      }];
    }
  })(nativeSelectSelectStyles);
  const nativeSelectIconStyles = ({
    ownerState,
    theme
  }) => _extends({
    // We use a position absolute over a flexbox in order to forward the pointer events
    // to the input and to support wrapping tags..
    position: "absolute",
    right: 0,
    top: "calc(50% - .5em)",
    // Center vertically, height is 1em
    pointerEvents: "none",
    // Don't block pointer events on the select under the icon.
    color: (theme.vars || theme).palette.action.active,
    [`&.${nativeSelectClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    }
  }, ownerState.open && {
    transform: "rotate(180deg)"
  }, ownerState.variant === "filled" && {
    right: 7
  }, ownerState.variant === "outlined" && {
    right: 7
  });
  const NativeSelectIcon = styled$1("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
    }
  })(nativeSelectIconStyles);
  const NativeSelectInput = /* @__PURE__ */ React__namespace.forwardRef(function NativeSelectInput2(props, ref) {
    const {
      className,
      disabled,
      error,
      IconComponent,
      inputRef,
      variant = "standard"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$t);
    const ownerState = _extends({}, props, {
      disabled,
      variant,
      error
    });
    const classes = useUtilityClasses$l(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends({
        ownerState,
        className: clsx(classes.select, className),
        disabled,
        ref: inputRef || ref
      }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
        as: IconComponent,
        ownerState,
        className: classes.icon
      })]
    });
  });
  const NativeSelectInput$1 = NativeSelectInput;
  function getSelectUtilityClasses(slot) {
    return generateUtilityClass("MuiSelect", slot);
  }
  const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  const selectClasses$1 = selectClasses;
  var _span$1;
  const _excluded$s = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
  const SelectSelect = styled$1("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [
        // Win specificity over the input base
        {
          [`&.${selectClasses$1.select}`]: styles2.select
        },
        {
          [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
        },
        {
          [`&.${selectClasses$1.error}`]: styles2.error
        },
        {
          [`&.${selectClasses$1.multiple}`]: styles2.multiple
        }
      ];
    }
  })(nativeSelectSelectStyles, {
    // Win specificity over the input base
    [`&.${selectClasses$1.select}`]: {
      height: "auto",
      // Resets for multiple select with chips
      minHeight: "1.4375em",
      // Required for select\text-field height consistency
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    }
  });
  const SelectIcon = styled$1("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
    }
  })(nativeSelectIconStyles);
  const SelectNativeInput = styled$1("input", {
    shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (props, styles2) => styles2.nativeInput
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
  });
  function areEqualValues(a, b2) {
    if (typeof b2 === "object" && b2 !== null) {
      return a === b2;
    }
    return String(a) === String(b2);
  }
  function isEmpty(display) {
    return display == null || typeof display === "string" && !display.trim();
  }
  const useUtilityClasses$k = (ownerState) => {
    const {
      classes,
      variant,
      disabled,
      multiple,
      open,
      error
    } = ownerState;
    const slots = {
      select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
      icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
      nativeInput: ["nativeInput"]
    };
    return composeClasses(slots, getSelectUtilityClasses, classes);
  };
  const SelectInput = /* @__PURE__ */ React__namespace.forwardRef(function SelectInput2(props, ref) {
    const {
      "aria-describedby": ariaDescribedby,
      "aria-label": ariaLabel,
      autoFocus,
      autoWidth,
      children,
      className,
      defaultOpen,
      defaultValue,
      disabled,
      displayEmpty,
      error = false,
      IconComponent,
      inputRef: inputRefProp,
      labelId,
      MenuProps = {},
      multiple,
      name,
      onBlur,
      onChange,
      onClose,
      onFocus,
      onOpen,
      open: openProp,
      readOnly,
      renderValue,
      SelectDisplayProps = {},
      tabIndex: tabIndexProp,
      value: valueProp,
      variant = "standard"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$s);
    const [value, setValueState] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "Select"
    });
    const [openState, setOpenState] = useControlled({
      controlled: openProp,
      default: defaultOpen,
      name: "Select"
    });
    const inputRef = React__namespace.useRef(null);
    const displayRef = React__namespace.useRef(null);
    const [displayNode, setDisplayNode] = React__namespace.useState(null);
    const {
      current: isOpenControlled
    } = React__namespace.useRef(openProp != null);
    const [menuMinWidthState, setMenuMinWidthState] = React__namespace.useState();
    const handleRef = useForkRef(ref, inputRefProp);
    const handleDisplayRef = React__namespace.useCallback((node2) => {
      displayRef.current = node2;
      if (node2) {
        setDisplayNode(node2);
      }
    }, []);
    const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
    React__namespace.useImperativeHandle(handleRef, () => ({
      focus: () => {
        displayRef.current.focus();
      },
      node: inputRef.current,
      value
    }), [value]);
    React__namespace.useEffect(() => {
      if (defaultOpen && openState && displayNode && !isOpenControlled) {
        setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
        displayRef.current.focus();
      }
    }, [displayNode, autoWidth]);
    React__namespace.useEffect(() => {
      if (autoFocus) {
        displayRef.current.focus();
      }
    }, [autoFocus]);
    React__namespace.useEffect(() => {
      if (!labelId) {
        return void 0;
      }
      const label = ownerDocument(displayRef.current).getElementById(labelId);
      if (label) {
        const handler = () => {
          if (getSelection().isCollapsed) {
            displayRef.current.focus();
          }
        };
        label.addEventListener("click", handler);
        return () => {
          label.removeEventListener("click", handler);
        };
      }
      return void 0;
    }, [labelId]);
    const update = (open2, event) => {
      if (open2) {
        if (onOpen) {
          onOpen(event);
        }
      } else if (onClose) {
        onClose(event);
      }
      if (!isOpenControlled) {
        setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
        setOpenState(open2);
      }
    };
    const handleMouseDown = (event) => {
      if (event.button !== 0) {
        return;
      }
      event.preventDefault();
      displayRef.current.focus();
      update(true, event);
    };
    const handleClose = (event) => {
      update(false, event);
    };
    const childrenArray = React__namespace.Children.toArray(children);
    const handleChange = (event) => {
      const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
      if (child === void 0) {
        return;
      }
      setValueState(child.props.value);
      if (onChange) {
        onChange(event, child);
      }
    };
    const handleItemClick = (child) => (event) => {
      let newValue;
      if (!event.currentTarget.hasAttribute("tabindex")) {
        return;
      }
      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];
        const itemIndex = value.indexOf(child.props.value);
        if (itemIndex === -1) {
          newValue.push(child.props.value);
        } else {
          newValue.splice(itemIndex, 1);
        }
      } else {
        newValue = child.props.value;
      }
      if (child.props.onClick) {
        child.props.onClick(event);
      }
      if (value !== newValue) {
        setValueState(newValue);
        if (onChange) {
          const nativeEvent = event.nativeEvent || event;
          const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
          Object.defineProperty(clonedEvent, "target", {
            writable: true,
            value: {
              value: newValue,
              name
            }
          });
          onChange(clonedEvent, child);
        }
      }
      if (!multiple) {
        update(false, event);
      }
    };
    const handleKeyDown2 = (event) => {
      if (!readOnly) {
        const validKeys = [
          " ",
          "ArrowUp",
          "ArrowDown",
          // The native select doesn't respond to enter on macOS, but it's recommended by
          // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
          "Enter"
        ];
        if (validKeys.indexOf(event.key) !== -1) {
          event.preventDefault();
          update(true, event);
        }
      }
    };
    const open = displayNode !== null && openState;
    const handleBlur = (event) => {
      if (!open && onBlur) {
        Object.defineProperty(event, "target", {
          writable: true,
          value: {
            value,
            name
          }
        });
        onBlur(event);
      }
    };
    delete other["aria-invalid"];
    let display;
    let displaySingle;
    const displayMultiple = [];
    let computeDisplay = false;
    if (isFilled({
      value
    }) || displayEmpty) {
      if (renderValue) {
        display = renderValue(value);
      } else {
        computeDisplay = true;
      }
    }
    const items2 = childrenArray.map((child) => {
      if (!/* @__PURE__ */ React__namespace.isValidElement(child)) {
        return null;
      }
      let selected;
      if (multiple) {
        if (!Array.isArray(value)) {
          throw new Error(formatMuiErrorMessage(2));
        }
        selected = value.some((v2) => areEqualValues(v2, child.props.value));
        if (selected && computeDisplay) {
          displayMultiple.push(child.props.children);
        }
      } else {
        selected = areEqualValues(value, child.props.value);
        if (selected && computeDisplay) {
          displaySingle = child.props.children;
        }
      }
      return /* @__PURE__ */ React__namespace.cloneElement(child, {
        "aria-selected": selected ? "true" : "false",
        onClick: handleItemClick(child),
        onKeyUp: (event) => {
          if (event.key === " ") {
            event.preventDefault();
          }
          if (child.props.onKeyUp) {
            child.props.onKeyUp(event);
          }
        },
        role: "option",
        selected,
        value: void 0,
        // The value is most likely not a valid HTML attribute.
        "data-value": child.props.value
        // Instead, we provide it as a data attribute.
      });
    });
    if (computeDisplay) {
      if (multiple) {
        if (displayMultiple.length === 0) {
          display = null;
        } else {
          display = displayMultiple.reduce((output, child, index) => {
            output.push(child);
            if (index < displayMultiple.length - 1) {
              output.push(", ");
            }
            return output;
          }, []);
        }
      } else {
        display = displaySingle;
      }
    }
    let menuMinWidth = menuMinWidthState;
    if (!autoWidth && isOpenControlled && displayNode) {
      menuMinWidth = anchorElement.clientWidth;
    }
    let tabIndex;
    if (typeof tabIndexProp !== "undefined") {
      tabIndex = tabIndexProp;
    } else {
      tabIndex = disabled ? null : 0;
    }
    const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
    const ownerState = _extends({}, props, {
      variant,
      value,
      open,
      error
    });
    const classes = useUtilityClasses$k(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends({
        ref: handleDisplayRef,
        tabIndex,
        role: "button",
        "aria-disabled": disabled ? "true" : void 0,
        "aria-expanded": open ? "true" : "false",
        "aria-haspopup": "listbox",
        "aria-label": ariaLabel,
        "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
        "aria-describedby": ariaDescribedby,
        onKeyDown: handleKeyDown2,
        onMouseDown: disabled || readOnly ? null : handleMouseDown,
        onBlur: handleBlur,
        onFocus
      }, SelectDisplayProps, {
        ownerState,
        className: clsx(SelectDisplayProps.className, classes.select, className),
        id: buttonId,
        children: isEmpty(display) ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : display
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends({
        "aria-invalid": error,
        value: Array.isArray(value) ? value.join(",") : value,
        name,
        ref: inputRef,
        "aria-hidden": true,
        onChange: handleChange,
        tabIndex: -1,
        disabled,
        className: classes.nativeInput,
        autoFocus,
        ownerState
      }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
        as: IconComponent,
        className: classes.icon,
        ownerState
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends({
        id: `menu-${name || ""}`,
        anchorEl: anchorElement,
        open,
        onClose: handleClose,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "center"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "center"
        }
      }, MenuProps, {
        MenuListProps: _extends({
          "aria-labelledby": labelId,
          role: "listbox",
          disableListWrap: true
        }, MenuProps.MenuListProps),
        PaperProps: _extends({}, MenuProps.PaperProps, {
          style: _extends({
            minWidth: menuMinWidth
          }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
        }),
        children: items2
      }))]
    });
  });
  const SelectInput$1 = SelectInput;
  const _excluded$r = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2$3 = ["root"];
  const useUtilityClasses$j = (ownerState) => {
    const {
      classes
    } = ownerState;
    return classes;
  };
  const styledRootConfig = {
    name: "MuiSelect",
    overridesResolver: (props, styles2) => styles2.root,
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
    slot: "Root"
  };
  const StyledInput = styled$1(Input$1, styledRootConfig)("");
  const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
  const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
  const Select = /* @__PURE__ */ React__namespace.forwardRef(function Select2(inProps, ref) {
    const props = useThemeProps({
      name: "MuiSelect",
      props: inProps
    });
    const {
      autoWidth = false,
      children,
      classes: classesProp = {},
      className,
      defaultOpen = false,
      displayEmpty = false,
      IconComponent = ArrowDropDownIcon,
      id,
      input,
      inputProps,
      label,
      labelId,
      MenuProps,
      multiple = false,
      native = false,
      onClose,
      onOpen,
      open,
      renderValue,
      SelectDisplayProps,
      variant: variantProp = "outlined"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$r);
    const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["variant", "error"]
    });
    const variant = fcs.variant || variantProp;
    const ownerState = _extends({}, props, {
      variant,
      classes: classesProp
    });
    const classes = useUtilityClasses$j(ownerState);
    const restOfClasses = _objectWithoutPropertiesLoose(classes, _excluded2$3);
    const InputComponent = input || {
      standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
        ownerState
      }),
      outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
        label,
        ownerState
      }),
      filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
        ownerState
      })
    }[variant];
    const inputComponentRef = useForkRef(ref, InputComponent.ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React__namespace.Fragment, {
      children: /* @__PURE__ */ React__namespace.cloneElement(InputComponent, _extends({
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent,
        inputProps: _extends({
          children,
          error: fcs.error,
          IconComponent,
          variant,
          type: void 0,
          // We render a select. We can ignore the type provided by the `Input`.
          multiple
        }, native ? {
          id
        } : {
          autoWidth,
          defaultOpen,
          displayEmpty,
          labelId,
          MenuProps,
          onClose,
          onOpen,
          open,
          renderValue,
          SelectDisplayProps: _extends({
            id
          }, SelectDisplayProps)
        }, inputProps, {
          classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
        }, input ? input.props.inputProps : {})
      }, multiple && native && variant === "outlined" ? {
        notched: true
      } : {}, {
        ref: inputComponentRef,
        className: clsx(InputComponent.props.className, className, classes.root)
      }, !input && {
        variant
      }, other))
    });
  });
  Select.muiName = "Select";
  const MUISelect = Select;
  function getTextFieldUtilityClass(slot) {
    return generateUtilityClass("MuiTextField", slot);
  }
  generateUtilityClasses("MuiTextField", ["root"]);
  const _excluded$q = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
  const variantComponent = {
    standard: Input$1,
    filled: FilledInput$1,
    outlined: OutlinedInput$1
  };
  const useUtilityClasses$i = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTextFieldUtilityClass, classes);
  };
  const TextFieldRoot = styled$1(MUIFormControl, {
    name: "MuiTextField",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const TextField = /* @__PURE__ */ React__namespace.forwardRef(function TextField2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTextField"
    });
    const {
      autoComplete,
      autoFocus = false,
      children,
      className,
      color: color2 = "primary",
      defaultValue,
      disabled = false,
      error = false,
      FormHelperTextProps,
      fullWidth = false,
      helperText,
      id: idOverride,
      InputLabelProps,
      inputProps,
      InputProps,
      inputRef,
      label,
      maxRows,
      minRows,
      multiline = false,
      name,
      onBlur,
      onChange,
      onFocus,
      placeholder,
      required = false,
      rows,
      select = false,
      SelectProps,
      type,
      value,
      variant = "outlined"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
    const ownerState = _extends({}, props, {
      autoFocus,
      color: color2,
      disabled,
      error,
      fullWidth,
      multiline,
      required,
      select,
      variant
    });
    const classes = useUtilityClasses$i(ownerState);
    const InputMore = {};
    if (variant === "outlined") {
      if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
        InputMore.notched = InputLabelProps.shrink;
      }
      InputMore.label = label;
    }
    if (select) {
      if (!SelectProps || !SelectProps.native) {
        InputMore.id = void 0;
      }
      InputMore["aria-describedby"] = void 0;
    }
    const id = useId(idOverride);
    const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
    const inputLabelId = label && id ? `${id}-label` : void 0;
    const InputComponent = variantComponent[variant];
    const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends({
      "aria-describedby": helperTextId,
      autoComplete,
      autoFocus,
      defaultValue,
      fullWidth,
      multiline,
      name,
      rows,
      maxRows,
      minRows,
      type,
      value,
      id,
      inputRef,
      onBlur,
      onChange,
      onFocus,
      placeholder,
      inputProps
    }, InputMore, InputProps));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends({
      className: clsx(classes.root, className),
      disabled,
      error,
      fullWidth,
      ref,
      required,
      color: color2,
      variant,
      ownerState
    }, other, {
      children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(MUIInputLabel, _extends({
        htmlFor: id,
        id: inputLabelId
      }, InputLabelProps, {
        children: label
      })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(MUISelect, _extends({
        "aria-describedby": helperTextId,
        id,
        labelId: inputLabelId,
        value,
        input: InputElement
      }, SelectProps, {
        children
      })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, _extends({
        id: helperTextId
      }, FormHelperTextProps, {
        children: helperText
      }))]
    }));
  });
  const MUITextField = TextField;
  const _excluded$p = ["quickFilterParser", "quickFilterFormatter", "debounceMs"];
  const GridToolbarQuickFilterRoot = styled$1(MUITextField, {
    name: "MuiDataGrid",
    slot: "ToolbarQuickFilter",
    overridesResolver: (props, styles2) => styles2.toolbarQuickFilter
  })(({
    theme
  }) => ({
    width: "auto",
    paddingBottom: theme.spacing(0.5),
    "& input": {
      marginLeft: theme.spacing(0.5)
    },
    "& .MuiInput-underline:before": {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
    },
    [`& input[type=search]::-ms-clear,
& input[type=search]::-ms-reveal`]: {
      /* clears the 'X' icon from IE */
      display: "none",
      width: 0,
      height: 0
    },
    [`& input[type="search"]::-webkit-search-decoration,
  & input[type="search"]::-webkit-search-cancel-button,
  & input[type="search"]::-webkit-search-results-button,
  & input[type="search"]::-webkit-search-results-decoration`]: {
      /* clears the 'X' icon from Chrome */
      display: "none"
    }
  }));
  const defaultSearchValueParser = (searchText) => searchText.split(" ").filter((word) => word !== "");
  const defaultSearchValueFormatter = (values2) => values2.join(" ");
  function GridToolbarQuickFilter(props) {
    var _rootProps$slotProps, _rootProps$slotProps2;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const quickFilterValues = useGridSelector(apiRef2, gridQuickFilterValuesSelector);
    const {
      quickFilterParser = defaultSearchValueParser,
      quickFilterFormatter = defaultSearchValueFormatter,
      debounceMs = rootProps.filterDebounceMs
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$p);
    const [searchValue, setSearchValue] = React__namespace.useState(() => quickFilterFormatter(quickFilterValues != null ? quickFilterValues : []));
    const prevQuickFilterValuesRef = React__namespace.useRef(quickFilterValues);
    React__namespace.useEffect(() => {
      if (!isDeepEqual(prevQuickFilterValuesRef.current, quickFilterValues)) {
        prevQuickFilterValuesRef.current = quickFilterValues;
        setSearchValue((prevSearchValue) => isDeepEqual(quickFilterParser(prevSearchValue), quickFilterValues) ? prevSearchValue : quickFilterFormatter(quickFilterValues != null ? quickFilterValues : []));
      }
    }, [quickFilterValues, quickFilterFormatter, quickFilterParser]);
    const updateSearchValue = React__namespace.useCallback((newSearchValue) => {
      const newQuickFilterValues = quickFilterParser(newSearchValue);
      prevQuickFilterValuesRef.current = newQuickFilterValues;
      apiRef2.current.setQuickFilterValues(newQuickFilterValues);
    }, [apiRef2, quickFilterParser]);
    const debouncedUpdateSearchValue = React__namespace.useMemo(() => debounce$1(updateSearchValue, debounceMs), [updateSearchValue, debounceMs]);
    const handleSearchValueChange = React__namespace.useCallback((event) => {
      const newSearchValue = event.target.value;
      setSearchValue(newSearchValue);
      debouncedUpdateSearchValue(newSearchValue);
    }, [debouncedUpdateSearchValue]);
    const handleSearchReset = React__namespace.useCallback(() => {
      setSearchValue("");
      updateSearchValue("");
    }, [updateSearchValue]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarQuickFilterRoot, _extends({
      as: rootProps.slots.baseTextField,
      ownerState: rootProps,
      variant: "standard",
      value: searchValue,
      onChange: handleSearchValueChange,
      placeholder: apiRef2.current.getLocaleText("toolbarQuickFilterPlaceholder"),
      "aria-label": apiRef2.current.getLocaleText("toolbarQuickFilterLabel"),
      type: "search"
    }, other, {
      InputProps: _extends({
        startAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.quickFilterIcon, {
          fontSize: "small"
        }),
        endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends({
          "aria-label": apiRef2.current.getLocaleText("toolbarQuickFilterDeleteIconLabel"),
          size: "small",
          sx: {
            visibility: searchValue ? "visible" : "hidden"
          },
          onClick: handleSearchReset
        }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.quickFilterClearIcon, {
            fontSize: "small"
          })
        }))
      }, other.InputProps)
    }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseTextField));
  }
  const _excluded$o = ["className", "csvOptions", "printOptions", "excelOptions", "showQuickFilter", "quickFilterProps"];
  const GridToolbar = /* @__PURE__ */ React__namespace.forwardRef(function GridToolbar2(props, ref) {
    const {
      csvOptions,
      printOptions,
      excelOptions,
      showQuickFilter = false,
      quickFilterProps = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
    const rootProps = useGridRootProps();
    if (rootProps.disableColumnFilter && rootProps.disableColumnSelector && rootProps.disableDensitySelector && !showQuickFilter) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridToolbarContainer, _extends({
      ref
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarColumnsButton, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarFilterButton, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarDensitySelector, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarExport, {
        csvOptions,
        printOptions,
        excelOptions
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, {
        sx: {
          flex: 1
        }
      }), showQuickFilter && /* @__PURE__ */ jsxRuntimeExports.jsx(GridToolbarQuickFilter, _extends({}, quickFilterProps))]
    }));
  });
  const _excluded$n = ["className", "rowCount", "visibleRowCount"];
  const useUtilityClasses$h = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["rowCount"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridRowCountRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "RowCount",
    overridesResolver: (props, styles2) => styles2.rowCount
  })(({
    theme
  }) => ({
    alignItems: "center",
    display: "flex",
    margin: theme.spacing(0, 2)
  }));
  const GridRowCount = /* @__PURE__ */ React__namespace.forwardRef(function GridRowCount2(props, ref) {
    const {
      className,
      rowCount,
      visibleRowCount
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$n);
    const apiRef2 = useGridApiContext();
    const ownerState = useGridRootProps();
    const classes = useUtilityClasses$h(ownerState);
    if (rowCount === 0) {
      return null;
    }
    const text = visibleRowCount < rowCount ? apiRef2.current.getLocaleText("footerTotalVisibleRows")(visibleRowCount, rowCount) : rowCount.toLocaleString();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRowCountRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: [apiRef2.current.getLocaleText("footerTotalRows"), " ", text]
    }));
  });
  const _excluded$m = ["className", "selectedRowCount"];
  const useUtilityClasses$g = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["selectedRowCount"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridSelectedRowCountRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "SelectedRowCount",
    overridesResolver: (props, styles2) => styles2.selectedRowCount
  })(({
    theme
  }) => ({
    alignItems: "center",
    display: "flex",
    margin: theme.spacing(0, 2),
    visibility: "hidden",
    width: 0,
    height: 0,
    [theme.breakpoints.up("sm")]: {
      visibility: "visible",
      width: "auto",
      height: "auto"
    }
  }));
  const GridSelectedRowCount = /* @__PURE__ */ React__namespace.forwardRef(function GridSelectedRowCount2(props, ref) {
    const {
      className,
      selectedRowCount
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
    const apiRef2 = useGridApiContext();
    const ownerState = useGridRootProps();
    const classes = useUtilityClasses$g(ownerState);
    const rowSelectedText = apiRef2.current.getLocaleText("footerRowSelected")(selectedRowCount);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCountRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: rowSelectedText
    }));
  });
  const GridFooter = /* @__PURE__ */ React__namespace.forwardRef(function GridFooter2(props, ref) {
    var _rootProps$slotProps;
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const totalTopLevelRowCount = useGridSelector(apiRef2, gridTopLevelRowCountSelector);
    const selectedRowCount = useGridSelector(apiRef2, selectedGridRowsCountSelector);
    const visibleTopLevelRowCount = useGridSelector(apiRef2, gridFilteredTopLevelRowCountSelector);
    const selectedRowCountElement = !rootProps.hideFooterSelectedRowCount && selectedRowCount > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCount, {
      selectedRowCount
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
    const rowCountElement = !rootProps.hideFooterRowCount && !rootProps.pagination ? /* @__PURE__ */ jsxRuntimeExports.jsx(GridRowCount, {
      rowCount: totalTopLevelRowCount,
      visibleRowCount: visibleTopLevelRowCount
    }) : null;
    const paginationElement = rootProps.pagination && !rootProps.hideFooterPagination && rootProps.slots.pagination && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.pagination, _extends({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.pagination));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFooterContainer, _extends({
      ref
    }, props, {
      children: [selectedRowCountElement, rowCountElement, paginationElement]
    }));
  });
  function GridHeader() {
    var _rootProps$slotProps, _rootProps$slotProps2;
    const rootProps = useGridRootProps();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.preferencesPanel, _extends({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.preferencesPanel)), rootProps.slots.toolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.toolbar, _extends({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.toolbar))]
    });
  }
  function getCircularProgressUtilityClass(slot) {
    return generateUtilityClass("MuiCircularProgress", slot);
  }
  generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
  const _excluded$l = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
  let _ = (t2) => t2, _t, _t2, _t3, _t4;
  const SIZE = 44;
  const circularRotateKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
  const circularDashKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
  const useUtilityClasses$f = (ownerState) => {
    const {
      classes,
      variant,
      color: color2,
      disableShrink
    } = ownerState;
    const slots = {
      root: ["root", variant, `color${capitalize(color2)}`],
      svg: ["svg"],
      circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
    };
    return composeClasses(slots, getCircularProgressUtilityClass, classes);
  };
  const CircularProgressRoot = styled$1("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
    }
  })(({
    ownerState,
    theme
  }) => _extends({
    display: "inline-block"
  }, ownerState.variant === "determinate" && {
    transition: theme.transitions.create("transform")
  }, ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main
  }), ({
    ownerState
  }) => ownerState.variant === "indeterminate" && css(_t3 || (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
  const CircularProgressSVG = styled$1("svg", {
    name: "MuiCircularProgress",
    slot: "Svg",
    overridesResolver: (props, styles2) => styles2.svg
  })({
    display: "block"
    // Keeps the progress centered
  });
  const CircularProgressCircle = styled$1("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
    }
  })(({
    ownerState,
    theme
  }) => _extends({
    stroke: "currentColor"
  }, ownerState.variant === "determinate" && {
    transition: theme.transitions.create("stroke-dashoffset")
  }, ownerState.variant === "indeterminate" && {
    // Some default value that looks fine waiting for the animation to kicks in.
    strokeDasharray: "80px, 200px",
    strokeDashoffset: 0
    // Add the unit to fix a Edge 16 and below bug.
  }), ({
    ownerState
  }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink && css(_t4 || (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));
  const CircularProgress = /* @__PURE__ */ React__namespace.forwardRef(function CircularProgress2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiCircularProgress"
    });
    const {
      className,
      color: color2 = "primary",
      disableShrink = false,
      size = 40,
      style: style2,
      thickness = 3.6,
      value = 0,
      variant = "indeterminate"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
    const ownerState = _extends({}, props, {
      color: color2,
      disableShrink,
      size,
      thickness,
      value,
      variant
    });
    const classes = useUtilityClasses$f(ownerState);
    const circleStyle = {};
    const rootStyle = {};
    const rootProps = {};
    if (variant === "determinate") {
      const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
      circleStyle.strokeDasharray = circumference.toFixed(3);
      rootProps["aria-valuenow"] = Math.round(value);
      circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
      rootStyle.transform = "rotate(-90deg)";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, _extends({
      className: clsx(classes.root, className),
      style: _extends({
        width: size,
        height: size
      }, rootStyle, style2),
      ownerState,
      ref,
      role: "progressbar"
    }, rootProps, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
        className: classes.svg,
        ownerState,
        viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
          className: classes.circle,
          style: circleStyle,
          ownerState,
          cx: SIZE,
          cy: SIZE,
          r: (SIZE - thickness) / 2,
          fill: "none",
          strokeWidth: thickness
        })
      })
    }));
  });
  const CircularProgress$1 = CircularProgress;
  const GridLoadingOverlay = /* @__PURE__ */ React__namespace.forwardRef(function GridLoadingOverlay2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends({
      ref
    }, props, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, {})
    }));
  });
  const GridNoRowsOverlay = /* @__PURE__ */ React__namespace.forwardRef(function GridNoRowsOverlay2(props, ref) {
    const apiRef2 = useGridApiContext();
    const noRowsLabel = apiRef2.current.getLocaleText("noRowsLabel");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends({
      ref
    }, props, {
      children: noRowsLabel
    }));
  });
  const TableContext = /* @__PURE__ */ React__namespace.createContext();
  const TableContext$1 = TableContext;
  const Tablelvl2Context = /* @__PURE__ */ React__namespace.createContext();
  const Tablelvl2Context$1 = Tablelvl2Context;
  function getTableCellUtilityClass(slot) {
    return generateUtilityClass("MuiTableCell", slot);
  }
  const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
  const tableCellClasses$1 = tableCellClasses;
  const _excluded$k = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"];
  const useUtilityClasses$e = (ownerState) => {
    const {
      classes,
      variant,
      align,
      padding: padding2,
      size,
      stickyHeader
    } = ownerState;
    const slots = {
      root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding2 !== "normal" && `padding${capitalize(padding2)}`, `size${capitalize(size)}`]
    };
    return composeClasses(slots, getTableCellUtilityClass, classes);
  };
  const TableCellRoot = styled$1("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
    }
  })(({
    theme,
    ownerState
  }) => _extends({}, theme.typography.body2, {
    display: "table-cell",
    verticalAlign: "inherit",
    // Workaround for a rendering bug with spanned columns in Chrome 62.0.
    // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
    borderBottom: theme.vars ? `1px solid ${theme.vars.palette.TableCell.border}` : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
    textAlign: "left",
    padding: 16
  }, ownerState.variant === "head" && {
    color: (theme.vars || theme).palette.text.primary,
    lineHeight: theme.typography.pxToRem(24),
    fontWeight: theme.typography.fontWeightMedium
  }, ownerState.variant === "body" && {
    color: (theme.vars || theme).palette.text.primary
  }, ownerState.variant === "footer" && {
    color: (theme.vars || theme).palette.text.secondary,
    lineHeight: theme.typography.pxToRem(21),
    fontSize: theme.typography.pxToRem(12)
  }, ownerState.size === "small" && {
    padding: "6px 16px",
    [`&.${tableCellClasses$1.paddingCheckbox}`]: {
      width: 24,
      // prevent the checkbox column from growing
      padding: "0 12px 0 16px",
      "& > *": {
        padding: 0
      }
    }
  }, ownerState.padding === "checkbox" && {
    width: 48,
    // prevent the checkbox column from growing
    padding: "0 0 0 4px"
  }, ownerState.padding === "none" && {
    padding: 0
  }, ownerState.align === "left" && {
    textAlign: "left"
  }, ownerState.align === "center" && {
    textAlign: "center"
  }, ownerState.align === "right" && {
    textAlign: "right",
    flexDirection: "row-reverse"
  }, ownerState.align === "justify" && {
    textAlign: "justify"
  }, ownerState.stickyHeader && {
    position: "sticky",
    top: 0,
    zIndex: 2,
    backgroundColor: (theme.vars || theme).palette.background.default
  }));
  const TableCell = /* @__PURE__ */ React__namespace.forwardRef(function TableCell2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTableCell"
    });
    const {
      align = "inherit",
      className,
      component: componentProp,
      padding: paddingProp,
      scope: scopeProp,
      size: sizeProp,
      sortDirection,
      variant: variantProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
    const table = React__namespace.useContext(TableContext$1);
    const tablelvl2 = React__namespace.useContext(Tablelvl2Context$1);
    const isHeadCell = tablelvl2 && tablelvl2.variant === "head";
    let component;
    if (componentProp) {
      component = componentProp;
    } else {
      component = isHeadCell ? "th" : "td";
    }
    let scope = scopeProp;
    if (component === "td") {
      scope = void 0;
    } else if (!scope && isHeadCell) {
      scope = "col";
    }
    const variant = variantProp || tablelvl2 && tablelvl2.variant;
    const ownerState = _extends({}, props, {
      align,
      component,
      padding: paddingProp || (table && table.padding ? table.padding : "normal"),
      size: sizeProp || (table && table.size ? table.size : "medium"),
      sortDirection,
      stickyHeader: variant === "head" && table && table.stickyHeader,
      variant
    });
    const classes = useUtilityClasses$e(ownerState);
    let ariaSort = null;
    if (sortDirection) {
      ariaSort = sortDirection === "asc" ? "ascending" : "descending";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, _extends({
      as: component,
      ref,
      className: clsx(classes.root, className),
      "aria-sort": ariaSort,
      scope,
      ownerState
    }, other));
  });
  const TableCell$1 = TableCell;
  function getToolbarUtilityClass(slot) {
    return generateUtilityClass("MuiToolbar", slot);
  }
  generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
  const _excluded$j = ["className", "component", "disableGutters", "variant"];
  const useUtilityClasses$d = (ownerState) => {
    const {
      classes,
      disableGutters,
      variant
    } = ownerState;
    const slots = {
      root: ["root", !disableGutters && "gutters", variant]
    };
    return composeClasses(slots, getToolbarUtilityClass, classes);
  };
  const ToolbarRoot = styled$1("div", {
    name: "MuiToolbar",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    position: "relative",
    display: "flex",
    alignItems: "center"
  }, !ownerState.disableGutters && {
    paddingLeft: theme.spacing(2),
    paddingRight: theme.spacing(2),
    [theme.breakpoints.up("sm")]: {
      paddingLeft: theme.spacing(3),
      paddingRight: theme.spacing(3)
    }
  }, ownerState.variant === "dense" && {
    minHeight: 48
  }), ({
    theme,
    ownerState
  }) => ownerState.variant === "regular" && theme.mixins.toolbar);
  const Toolbar = /* @__PURE__ */ React__namespace.forwardRef(function Toolbar2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiToolbar"
    });
    const {
      className,
      component = "div",
      disableGutters = false,
      variant = "regular"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
    const ownerState = _extends({}, props, {
      component,
      disableGutters,
      variant
    });
    const classes = useUtilityClasses$d(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarRoot, _extends({
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState
    }, other));
  });
  const Toolbar$1 = Toolbar;
  const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
  }), "KeyboardArrowLeft");
  const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
  }), "KeyboardArrowRight");
  const LastPageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
  }), "LastPage");
  const FirstPageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
  }), "FirstPage");
  var _LastPageIcon, _FirstPageIcon, _KeyboardArrowRight, _KeyboardArrowLeft, _KeyboardArrowLeft2, _KeyboardArrowRight2, _FirstPageIcon2, _LastPageIcon2;
  const _excluded$i = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"];
  const TablePaginationActions = /* @__PURE__ */ React__namespace.forwardRef(function TablePaginationActions2(props, ref) {
    const {
      backIconButtonProps,
      count,
      getItemAriaLabel,
      nextIconButtonProps,
      onPageChange,
      page,
      rowsPerPage,
      showFirstButton,
      showLastButton
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
    const theme = useTheme();
    const handleFirstPageButtonClick = (event) => {
      onPageChange(event, 0);
    };
    const handleBackButtonClick = (event) => {
      onPageChange(event, page - 1);
    };
    const handleNextButtonClick = (event) => {
      onPageChange(event, page + 1);
    };
    const handleLastPageButtonClick = (event) => {
      onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends({
      ref
    }, other, {
      children: [showFirstButton && /* @__PURE__ */ jsxRuntimeExports.jsx(MUIIconButton, {
        onClick: handleFirstPageButtonClick,
        disabled: page === 0,
        "aria-label": getItemAriaLabel("first", page),
        title: getItemAriaLabel("first", page),
        children: theme.direction === "rtl" ? _LastPageIcon || (_LastPageIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(LastPageIcon, {})) : _FirstPageIcon || (_FirstPageIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(FirstPageIcon, {}))
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(MUIIconButton, _extends({
        onClick: handleBackButtonClick,
        disabled: page === 0,
        color: "inherit",
        "aria-label": getItemAriaLabel("previous", page),
        title: getItemAriaLabel("previous", page)
      }, backIconButtonProps, {
        children: theme.direction === "rtl" ? _KeyboardArrowRight || (_KeyboardArrowRight = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowRight, {})) : _KeyboardArrowLeft || (_KeyboardArrowLeft = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowLeft, {}))
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(MUIIconButton, _extends({
        onClick: handleNextButtonClick,
        disabled: count !== -1 ? page >= Math.ceil(count / rowsPerPage) - 1 : false,
        color: "inherit",
        "aria-label": getItemAriaLabel("next", page),
        title: getItemAriaLabel("next", page)
      }, nextIconButtonProps, {
        children: theme.direction === "rtl" ? _KeyboardArrowLeft2 || (_KeyboardArrowLeft2 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowLeft, {})) : _KeyboardArrowRight2 || (_KeyboardArrowRight2 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowRight, {}))
      })), showLastButton && /* @__PURE__ */ jsxRuntimeExports.jsx(MUIIconButton, {
        onClick: handleLastPageButtonClick,
        disabled: page >= Math.ceil(count / rowsPerPage) - 1,
        "aria-label": getItemAriaLabel("last", page),
        title: getItemAriaLabel("last", page),
        children: theme.direction === "rtl" ? _FirstPageIcon2 || (_FirstPageIcon2 = /* @__PURE__ */ jsxRuntimeExports.jsx(FirstPageIcon, {})) : _LastPageIcon2 || (_LastPageIcon2 = /* @__PURE__ */ jsxRuntimeExports.jsx(LastPageIcon, {}))
      })]
    }));
  });
  const TablePaginationActions$1 = TablePaginationActions;
  function getTablePaginationUtilityClass(slot) {
    return generateUtilityClass("MuiTablePagination", slot);
  }
  const tablePaginationClasses = generateUtilityClasses("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
  const tablePaginationClasses$1 = tablePaginationClasses;
  var _InputBase;
  const _excluded$h = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"];
  const TablePaginationRoot = styled$1(TableCell$1, {
    name: "MuiTablePagination",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => ({
    overflow: "auto",
    color: (theme.vars || theme).palette.text.primary,
    fontSize: theme.typography.pxToRem(14),
    // Increase the specificity to override TableCell.
    "&:last-child": {
      padding: 0
    }
  }));
  const TablePaginationToolbar = styled$1(Toolbar$1, {
    name: "MuiTablePagination",
    slot: "Toolbar",
    overridesResolver: (props, styles2) => _extends({
      [`& .${tablePaginationClasses$1.actions}`]: styles2.actions
    }, styles2.toolbar)
  })(({
    theme
  }) => ({
    minHeight: 52,
    paddingRight: 2,
    [`${theme.breakpoints.up("xs")} and (orientation: landscape)`]: {
      minHeight: 52
    },
    [theme.breakpoints.up("sm")]: {
      minHeight: 52,
      paddingRight: 2
    },
    [`& .${tablePaginationClasses$1.actions}`]: {
      flexShrink: 0,
      marginLeft: 20
    }
  }));
  const TablePaginationSpacer = styled$1("div", {
    name: "MuiTablePagination",
    slot: "Spacer",
    overridesResolver: (props, styles2) => styles2.spacer
  })({
    flex: "1 1 100%"
  });
  const TablePaginationSelectLabel = styled$1("p", {
    name: "MuiTablePagination",
    slot: "SelectLabel",
    overridesResolver: (props, styles2) => styles2.selectLabel
  })(({
    theme
  }) => _extends({}, theme.typography.body2, {
    flexShrink: 0
  }));
  const TablePaginationSelect = styled$1(MUISelect, {
    name: "MuiTablePagination",
    slot: "Select",
    overridesResolver: (props, styles2) => _extends({
      [`& .${tablePaginationClasses$1.selectIcon}`]: styles2.selectIcon,
      [`& .${tablePaginationClasses$1.select}`]: styles2.select
    }, styles2.input, styles2.selectRoot)
  })({
    color: "inherit",
    fontSize: "inherit",
    flexShrink: 0,
    marginRight: 32,
    marginLeft: 8,
    [`& .${tablePaginationClasses$1.select}`]: {
      paddingLeft: 8,
      paddingRight: 24,
      textAlign: "right",
      textAlignLast: "right"
      // Align <select> on Chrome.
    }
  });
  const TablePaginationMenuItem = styled$1(MUIMenuItem, {
    name: "MuiTablePagination",
    slot: "MenuItem",
    overridesResolver: (props, styles2) => styles2.menuItem
  })({});
  const TablePaginationDisplayedRows = styled$1("p", {
    name: "MuiTablePagination",
    slot: "DisplayedRows",
    overridesResolver: (props, styles2) => styles2.displayedRows
  })(({
    theme
  }) => _extends({}, theme.typography.body2, {
    flexShrink: 0
  }));
  function defaultLabelDisplayedRows({
    from: from2,
    to,
    count
  }) {
    return `${from2}–${to} of ${count !== -1 ? count : `more than ${to}`}`;
  }
  function defaultGetAriaLabel(type) {
    return `Go to ${type} page`;
  }
  const useUtilityClasses$c = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      toolbar: ["toolbar"],
      spacer: ["spacer"],
      selectLabel: ["selectLabel"],
      select: ["select"],
      input: ["input"],
      selectIcon: ["selectIcon"],
      menuItem: ["menuItem"],
      displayedRows: ["displayedRows"],
      actions: ["actions"]
    };
    return composeClasses(slots, getTablePaginationUtilityClass, classes);
  };
  const TablePagination = /* @__PURE__ */ React__namespace.forwardRef(function TablePagination2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTablePagination"
    });
    const {
      ActionsComponent = TablePaginationActions$1,
      backIconButtonProps,
      className,
      colSpan: colSpanProp,
      component = TableCell$1,
      count,
      getItemAriaLabel = defaultGetAriaLabel,
      labelDisplayedRows = defaultLabelDisplayedRows,
      labelRowsPerPage = "Rows per page:",
      nextIconButtonProps,
      onPageChange,
      onRowsPerPageChange,
      page,
      rowsPerPage,
      rowsPerPageOptions = [10, 25, 50, 100],
      SelectProps = {},
      showFirstButton = false,
      showLastButton = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
    const ownerState = props;
    const classes = useUtilityClasses$c(ownerState);
    const MenuItemComponent = SelectProps.native ? "option" : TablePaginationMenuItem;
    let colSpan;
    if (component === TableCell$1 || component === "td") {
      colSpan = colSpanProp || 1e3;
    }
    const selectId = useId(SelectProps.id);
    const labelId = useId(SelectProps.labelId);
    const getLabelDisplayedRowsTo = () => {
      if (count === -1) {
        return (page + 1) * rowsPerPage;
      }
      return rowsPerPage === -1 ? count : Math.min(count, (page + 1) * rowsPerPage);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationRoot, _extends({
      colSpan,
      ref,
      as: component,
      ownerState,
      className: clsx(classes.root, className)
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TablePaginationToolbar, {
        className: classes.toolbar,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSpacer, {
          className: classes.spacer
        }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSelectLabel, {
          className: classes.selectLabel,
          id: labelId,
          children: labelRowsPerPage
        }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSelect, _extends({
          variant: "standard"
        }, !SelectProps.variant && {
          input: _InputBase || (_InputBase = /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, {}))
        }, {
          value: rowsPerPage,
          onChange: onRowsPerPageChange,
          id: selectId,
          labelId
        }, SelectProps, {
          classes: _extends({}, SelectProps.classes, {
            // TODO v5 remove `classes.input`
            root: clsx(classes.input, classes.selectRoot, (SelectProps.classes || {}).root),
            select: clsx(classes.select, (SelectProps.classes || {}).select),
            // TODO v5 remove `selectIcon`
            icon: clsx(classes.selectIcon, (SelectProps.classes || {}).icon)
          }),
          children: rowsPerPageOptions.map((rowsPerPageOption) => /* @__PURE__ */ React.createElement(MenuItemComponent, _extends({}, !isHostComponent(MenuItemComponent) && {
            ownerState
          }, {
            className: classes.menuItem,
            key: rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption,
            value: rowsPerPageOption.value ? rowsPerPageOption.value : rowsPerPageOption
          }), rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption))
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationDisplayedRows, {
          className: classes.displayedRows,
          children: labelDisplayedRows({
            from: count === 0 ? 0 : page * rowsPerPage + 1,
            to: getLabelDisplayedRowsTo(),
            count: count === -1 ? -1 : count,
            page
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsComponent, {
          className: classes.actions,
          backIconButtonProps,
          count,
          nextIconButtonProps,
          onPageChange,
          page,
          rowsPerPage,
          showFirstButton,
          showLastButton,
          getItemAriaLabel
        })]
      })
    }));
  });
  const TablePagination$1 = TablePagination;
  const GridPaginationRoot = styled$1(TablePagination$1)(({
    theme
  }) => ({
    [`& .${tablePaginationClasses$1.selectLabel}`]: {
      display: "none",
      [theme.breakpoints.up("sm")]: {
        display: "block"
      }
    },
    [`& .${tablePaginationClasses$1.input}`]: {
      display: "none",
      [theme.breakpoints.up("sm")]: {
        display: "inline-flex"
      }
    }
  }));
  const GridPagination = /* @__PURE__ */ React__namespace.forwardRef(function GridPagination2(props, ref) {
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const paginationModel = useGridSelector(apiRef2, gridPaginationModelSelector);
    const visibleTopLevelRowCount = useGridSelector(apiRef2, gridFilteredTopLevelRowCountSelector);
    const rowCount = React__namespace.useMemo(() => {
      var _ref, _rootProps$rowCount;
      return (_ref = (_rootProps$rowCount = rootProps.rowCount) != null ? _rootProps$rowCount : visibleTopLevelRowCount) != null ? _ref : 0;
    }, [rootProps.rowCount, visibleTopLevelRowCount]);
    const lastPage = React__namespace.useMemo(() => Math.floor(rowCount / (paginationModel.pageSize || 1)), [rowCount, paginationModel.pageSize]);
    const handlePageSizeChange = React__namespace.useCallback((event) => {
      const pageSize2 = Number(event.target.value);
      apiRef2.current.setPageSize(pageSize2);
    }, [apiRef2]);
    const handlePageChange = React__namespace.useCallback((_2, page) => {
      apiRef2.current.setPage(page);
    }, [apiRef2]);
    const isPageSizeIncludedInPageSizeOptions = (pageSize2) => {
      for (let i = 0; i < rootProps.pageSizeOptions.length; i += 1) {
        const option = rootProps.pageSizeOptions[i];
        if (typeof option === "number") {
          if (option === pageSize2) {
            return true;
          }
        } else if (option.value === pageSize2) {
          return true;
        }
      }
      return false;
    };
    const pageSizeOptions = isPageSizeIncludedInPageSizeOptions(paginationModel.pageSize) ? rootProps.pageSizeOptions : [];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPaginationRoot, _extends({
      ref,
      component: "div",
      count: rowCount,
      page: paginationModel.page <= lastPage ? paginationModel.page : lastPage,
      rowsPerPageOptions: pageSizeOptions,
      rowsPerPage: paginationModel.pageSize,
      onPageChange: handlePageChange,
      onRowsPerPageChange: handlePageSizeChange
    }, apiRef2.current.getLocaleText("MuiTablePagination"), props));
  });
  const getVisibleRows = (apiRef2, props) => {
    let rows;
    let range;
    if (props.pagination && props.paginationMode === "client") {
      range = gridPaginationRowRangeSelector(apiRef2);
      rows = gridPaginatedVisibleSortedGridRowEntriesSelector(apiRef2);
    } else {
      rows = gridExpandedSortedRowEntriesSelector(apiRef2);
      if (rows.length === 0) {
        range = null;
      } else {
        range = {
          firstRowIndex: 0,
          lastRowIndex: rows.length - 1
        };
      }
    }
    return {
      rows,
      range
    };
  };
  const useGridVisibleRows = (apiRef2, props) => {
    const response = getVisibleRows(apiRef2, props);
    return React__namespace.useMemo(() => ({
      rows: response.rows,
      range: response.range
    }), [response.rows, response.range]);
  };
  const GLOBAL_API_REF = {
    current: null
  };
  function tagInternalFilter(fn2) {
    fn2.isInternal = true;
    return fn2;
  }
  function isInternalFilter(fn2) {
    return fn2 !== void 0 && fn2.isInternal === true;
  }
  function convertFilterV7ToLegacy(fn2) {
    return tagInternalFilter((filterItem2, column2) => {
      const filterFn = fn2(filterItem2, column2);
      if (!filterFn) {
        return filterFn;
      }
      return (cellParams) => {
        return filterFn(cellParams.value, cellParams.row, column2, GLOBAL_API_REF.current);
      };
    });
  }
  function convertLegacyOperators(ops) {
    return ops.map((op) => {
      return _extends({}, op, {
        getApplyFilterFn: convertFilterV7ToLegacy(op.getApplyFilterFnV7),
        getApplyFilterFnV7: tagInternalFilter(op.getApplyFilterFnV7)
      });
    });
  }
  function convertQuickFilterV7ToLegacy(fn2) {
    return tagInternalFilter((filterItem2, column2, apiRef2) => {
      const filterFn = fn2(filterItem2, column2, apiRef2);
      if (!filterFn) {
        return filterFn;
      }
      return (cellParams) => {
        return filterFn(cellParams.value, cellParams.row, column2, apiRef2);
      };
    });
  }
  const getGridStringQuickFilterFn = tagInternalFilter((value) => {
    if (!value) {
      return null;
    }
    const filterRegex = new RegExp(escapeRegExp(value), "i");
    return (_2, row, column2, apiRef2) => {
      const columnValue = apiRef2.current.getRowFormattedValue(row, column2);
      return columnValue != null ? filterRegex.test(columnValue.toString()) : false;
    };
  });
  const getGridStringOperators = (disableTrim = false) => convertLegacyOperators([{
    value: "contains",
    getApplyFilterFnV7: (filterItem2) => {
      if (!filterItem2.value) {
        return null;
      }
      const filterItemValue = disableTrim ? filterItem2.value : filterItem2.value.trim();
      const filterRegex = new RegExp(escapeRegExp(filterItemValue), "i");
      return (value) => {
        return value != null ? filterRegex.test(String(value)) : false;
      };
    },
    InputComponent: GridFilterInputValue
  }, {
    value: "equals",
    getApplyFilterFnV7: (filterItem2) => {
      if (!filterItem2.value) {
        return null;
      }
      const filterItemValue = disableTrim ? filterItem2.value : filterItem2.value.trim();
      const collator2 = new Intl.Collator(void 0, {
        sensitivity: "base",
        usage: "search"
      });
      return (value) => {
        return value != null ? collator2.compare(filterItemValue, value.toString()) === 0 : false;
      };
    },
    InputComponent: GridFilterInputValue
  }, {
    value: "startsWith",
    getApplyFilterFnV7: (filterItem2) => {
      if (!filterItem2.value) {
        return null;
      }
      const filterItemValue = disableTrim ? filterItem2.value : filterItem2.value.trim();
      const filterRegex = new RegExp(`^${escapeRegExp(filterItemValue)}.*$`, "i");
      return (value) => {
        return value != null ? filterRegex.test(value.toString()) : false;
      };
    },
    InputComponent: GridFilterInputValue
  }, {
    value: "endsWith",
    getApplyFilterFnV7: (filterItem2) => {
      if (!filterItem2.value) {
        return null;
      }
      const filterItemValue = disableTrim ? filterItem2.value : filterItem2.value.trim();
      const filterRegex = new RegExp(`.*${escapeRegExp(filterItemValue)}$`, "i");
      return (value) => {
        return value != null ? filterRegex.test(value.toString()) : false;
      };
    },
    InputComponent: GridFilterInputValue
  }, {
    value: "isEmpty",
    getApplyFilterFnV7: () => {
      return (value) => {
        return value === "" || value == null;
      };
    },
    requiresFilterValue: false
  }, {
    value: "isNotEmpty",
    getApplyFilterFnV7: () => {
      return (value) => {
        return value !== "" && value != null;
      };
    },
    requiresFilterValue: false
  }, {
    value: "isAnyOf",
    getApplyFilterFnV7: (filterItem2) => {
      if (!Array.isArray(filterItem2.value) || filterItem2.value.length === 0) {
        return null;
      }
      const filterItemValue = disableTrim ? filterItem2.value : filterItem2.value.map((val) => val.trim());
      const collator2 = new Intl.Collator(void 0, {
        sensitivity: "base",
        usage: "search"
      });
      return (value) => value != null ? filterItemValue.some((filterValue) => {
        return collator2.compare(filterValue, value.toString() || "") === 0;
      }) : false;
    },
    InputComponent: GridFilterInputMultipleValue
  }]);
  const GRID_STRING_COL_DEF = {
    width: 100,
    minWidth: 50,
    maxWidth: Infinity,
    hideable: true,
    sortable: true,
    resizable: true,
    filterable: true,
    groupable: true,
    pinnable: true,
    // @ts-ignore
    aggregable: true,
    editable: false,
    sortComparator: gridStringOrNumberComparator,
    type: "string",
    align: "left",
    filterOperators: getGridStringOperators(),
    renderEditCell: renderEditInputCell,
    getApplyQuickFilterFn: convertQuickFilterV7ToLegacy(getGridStringQuickFilterFn),
    getApplyQuickFilterFnV7: getGridStringQuickFilterFn
  };
  const getGridBooleanOperators = () => convertLegacyOperators([{
    value: "is",
    getApplyFilterFnV7: (filterItem2) => {
      if (!filterItem2.value) {
        return null;
      }
      const valueAsBoolean = filterItem2.value === "true";
      return (value) => {
        return Boolean(value) === valueAsBoolean;
      };
    },
    InputComponent: GridFilterInputBoolean
  }]);
  function gridBooleanFormatter({
    value,
    api
  }) {
    return value ? api.getLocaleText("booleanCellTrueLabel") : api.getLocaleText("booleanCellFalseLabel");
  }
  const stringToBoolean = (value) => {
    switch (value.toLowerCase().trim()) {
      case "true":
      case "yes":
      case "1":
        return true;
      case "false":
      case "no":
      case "0":
      case "null":
      case "undefined":
        return false;
      default:
        return void 0;
    }
  };
  const GRID_BOOLEAN_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
    type: "boolean",
    align: "center",
    headerAlign: "center",
    renderCell: renderBooleanCell,
    renderEditCell: renderEditBooleanCell,
    sortComparator: gridNumberComparator,
    valueFormatter: gridBooleanFormatter,
    filterOperators: getGridBooleanOperators(),
    getApplyQuickFilterFn: void 0,
    getApplyQuickFilterFnV7: void 0,
    // @ts-ignore
    aggregable: false,
    // @ts-ignore
    pastedValueParser: (value) => stringToBoolean(value)
  });
  const GRID_CHECKBOX_SELECTION_FIELD = "__check__";
  const GRID_CHECKBOX_SELECTION_COL_DEF = _extends({}, GRID_BOOLEAN_COL_DEF, {
    field: GRID_CHECKBOX_SELECTION_FIELD,
    type: "checkboxSelection",
    width: 50,
    resizable: false,
    sortable: false,
    filterable: false,
    // @ts-ignore
    aggregable: false,
    disableColumnMenu: true,
    disableReorder: true,
    disableExport: true,
    getApplyQuickFilterFn: void 0,
    getApplyQuickFilterFnV7: void 0,
    valueGetter: (params) => {
      const selectionLookup = selectedIdsLookupSelector(params.api.state, params.api.instanceId);
      return selectionLookup[params.id] !== void 0;
    },
    renderHeader: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridHeaderCheckbox, _extends({}, params)),
    renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridCellCheckboxRenderer, _extends({}, params))
  });
  const GRID_ACTIONS_COLUMN_TYPE = "actions";
  const GRID_ACTIONS_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
    sortable: false,
    filterable: false,
    // @ts-ignore
    aggregable: false,
    width: 100,
    align: "center",
    headerAlign: "center",
    headerName: "",
    disableColumnMenu: true,
    disableExport: true,
    renderCell: renderActionsCell,
    getApplyQuickFilterFn: void 0,
    getApplyQuickFilterFnV7: void 0
  });
  const GRID_DETAIL_PANEL_TOGGLE_FIELD = "__detail_panel_toggle__";
  const gridEditRowsStateSelector = (state) => state.editRows;
  const _excluded$g = ["selected", "rowId", "row", "index", "style", "position", "rowHeight", "className", "visibleColumns", "renderedColumns", "containerWidth", "firstColumnToRender", "lastColumnToRender", "isLastVisible", "focusedCellColumnIndexNotInRange", "isNotVisible", "focusedCell", "tabbableCell", "onClick", "onDoubleClick", "onMouseEnter", "onMouseLeave"];
  const useUtilityClasses$b = (ownerState) => {
    const {
      editable,
      editing,
      selected,
      isLastVisible,
      rowHeight,
      classes
    } = ownerState;
    const slots = {
      root: ["row", selected && "selected", editable && "row--editable", editing && "row--editing", isLastVisible && "row--lastVisible", rowHeight === "auto" && "row--dynamicHeight"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function EmptyCell({
    width: width2
  }) {
    if (!width2) {
      return null;
    }
    const style2 = {
      width: width2
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: `${gridClasses.cell} ${gridClasses.withBorderColor}`,
      style: style2
    });
  }
  const GridRow = /* @__PURE__ */ React__namespace.forwardRef(function GridRow2(props, refProp) {
    const {
      selected,
      rowId,
      row,
      index,
      style: styleProp,
      position: position2,
      rowHeight,
      className,
      visibleColumns,
      renderedColumns,
      containerWidth,
      firstColumnToRender,
      isLastVisible = false,
      focusedCellColumnIndexNotInRange,
      isNotVisible,
      focusedCell,
      onClick,
      onDoubleClick,
      onMouseEnter,
      onMouseLeave
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
    const apiRef2 = useGridApiContext();
    const ref = React__namespace.useRef(null);
    const rootProps = useGridRootProps();
    const currentPage = useGridVisibleRows(apiRef2, rootProps);
    const columnsTotalWidth = useGridSelector(apiRef2, gridColumnsTotalWidthSelector);
    const sortModel = useGridSelector(apiRef2, gridSortModelSelector);
    const treeDepth = useGridSelector(apiRef2, gridRowMaximumTreeDepthSelector);
    const headerGroupingMaxDepth = useGridSelector(apiRef2, gridColumnGroupsHeaderMaxDepthSelector);
    const editRowsState = useGridSelector(apiRef2, gridEditRowsStateSelector);
    const handleRef = useForkRef(ref, refProp);
    const ariaRowIndex = index + headerGroupingMaxDepth + 2;
    const ownerState = {
      selected,
      isLastVisible,
      classes: rootProps.classes,
      editing: apiRef2.current.getRowMode(rowId) === GridRowModes.Edit,
      editable: rootProps.editMode === GridEditModes.Row,
      rowHeight
    };
    const classes = useUtilityClasses$b(ownerState);
    React__namespace.useLayoutEffect(() => {
      if (rowHeight === "auto" && ref.current && typeof ResizeObserver === "undefined") {
        apiRef2.current.unstable_storeRowHeightMeasurement(rowId, ref.current.clientHeight, position2);
      }
    }, [apiRef2, rowHeight, rowId, position2]);
    React__namespace.useLayoutEffect(() => {
      if (currentPage.range) {
        const rowIndex = apiRef2.current.getRowIndexRelativeToVisibleRows(rowId);
        if (rowIndex != null) {
          apiRef2.current.unstable_setLastMeasuredRowIndex(rowIndex);
        }
      }
      const rootElement = ref.current;
      const hasFixedHeight = rowHeight !== "auto";
      if (!rootElement || hasFixedHeight || typeof ResizeObserver === "undefined") {
        return void 0;
      }
      const resizeObserver = new ResizeObserver((entries) => {
        const [entry] = entries;
        const height2 = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;
        apiRef2.current.unstable_storeRowHeightMeasurement(rowId, height2, position2);
      });
      resizeObserver.observe(rootElement);
      return () => resizeObserver.disconnect();
    }, [apiRef2, currentPage.range, index, rowHeight, rowId, position2]);
    const publish = React__namespace.useCallback((eventName, propHandler) => (event) => {
      if (event.target.nodeType === 1 && !event.currentTarget.contains(event.target)) {
        return;
      }
      if (!apiRef2.current.getRow(rowId)) {
        return;
      }
      apiRef2.current.publishEvent(eventName, apiRef2.current.getRowParams(rowId), event);
      if (propHandler) {
        propHandler(event);
      }
    }, [apiRef2, rowId]);
    const publishClick = React__namespace.useCallback((event) => {
      const cell = findParentElementFromClassName(event.target, gridClasses.cell);
      const field = cell == null ? void 0 : cell.getAttribute("data-field");
      if (field) {
        if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
          return;
        }
        if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
          return;
        }
        if (field === "__reorder__") {
          return;
        }
        if (apiRef2.current.getCellMode(rowId, field) === GridCellModes.Edit) {
          return;
        }
        const column2 = apiRef2.current.getColumn(field);
        if ((column2 == null ? void 0 : column2.type) === GRID_ACTIONS_COLUMN_TYPE) {
          return;
        }
      }
      publish("rowClick", onClick)(event);
    }, [apiRef2, onClick, publish, rowId]);
    const {
      slots,
      slotProps,
      disableColumnReorder
    } = rootProps;
    const CellComponent = slots.cell === MemoizedGridCellV7 ? MemoizedGridCellV7 : MemoizedCellWrapper;
    const rowReordering = rootProps.rowReordering;
    const getCell = (column2, cellProps) => {
      var _editRowsState$rowId$, _editRowsState$rowId;
      const disableDragEvents = disableColumnReorder && column2.disableReorder || !rowReordering && !!sortModel.length && treeDepth > 1 && Object.keys(editRowsState).length > 0;
      const editCellState = (_editRowsState$rowId$ = (_editRowsState$rowId = editRowsState[rowId]) == null ? void 0 : _editRowsState$rowId[column2.field]) != null ? _editRowsState$rowId$ : null;
      let cellIsNotVisible = false;
      if (focusedCellColumnIndexNotInRange !== void 0 && visibleColumns[focusedCellColumnIndexNotInRange].field === column2.field) {
        cellIsNotVisible = true;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CellComponent, _extends({
        column: column2,
        width: cellProps.width,
        rowId,
        height: rowHeight,
        showRightBorder: cellProps.showRightBorder,
        align: column2.align || "left",
        colIndex: cellProps.indexRelativeToAllColumns,
        colSpan: cellProps.colSpan,
        disableDragEvents,
        editCellState,
        isNotVisible: cellIsNotVisible
      }, slotProps == null ? void 0 : slotProps.cell), column2.field);
    };
    const sizes = useGridSelector(apiRef2, () => _extends({}, apiRef2.current.unstable_getRowInternalSizes(rowId)), objectShallowCompare);
    let minHeight2 = rowHeight;
    if (minHeight2 === "auto" && sizes) {
      let numberOfBaseSizes = 0;
      const maximumSize = Object.entries(sizes).reduce((acc, [key, size]) => {
        const isBaseHeight = /^base[A-Z]/.test(key);
        if (!isBaseHeight) {
          return acc;
        }
        numberOfBaseSizes += 1;
        if (size > acc) {
          return size;
        }
        return acc;
      }, 0);
      if (maximumSize > 0 && numberOfBaseSizes > 1) {
        minHeight2 = maximumSize;
      }
    }
    const style2 = React__namespace.useMemo(() => {
      if (isNotVisible) {
        return {
          opacity: 0,
          width: 0,
          height: 0
        };
      }
      const rowStyle = _extends({}, styleProp, {
        maxHeight: rowHeight === "auto" ? "none" : rowHeight,
        // max-height doesn't support "auto"
        minHeight: minHeight2
      });
      if (sizes != null && sizes.spacingTop) {
        const property = rootProps.rowSpacingType === "border" ? "borderTopWidth" : "marginTop";
        rowStyle[property] = sizes.spacingTop;
      }
      if (sizes != null && sizes.spacingBottom) {
        const property = rootProps.rowSpacingType === "border" ? "borderBottomWidth" : "marginBottom";
        let propertyValue = rowStyle[property];
        if (typeof propertyValue !== "number") {
          propertyValue = parseInt(propertyValue || "0", 10);
        }
        propertyValue += sizes.spacingBottom;
        rowStyle[property] = propertyValue;
      }
      return rowStyle;
    }, [isNotVisible, rowHeight, styleProp, minHeight2, sizes, rootProps.rowSpacingType]);
    const rowClassNames = apiRef2.current.unstable_applyPipeProcessors("rowClassName", [], rowId);
    if (typeof rootProps.getRowClassName === "function") {
      var _currentPage$range;
      const indexRelativeToCurrentPage = index - (((_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.firstRowIndex) || 0);
      const rowParams = _extends({}, apiRef2.current.getRowParams(rowId), {
        isFirstVisible: indexRelativeToCurrentPage === 0,
        isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,
        indexRelativeToCurrentPage
      });
      rowClassNames.push(rootProps.getRowClassName(rowParams));
    }
    const randomNumber = randomNumberBetween(1e4, 20, 80);
    const rowNode = apiRef2.current.getRowNode(rowId);
    if (!rowNode) {
      return null;
    }
    const rowType = rowNode.type;
    const cells = [];
    for (let i = 0; i < renderedColumns.length; i += 1) {
      const column2 = renderedColumns[i];
      let indexRelativeToAllColumns = firstColumnToRender + i;
      if (focusedCellColumnIndexNotInRange !== void 0 && focusedCell) {
        if (visibleColumns[focusedCellColumnIndexNotInRange].field === column2.field) {
          indexRelativeToAllColumns = focusedCellColumnIndexNotInRange;
        } else {
          indexRelativeToAllColumns -= 1;
        }
      }
      const cellColSpanInfo = apiRef2.current.unstable_getCellColSpanInfo(rowId, indexRelativeToAllColumns);
      if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {
        if (rowType !== "skeletonRow") {
          const {
            colSpan,
            width: width2
          } = cellColSpanInfo.cellProps;
          const cellProps = {
            width: width2,
            colSpan,
            showRightBorder: rootProps.showCellVerticalBorder,
            indexRelativeToAllColumns
          };
          cells.push(getCell(column2, cellProps));
        } else {
          const {
            width: width2
          } = cellColSpanInfo.cellProps;
          const contentWidth = Math.round(randomNumber());
          cells.push(/* @__PURE__ */ jsxRuntimeExports.jsx(slots.skeletonCell, {
            width: width2,
            contentWidth,
            field: column2.field,
            align: column2.align
          }, column2.field));
        }
      }
    }
    const emptyCellWidth = containerWidth - columnsTotalWidth;
    const eventHandlers = row ? {
      onClick: publishClick,
      onDoubleClick: publish("rowDoubleClick", onDoubleClick),
      onMouseEnter: publish("rowMouseEnter", onMouseEnter),
      onMouseLeave: publish("rowMouseLeave", onMouseLeave)
    } : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends({
      ref: handleRef,
      "data-id": rowId,
      "data-rowindex": index,
      role: "row",
      className: clsx(...rowClassNames, classes.root, className),
      "aria-rowindex": ariaRowIndex,
      "aria-selected": selected,
      style: style2
    }, eventHandlers, other, {
      children: [cells, emptyCellWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyCell, {
        width: emptyCellWidth
      })]
    }));
  });
  const MemoizedGridRow = fastMemo(GridRow);
  function GridContextProvider({
    privateApiRef,
    props,
    children
  }) {
    const apiRef2 = React__namespace.useRef(privateApiRef.current.getPublicApi());
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRootPropsContext.Provider, {
      value: props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPrivateApiContext.Provider, {
        value: privateApiRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridApiContext.Provider, {
          value: apiRef2,
          children
        })
      })
    });
  }
  const forceDebug = localStorageAvailable() && window.localStorage.getItem("DEBUG") != null;
  const noop$1 = () => {
  };
  const noopLogger = {
    debug: noop$1,
    info: noop$1,
    warn: noop$1,
    error: noop$1
  };
  const LOG_LEVELS = ["debug", "info", "warn", "error"];
  function getAppender(name, logLevel, appender = console) {
    const minLogLevelIdx = LOG_LEVELS.indexOf(logLevel);
    if (minLogLevelIdx === -1) {
      throw new Error(`MUI: Log level ${logLevel} not recognized.`);
    }
    const logger = LOG_LEVELS.reduce((loggerObj, method, idx) => {
      if (idx >= minLogLevelIdx) {
        loggerObj[method] = (...args) => {
          const [message, ...other] = args;
          appender[method](`MUI: ${name} - ${message}`, ...other);
        };
      } else {
        loggerObj[method] = noop$1;
      }
      return loggerObj;
    }, {});
    return logger;
  }
  const useGridLoggerFactory = (apiRef2, props) => {
    const getLogger = React__namespace.useCallback((name) => {
      if (forceDebug) {
        return getAppender(name, "debug", props.logger);
      }
      if (!props.logLevel) {
        return noopLogger;
      }
      return getAppender(name, props.logLevel.toString(), props.logger);
    }, [props.logLevel, props.logger]);
    useGridApiMethod(apiRef2, {
      getLogger
    }, "private");
  };
  class Store {
    static create(value) {
      return new Store(value);
    }
    constructor(_value) {
      this.value = void 0;
      this.listeners = void 0;
      this.subscribe = (fn2) => {
        this.listeners.add(fn2);
        return () => {
          this.listeners.delete(fn2);
        };
      };
      this.getSnapshot = () => {
        return this.value;
      };
      this.update = (value) => {
        this.value = value;
        this.listeners.forEach((l2) => l2(value));
      };
      this.value = _value;
      this.listeners = /* @__PURE__ */ new Set();
    }
  }
  class EventManager {
    constructor() {
      this.maxListeners = 20;
      this.warnOnce = false;
      this.events = {};
    }
    on(eventName, listener, options = {}) {
      let collection = this.events[eventName];
      if (!collection) {
        collection = {
          highPriority: /* @__PURE__ */ new Map(),
          regular: /* @__PURE__ */ new Map()
        };
        this.events[eventName] = collection;
      }
      if (options.isFirst) {
        collection.highPriority.set(listener, true);
      } else {
        collection.regular.set(listener, true);
      }
    }
    removeListener(eventName, listener) {
      if (this.events[eventName]) {
        this.events[eventName].regular.delete(listener);
        this.events[eventName].highPriority.delete(listener);
      }
    }
    removeAllListeners() {
      this.events = {};
    }
    emit(eventName, ...args) {
      const collection = this.events[eventName];
      if (!collection) {
        return;
      }
      const highPriorityListeners = Array.from(collection.highPriority.keys());
      const regularListeners = Array.from(collection.regular.keys());
      for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
        const listener = highPriorityListeners[i];
        if (collection.highPriority.has(listener)) {
          listener.apply(this, args);
        }
      }
      for (let i = 0; i < regularListeners.length; i += 1) {
        const listener = regularListeners[i];
        if (collection.regular.has(listener)) {
          listener.apply(this, args);
        }
      }
    }
    once(eventName, listener) {
      const that = this;
      this.on(eventName, function oneTimeListener(...args) {
        that.removeListener(eventName, oneTimeListener);
        listener.apply(that, args);
      });
    }
  }
  const SYMBOL_API_PRIVATE = Symbol("mui.api_private");
  const isSyntheticEvent = (event) => {
    return event.isPropagationStopped !== void 0;
  };
  let globalId = 0;
  function createPrivateAPI(publicApiRef) {
    var _publicApiRef$current;
    const existingPrivateApi = (_publicApiRef$current = publicApiRef.current) == null ? void 0 : _publicApiRef$current[SYMBOL_API_PRIVATE];
    if (existingPrivateApi) {
      return existingPrivateApi;
    }
    const state = {};
    const privateApi = {
      state,
      store: Store.create(state),
      instanceId: {
        id: globalId
      }
    };
    globalId += 1;
    privateApi.getPublicApi = () => publicApiRef.current;
    privateApi.register = (visibility, methods) => {
      Object.keys(methods).forEach((methodName) => {
        const method = methods[methodName];
        const currentPrivateMethod = privateApi[methodName];
        if ((currentPrivateMethod == null ? void 0 : currentPrivateMethod.spying) === true) {
          currentPrivateMethod.target = method;
        } else {
          privateApi[methodName] = method;
        }
        if (visibility === "public") {
          const publicApi = publicApiRef.current;
          const currentPublicMethod = publicApi[methodName];
          if ((currentPublicMethod == null ? void 0 : currentPublicMethod.spying) === true) {
            currentPublicMethod.target = method;
          } else {
            publicApi[methodName] = method;
          }
        }
      });
    };
    privateApi.register("private", {
      caches: {},
      eventManager: new EventManager()
    });
    return privateApi;
  }
  function createPublicAPI(privateApiRef) {
    const publicApi = {
      get state() {
        return privateApiRef.current.state;
      },
      get store() {
        return privateApiRef.current.store;
      },
      get instanceId() {
        return privateApiRef.current.instanceId;
      },
      [SYMBOL_API_PRIVATE]: privateApiRef.current
    };
    return publicApi;
  }
  function useGridApiInitialization(inputApiRef, props) {
    const publicApiRef = React__namespace.useRef();
    const privateApiRef = React__namespace.useRef();
    if (!privateApiRef.current) {
      privateApiRef.current = createPrivateAPI(publicApiRef);
    }
    if (!publicApiRef.current) {
      publicApiRef.current = createPublicAPI(privateApiRef);
    }
    const publishEvent = React__namespace.useCallback((...args) => {
      const [name, params, event = {}] = args;
      event.defaultMuiPrevented = false;
      if (isSyntheticEvent(event) && event.isPropagationStopped()) {
        return;
      }
      const details = props.signature === GridSignature.DataGridPro ? {
        api: privateApiRef.current.getPublicApi()
      } : {};
      privateApiRef.current.eventManager.emit(name, params, event, details);
    }, [privateApiRef, props.signature]);
    const subscribeEvent = React__namespace.useCallback((event, handler, options) => {
      privateApiRef.current.eventManager.on(event, handler, options);
      const api = privateApiRef.current;
      return () => {
        api.eventManager.removeListener(event, handler);
      };
    }, [privateApiRef]);
    useGridApiMethod(privateApiRef, {
      subscribeEvent,
      publishEvent
    }, "public");
    React__namespace.useImperativeHandle(inputApiRef, () => publicApiRef.current, [publicApiRef]);
    React__namespace.useEffect(() => {
      const api = privateApiRef.current;
      return () => {
        api.publishEvent("unmount");
      };
    }, [privateApiRef]);
    return privateApiRef;
  }
  const useGridLocaleText = (apiRef2, props) => {
    const getLocaleText = React__namespace.useCallback((key) => {
      if (props.localeText[key] == null) {
        throw new Error(`Missing translation for key ${key}.`);
      }
      return props.localeText[key];
    }, [props.localeText]);
    apiRef2.current.register("public", {
      getLocaleText
    });
  };
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  const useGridPipeProcessing = (apiRef2) => {
    const processorsCache = React__namespace.useRef({});
    const isRunning = React__namespace.useRef(false);
    const runAppliers = React__namespace.useCallback((groupCache) => {
      if (isRunning.current || !groupCache) {
        return;
      }
      isRunning.current = true;
      Object.values(groupCache.appliers).forEach((callback) => {
        callback();
      });
      isRunning.current = false;
    }, []);
    const registerPipeProcessor = React__namespace.useCallback((group, id, processor) => {
      if (!processorsCache.current[group]) {
        processorsCache.current[group] = {
          processors: /* @__PURE__ */ new Map(),
          appliers: {}
        };
      }
      const groupCache = processorsCache.current[group];
      const oldProcessor = groupCache.processors.get(id);
      if (oldProcessor !== processor) {
        groupCache.processors.set(id, processor);
        runAppliers(groupCache);
      }
      return () => {
        processorsCache.current[group].processors.set(id, null);
      };
    }, [runAppliers]);
    const registerPipeApplier = React__namespace.useCallback((group, id, applier) => {
      if (!processorsCache.current[group]) {
        processorsCache.current[group] = {
          processors: /* @__PURE__ */ new Map(),
          appliers: {}
        };
      }
      processorsCache.current[group].appliers[id] = applier;
      return () => {
        const _appliers = processorsCache.current[group].appliers, otherAppliers = _objectWithoutPropertiesLoose(_appliers, [id].map(_toPropertyKey));
        processorsCache.current[group].appliers = otherAppliers;
      };
    }, []);
    const requestPipeProcessorsApplication = React__namespace.useCallback((group) => {
      const groupCache = processorsCache.current[group];
      runAppliers(groupCache);
    }, [runAppliers]);
    const applyPipeProcessors = React__namespace.useCallback((...args) => {
      const [group, value, context] = args;
      if (!processorsCache.current[group]) {
        return value;
      }
      const preProcessors = Array.from(processorsCache.current[group].processors.values());
      return preProcessors.reduce((acc, preProcessor) => {
        if (!preProcessor) {
          return acc;
        }
        return preProcessor(acc, context);
      }, value);
    }, []);
    const preProcessingPrivateApi = {
      registerPipeProcessor,
      registerPipeApplier,
      requestPipeProcessorsApplication
    };
    const preProcessingPublicApi = {
      unstable_applyPipeProcessors: applyPipeProcessors
    };
    useGridApiMethod(apiRef2, preProcessingPrivateApi, "private");
    useGridApiMethod(apiRef2, preProcessingPublicApi, "public");
  };
  const useGridRegisterPipeProcessor = (apiRef2, group, callback) => {
    const cleanup = React__namespace.useRef();
    const id = React__namespace.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
    const registerPreProcessor = React__namespace.useCallback(() => {
      cleanup.current = apiRef2.current.registerPipeProcessor(group, id.current, callback);
    }, [apiRef2, callback, group]);
    useFirstRender(() => {
      registerPreProcessor();
    });
    const isFirstRender = React__namespace.useRef(true);
    React__namespace.useEffect(() => {
      if (isFirstRender.current) {
        isFirstRender.current = false;
      } else {
        registerPreProcessor();
      }
      return () => {
        if (cleanup.current) {
          cleanup.current();
          cleanup.current = null;
        }
      };
    }, [registerPreProcessor]);
  };
  const useGridRegisterPipeApplier = (apiRef2, group, callback) => {
    const cleanup = React__namespace.useRef();
    const id = React__namespace.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
    const registerPreProcessor = React__namespace.useCallback(() => {
      cleanup.current = apiRef2.current.registerPipeApplier(group, id.current, callback);
    }, [apiRef2, callback, group]);
    useFirstRender(() => {
      registerPreProcessor();
    });
    const isFirstRender = React__namespace.useRef(true);
    React__namespace.useEffect(() => {
      if (isFirstRender.current) {
        isFirstRender.current = false;
      } else {
        registerPreProcessor();
      }
      return () => {
        if (cleanup.current) {
          cleanup.current();
          cleanup.current = null;
        }
      };
    }, [registerPreProcessor]);
  };
  const useGridRegisterStrategyProcessor = (apiRef2, strategyName, group, processor) => {
    const registerPreProcessor = React__namespace.useCallback(() => {
      apiRef2.current.registerStrategyProcessor(strategyName, group, processor);
    }, [apiRef2, processor, group, strategyName]);
    useFirstRender(() => {
      registerPreProcessor();
    });
    const isFirstRender = React__namespace.useRef(true);
    React__namespace.useEffect(() => {
      if (isFirstRender.current) {
        isFirstRender.current = false;
      } else {
        registerPreProcessor();
      }
    }, [registerPreProcessor]);
  };
  const GRID_DEFAULT_STRATEGY = "none";
  const GRID_STRATEGIES_PROCESSORS = {
    rowTreeCreation: "rowTree",
    filtering: "rowTree",
    sorting: "rowTree",
    visibleRowsLookupCreation: "rowTree"
  };
  const useGridStrategyProcessing = (apiRef2) => {
    const availableStrategies = React__namespace.useRef(/* @__PURE__ */ new Map());
    const strategiesCache = React__namespace.useRef({});
    const registerStrategyProcessor = React__namespace.useCallback((strategyName, processorName, processor) => {
      const cleanup = () => {
        const _ref = strategiesCache.current[processorName], otherProcessors = _objectWithoutPropertiesLoose(_ref, [strategyName].map(_toPropertyKey));
        strategiesCache.current[processorName] = otherProcessors;
      };
      if (!strategiesCache.current[processorName]) {
        strategiesCache.current[processorName] = {};
      }
      const groupPreProcessors = strategiesCache.current[processorName];
      const previousProcessor = groupPreProcessors[strategyName];
      groupPreProcessors[strategyName] = processor;
      if (!previousProcessor || previousProcessor === processor) {
        return cleanup;
      }
      if (strategyName === apiRef2.current.getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {
        apiRef2.current.publishEvent("activeStrategyProcessorChange", processorName);
      }
      return cleanup;
    }, [apiRef2]);
    const applyStrategyProcessor = React__namespace.useCallback((processorName, params) => {
      const activeStrategy = apiRef2.current.getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);
      if (activeStrategy == null) {
        throw new Error("Can't apply a strategy processor before defining an active strategy");
      }
      const groupCache = strategiesCache.current[processorName];
      if (!groupCache || !groupCache[activeStrategy]) {
        throw new Error(`No processor found for processor "${processorName}" on strategy "${activeStrategy}"`);
      }
      const processor = groupCache[activeStrategy];
      return processor(params);
    }, [apiRef2]);
    const getActiveStrategy = React__namespace.useCallback((strategyGroup) => {
      var _availableStrategyEnt;
      const strategyEntries = Array.from(availableStrategies.current.entries());
      const availableStrategyEntry = strategyEntries.find(([, strategy]) => {
        if (strategy.group !== strategyGroup) {
          return false;
        }
        return strategy.isAvailable();
      });
      return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;
    }, []);
    const setStrategyAvailability = React__namespace.useCallback((strategyGroup, strategyName, isAvailable) => {
      availableStrategies.current.set(strategyName, {
        group: strategyGroup,
        isAvailable
      });
      apiRef2.current.publishEvent("strategyAvailabilityChange");
    }, [apiRef2]);
    const strategyProcessingApi = {
      registerStrategyProcessor,
      applyStrategyProcessor,
      getActiveStrategy,
      setStrategyAvailability
    };
    useGridApiMethod(apiRef2, strategyProcessingApi, "private");
  };
  const useGridStateInitialization = (apiRef2, props) => {
    const controlStateMapRef = React__namespace.useRef({});
    const [, rawForceUpdate] = React__namespace.useState();
    const registerControlState = React__namespace.useCallback((controlStateItem) => {
      controlStateMapRef.current[controlStateItem.stateId] = controlStateItem;
    }, []);
    const setState = React__namespace.useCallback((state, reason) => {
      let newState;
      if (isFunction$1(state)) {
        newState = state(apiRef2.current.state);
      } else {
        newState = state;
      }
      if (apiRef2.current.state === newState) {
        return false;
      }
      let ignoreSetState = false;
      const updatedControlStateIds = [];
      Object.keys(controlStateMapRef.current).forEach((stateId) => {
        const controlState = controlStateMapRef.current[stateId];
        const oldSubState = controlState.stateSelector(apiRef2.current.state, apiRef2.current.instanceId);
        const newSubState = controlState.stateSelector(newState, apiRef2.current.instanceId);
        if (newSubState === oldSubState) {
          return;
        }
        updatedControlStateIds.push({
          stateId: controlState.stateId,
          hasPropChanged: newSubState !== controlState.propModel
        });
        if (controlState.propModel !== void 0 && newSubState !== controlState.propModel) {
          ignoreSetState = true;
        }
      });
      if (updatedControlStateIds.length > 1) {
        throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map((el) => el.stateId).join(", ")} in the same transaction.`);
      }
      if (!ignoreSetState) {
        apiRef2.current.state = newState;
        if (apiRef2.current.publishEvent) {
          apiRef2.current.publishEvent("stateChange", newState);
        }
        apiRef2.current.store.update(newState);
      }
      if (updatedControlStateIds.length === 1) {
        const {
          stateId,
          hasPropChanged
        } = updatedControlStateIds[0];
        const controlState = controlStateMapRef.current[stateId];
        const model = controlState.stateSelector(newState, apiRef2.current.instanceId);
        if (controlState.propOnChange && hasPropChanged) {
          const details = props.signature === GridSignature.DataGridPro ? {
            api: apiRef2.current,
            reason
          } : {
            reason
          };
          controlState.propOnChange(model, details);
        }
        if (!ignoreSetState) {
          apiRef2.current.publishEvent(controlState.changeEvent, model, {
            reason
          });
        }
      }
      return !ignoreSetState;
    }, [apiRef2, props.signature]);
    const updateControlState = React__namespace.useCallback((key, state, reason) => {
      return apiRef2.current.setState((previousState) => {
        return _extends({}, previousState, {
          [key]: state(previousState[key])
        });
      }, reason);
    }, [apiRef2]);
    const forceUpdate = React__namespace.useCallback(() => rawForceUpdate(() => apiRef2.current.state), [apiRef2]);
    const publicStateApi = {
      setState,
      forceUpdate
    };
    const privateStateApi = {
      updateControlState,
      registerControlState
    };
    useGridApiMethod(apiRef2, publicStateApi, "public");
    useGridApiMethod(apiRef2, privateStateApi, "private");
  };
  const useGridInitialization = (inputApiRef, props) => {
    const privateApiRef = useGridApiInitialization(inputApiRef, props);
    useGridLoggerFactory(privateApiRef, props);
    useGridStateInitialization(privateApiRef, props);
    useGridPipeProcessing(privateApiRef);
    useGridStrategyProcessing(privateApiRef);
    useGridLocaleText(privateApiRef, props);
    return privateApiRef;
  };
  const useGridInitializeState = (initializer, privateApiRef, props) => {
    const isInitialized = React__namespace.useRef(false);
    if (!isInitialized.current) {
      privateApiRef.current.state = initializer(privateApiRef.current.state, props, privateApiRef);
      isInitialized.current = true;
    }
  };
  const dateRegex = /(\d+)-(\d+)-(\d+)/;
  const dateTimeRegex = /(\d+)-(\d+)-(\d+)T(\d+):(\d+)/;
  function buildApplyFilterFn(filterItem2, compareFn, showTime, keepHours) {
    if (!filterItem2.value) {
      return null;
    }
    const [year, month, day, hour, minute] = filterItem2.value.match(showTime ? dateTimeRegex : dateRegex).slice(1).map(Number);
    const time = new Date(year, month - 1, day, hour || 0, minute || 0).getTime();
    return (value) => {
      if (!value) {
        return false;
      }
      if (keepHours) {
        return compareFn(value.getTime(), time);
      }
      const dateCopy = new Date(value);
      const timeToCompare = dateCopy.setHours(showTime ? value.getHours() : 0, showTime ? value.getMinutes() : 0, 0, 0);
      return compareFn(timeToCompare, time);
    };
  }
  const getGridDateOperators = (showTime) => convertLegacyOperators([{
    value: "is",
    getApplyFilterFnV7: (filterItem2) => {
      return buildApplyFilterFn(filterItem2, (value1, value2) => value1 === value2, showTime);
    },
    InputComponent: GridFilterInputDate,
    InputComponentProps: {
      type: showTime ? "datetime-local" : "date"
    }
  }, {
    value: "not",
    getApplyFilterFnV7: (filterItem2) => {
      return buildApplyFilterFn(filterItem2, (value1, value2) => value1 !== value2, showTime);
    },
    InputComponent: GridFilterInputDate,
    InputComponentProps: {
      type: showTime ? "datetime-local" : "date"
    }
  }, {
    value: "after",
    getApplyFilterFnV7: (filterItem2) => {
      return buildApplyFilterFn(filterItem2, (value1, value2) => value1 > value2, showTime);
    },
    InputComponent: GridFilterInputDate,
    InputComponentProps: {
      type: showTime ? "datetime-local" : "date"
    }
  }, {
    value: "onOrAfter",
    getApplyFilterFnV7: (filterItem2) => {
      return buildApplyFilterFn(filterItem2, (value1, value2) => value1 >= value2, showTime);
    },
    InputComponent: GridFilterInputDate,
    InputComponentProps: {
      type: showTime ? "datetime-local" : "date"
    }
  }, {
    value: "before",
    getApplyFilterFnV7: (filterItem2) => {
      return buildApplyFilterFn(filterItem2, (value1, value2) => value1 < value2, showTime, !showTime);
    },
    InputComponent: GridFilterInputDate,
    InputComponentProps: {
      type: showTime ? "datetime-local" : "date"
    }
  }, {
    value: "onOrBefore",
    getApplyFilterFnV7: (filterItem2) => {
      return buildApplyFilterFn(filterItem2, (value1, value2) => value1 <= value2, showTime);
    },
    InputComponent: GridFilterInputDate,
    InputComponentProps: {
      type: showTime ? "datetime-local" : "date"
    }
  }, {
    value: "isEmpty",
    getApplyFilterFnV7: () => {
      return (value) => {
        return value == null;
      };
    },
    requiresFilterValue: false
  }, {
    value: "isNotEmpty",
    getApplyFilterFnV7: () => {
      return (value) => {
        return value != null;
      };
    },
    requiresFilterValue: false
  }]);
  function throwIfNotDateObject({
    value,
    columnType,
    rowId,
    field
  }) {
    if (!(value instanceof Date)) {
      throw new Error([`MUI: \`${columnType}\` column type only accepts \`Date\` objects as values.`, "Use `valueGetter` to transform the value into a `Date` object.", `Row ID: ${rowId}, field: "${field}".`].join("\n"));
    }
  }
  function gridDateFormatter({
    value,
    field,
    id
  }) {
    if (!value) {
      return "";
    }
    throwIfNotDateObject({
      value,
      columnType: "date",
      rowId: id,
      field
    });
    return value.toLocaleDateString();
  }
  function gridDateTimeFormatter({
    value,
    field,
    id
  }) {
    if (!value) {
      return "";
    }
    throwIfNotDateObject({
      value,
      columnType: "dateTime",
      rowId: id,
      field
    });
    return value.toLocaleString();
  }
  const GRID_DATE_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
    type: "date",
    sortComparator: gridDateComparator,
    valueFormatter: gridDateFormatter,
    filterOperators: getGridDateOperators(),
    renderEditCell: renderEditDateCell,
    getApplyQuickFilterFn: void 0,
    getApplyQuickFilterFnV7: void 0,
    // @ts-ignore
    pastedValueParser: (value) => new Date(value)
  });
  const GRID_DATETIME_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
    type: "dateTime",
    sortComparator: gridDateComparator,
    valueFormatter: gridDateTimeFormatter,
    filterOperators: getGridDateOperators(true),
    renderEditCell: renderEditDateCell,
    getApplyQuickFilterFn: void 0,
    getApplyQuickFilterFnV7: void 0,
    // @ts-ignore
    pastedValueParser: (value) => new Date(value)
  });
  const parseNumericValue = (value) => {
    if (value == null) {
      return null;
    }
    return Number(value);
  };
  const getGridNumericQuickFilterFn = tagInternalFilter((value) => {
    if (value == null || Number.isNaN(value) || value === "") {
      return null;
    }
    return (columnValue) => {
      return parseNumericValue(columnValue) === parseNumericValue(value);
    };
  });
  const getGridNumericOperators = () => convertLegacyOperators([{
    value: "=",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || Number.isNaN(filterItem2.value)) {
        return null;
      }
      return (value) => {
        return parseNumericValue(value) === filterItem2.value;
      };
    },
    InputComponent: GridFilterInputValue,
    InputComponentProps: {
      type: "number"
    }
  }, {
    value: "!=",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || Number.isNaN(filterItem2.value)) {
        return null;
      }
      return (value) => {
        return parseNumericValue(value) !== filterItem2.value;
      };
    },
    InputComponent: GridFilterInputValue,
    InputComponentProps: {
      type: "number"
    }
  }, {
    value: ">",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || Number.isNaN(filterItem2.value)) {
        return null;
      }
      return (value) => {
        if (value == null) {
          return false;
        }
        return parseNumericValue(value) > filterItem2.value;
      };
    },
    InputComponent: GridFilterInputValue,
    InputComponentProps: {
      type: "number"
    }
  }, {
    value: ">=",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || Number.isNaN(filterItem2.value)) {
        return null;
      }
      return (value) => {
        if (value == null) {
          return false;
        }
        return parseNumericValue(value) >= filterItem2.value;
      };
    },
    InputComponent: GridFilterInputValue,
    InputComponentProps: {
      type: "number"
    }
  }, {
    value: "<",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || Number.isNaN(filterItem2.value)) {
        return null;
      }
      return (value) => {
        if (value == null) {
          return false;
        }
        return parseNumericValue(value) < filterItem2.value;
      };
    },
    InputComponent: GridFilterInputValue,
    InputComponentProps: {
      type: "number"
    }
  }, {
    value: "<=",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || Number.isNaN(filterItem2.value)) {
        return null;
      }
      return (value) => {
        if (value == null) {
          return false;
        }
        return parseNumericValue(value) <= filterItem2.value;
      };
    },
    InputComponent: GridFilterInputValue,
    InputComponentProps: {
      type: "number"
    }
  }, {
    value: "isEmpty",
    getApplyFilterFnV7: () => {
      return (value) => {
        return value == null;
      };
    },
    requiresFilterValue: false
  }, {
    value: "isNotEmpty",
    getApplyFilterFnV7: () => {
      return (value) => {
        return value != null;
      };
    },
    requiresFilterValue: false
  }, {
    value: "isAnyOf",
    getApplyFilterFnV7: (filterItem2) => {
      if (!Array.isArray(filterItem2.value) || filterItem2.value.length === 0) {
        return null;
      }
      return (value) => {
        return value != null && filterItem2.value.includes(Number(value));
      };
    },
    InputComponent: GridFilterInputMultipleValue,
    InputComponentProps: {
      type: "number"
    }
  }]);
  const GRID_NUMERIC_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
    type: "number",
    align: "right",
    headerAlign: "right",
    sortComparator: gridNumberComparator,
    valueParser: (value) => value === "" ? null : Number(value),
    valueFormatter: ({
      value
    }) => isNumber$1(value) ? value.toLocaleString() : value || "",
    filterOperators: getGridNumericOperators(),
    getApplyQuickFilterFn: convertQuickFilterV7ToLegacy(getGridNumericQuickFilterFn),
    getApplyQuickFilterFnV7: getGridNumericQuickFilterFn
  });
  const parseObjectValue = (value) => {
    if (value == null || !isObject$1(value)) {
      return value;
    }
    return value.value;
  };
  const getGridSingleSelectOperators = () => convertLegacyOperators([{
    value: "is",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || filterItem2.value === "") {
        return null;
      }
      return (value) => parseObjectValue(value) === parseObjectValue(filterItem2.value);
    },
    InputComponent: GridFilterInputSingleSelect
  }, {
    value: "not",
    getApplyFilterFnV7: (filterItem2) => {
      if (filterItem2.value == null || filterItem2.value === "") {
        return null;
      }
      return (value) => parseObjectValue(value) !== parseObjectValue(filterItem2.value);
    },
    InputComponent: GridFilterInputSingleSelect
  }, {
    value: "isAnyOf",
    getApplyFilterFnV7: (filterItem2) => {
      if (!Array.isArray(filterItem2.value) || filterItem2.value.length === 0) {
        return null;
      }
      const filterItemValues = filterItem2.value.map(parseObjectValue);
      return (value) => filterItemValues.includes(parseObjectValue(value));
    },
    InputComponent: GridFilterInputMultipleSingleSelect
  }]);
  const isArrayOfObjects = (options) => {
    return typeof options[0] === "object";
  };
  const defaultGetOptionValue = (value) => {
    return isObject$1(value) ? value.value : value;
  };
  const defaultGetOptionLabel = (value) => {
    return isObject$1(value) ? value.label : String(value);
  };
  const GRID_SINGLE_SELECT_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
    type: "singleSelect",
    getOptionLabel: defaultGetOptionLabel,
    getOptionValue: defaultGetOptionValue,
    valueFormatter(params) {
      const {
        id,
        field,
        value,
        api
      } = params;
      const colDef = params.api.getColumn(field);
      if (!isSingleSelectColDef(colDef)) {
        return "";
      }
      let valueOptions;
      if (typeof colDef.valueOptions === "function") {
        valueOptions = colDef.valueOptions({
          id,
          row: id ? api.getRow(id) : null,
          field
        });
      } else {
        valueOptions = colDef.valueOptions;
      }
      if (value == null) {
        return "";
      }
      if (!valueOptions) {
        return value;
      }
      if (!isArrayOfObjects(valueOptions)) {
        return colDef.getOptionLabel(value);
      }
      const valueOption = valueOptions.find((option) => colDef.getOptionValue(option) === value);
      return valueOption ? colDef.getOptionLabel(valueOption) : "";
    },
    renderEditCell: renderEditSingleSelectCell,
    filterOperators: getGridSingleSelectOperators(),
    // @ts-ignore
    pastedValueParser: (value, params) => {
      const colDef = params.colDef;
      const colDefValueOptions = colDef.valueOptions;
      const valueOptions = typeof colDefValueOptions === "function" ? colDefValueOptions({
        field: colDef.field
      }) : colDefValueOptions || [];
      const getOptionValue = colDef.getOptionValue;
      const valueOption = valueOptions.find((option) => {
        if (getOptionValue(option) === value) {
          return true;
        }
        return false;
      });
      if (valueOption) {
        return value;
      }
      return void 0;
    }
  });
  const DEFAULT_GRID_COL_TYPE_KEY = "__default__";
  const getGridDefaultColumnTypes = () => {
    const nativeColumnTypes = {
      string: GRID_STRING_COL_DEF,
      number: GRID_NUMERIC_COL_DEF,
      date: GRID_DATE_COL_DEF,
      dateTime: GRID_DATETIME_COL_DEF,
      boolean: GRID_BOOLEAN_COL_DEF,
      singleSelect: GRID_SINGLE_SELECT_COL_DEF,
      [GRID_ACTIONS_COLUMN_TYPE]: GRID_ACTIONS_COL_DEF,
      [DEFAULT_GRID_COL_TYPE_KEY]: GRID_STRING_COL_DEF
    };
    return nativeColumnTypes;
  };
  function sanitizeCellValue(value, delimiterCharacter) {
    if (typeof value === "string") {
      if ([delimiterCharacter, "\n", "\r", '"'].some((delimiter2) => value.includes(delimiter2))) {
        return `"${value.replace(/"/g, '""')}"`;
      }
      return value;
    }
    return value;
  }
  const serializeCellValue = (cellParams, options) => {
    const {
      delimiterCharacter,
      ignoreValueFormatter
    } = options;
    let value;
    if (ignoreValueFormatter) {
      var _cellParams$value2;
      const columnType = cellParams.colDef.type;
      if (columnType === "number") {
        value = String(cellParams.value);
      } else if (columnType === "date" || columnType === "dateTime") {
        var _cellParams$value;
        value = (_cellParams$value = cellParams.value) == null ? void 0 : _cellParams$value.toISOString();
      } else if (typeof ((_cellParams$value2 = cellParams.value) == null ? void 0 : _cellParams$value2.toString) === "function") {
        value = cellParams.value.toString();
      } else {
        value = cellParams.value;
      }
    } else {
      value = cellParams.formattedValue;
    }
    return sanitizeCellValue(value, delimiterCharacter);
  };
  buildWarning(["MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.", "You can provide a `valueFormatter` with a string representation to be used."]);
  class CSVRow {
    constructor(options) {
      this.options = void 0;
      this.rowString = "";
      this.isEmpty = true;
      this.options = options;
    }
    addValue(value) {
      if (!this.isEmpty) {
        this.rowString += this.options.delimiterCharacter;
      }
      if (value === null || value === void 0) {
        this.rowString += "";
      } else if (typeof this.options.sanitizeCellValue === "function") {
        this.rowString += this.options.sanitizeCellValue(value, this.options.delimiterCharacter);
      } else {
        this.rowString += value;
      }
      this.isEmpty = false;
    }
    getRowString() {
      return this.rowString;
    }
  }
  const serializeRow = ({
    id,
    columns,
    getCellParams,
    delimiterCharacter,
    ignoreValueFormatter
  }) => {
    const row = new CSVRow({
      delimiterCharacter
    });
    columns.forEach((column2) => {
      const cellParams = getCellParams(id, column2.field);
      row.addValue(serializeCellValue(cellParams, {
        delimiterCharacter,
        ignoreValueFormatter
      }));
    });
    return row.getRowString();
  };
  function buildCSV(options) {
    const {
      columns,
      rowIds,
      delimiterCharacter,
      includeHeaders,
      includeColumnGroupsHeaders,
      ignoreValueFormatter,
      apiRef: apiRef2
    } = options;
    const CSVBody = rowIds.reduce((acc, id) => `${acc}${serializeRow({
    id,
    columns,
    getCellParams: apiRef2.current.getCellParams,
    delimiterCharacter,
    ignoreValueFormatter
  })}\r
`, "").trim();
    if (!includeHeaders) {
      return CSVBody;
    }
    const filteredColumns = columns.filter((column2) => column2.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);
    const headerRows = [];
    if (includeColumnGroupsHeaders) {
      const columnGroupLookup = apiRef2.current.unstable_getAllGroupDetails();
      let maxColumnGroupsDepth = 0;
      const columnGroupPathsLookup = filteredColumns.reduce((acc, column2) => {
        const columnGroupPath = apiRef2.current.unstable_getColumnGroupPath(column2.field);
        acc[column2.field] = columnGroupPath;
        maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);
        return acc;
      }, {});
      for (let i = 0; i < maxColumnGroupsDepth; i += 1) {
        const headerGroupRow = new CSVRow({
          delimiterCharacter,
          sanitizeCellValue
        });
        headerRows.push(headerGroupRow);
        filteredColumns.forEach((column2) => {
          const columnGroupId = (columnGroupPathsLookup[column2.field] || [])[i];
          const columnGroup = columnGroupLookup[columnGroupId];
          headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : "");
        });
      }
    }
    const mainHeaderRow = new CSVRow({
      delimiterCharacter,
      sanitizeCellValue
    });
    filteredColumns.forEach((column2) => {
      mainHeaderRow.addValue(column2.headerName || column2.field);
    });
    headerRows.push(mainHeaderRow);
    const CSVHead = `${headerRows.map((row) => row.getRowString()).join("\r\n")}\r
`;
    return `${CSVHead}${CSVBody}`.trim();
  }
  function writeToClipboardPolyfill(data) {
    const span = document.createElement("span");
    span.style.whiteSpace = "pre";
    span.style.userSelect = "all";
    span.style.opacity = "0px";
    span.textContent = data;
    document.body.appendChild(span);
    const range = document.createRange();
    range.selectNode(span);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
    try {
      document.execCommand("copy");
    } finally {
      document.body.removeChild(span);
    }
  }
  function copyToClipboard(data) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(data).catch(() => {
        writeToClipboardPolyfill(data);
      });
    } else {
      writeToClipboardPolyfill(data);
    }
  }
  function hasNativeSelection(element) {
    var _window$getSelection;
    if ((_window$getSelection = window.getSelection()) != null && _window$getSelection.toString()) {
      return true;
    }
    if (element && (element.selectionEnd || 0) - (element.selectionStart || 0) > 0) {
      return true;
    }
    return false;
  }
  const useGridClipboard = (apiRef2, props) => {
    const ignoreValueFormatterProp = props.unstable_ignoreValueFormatterDuringExport;
    const ignoreValueFormatter = (typeof ignoreValueFormatterProp === "object" ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.clipboardExport : ignoreValueFormatterProp) || false;
    const clipboardCopyCellDelimiter = props.clipboardCopyCellDelimiter;
    const handleCopy = React__namespace.useCallback((event) => {
      if (!((event.ctrlKey || event.metaKey) && event.key === "c")) {
        return;
      }
      if (hasNativeSelection(event.target)) {
        return;
      }
      let textToCopy = "";
      const selectedRows = apiRef2.current.getSelectedRows();
      if (selectedRows.size > 0) {
        textToCopy = apiRef2.current.getDataAsCsv({
          includeHeaders: false,
          // TODO: make it configurable
          delimiter: clipboardCopyCellDelimiter
        });
      } else {
        const focusedCell = gridFocusCellSelector(apiRef2);
        if (focusedCell) {
          const cellParams = apiRef2.current.getCellParams(focusedCell.id, focusedCell.field);
          textToCopy = serializeCellValue(cellParams, {
            delimiterCharacter: clipboardCopyCellDelimiter,
            ignoreValueFormatter
          });
        }
      }
      textToCopy = apiRef2.current.unstable_applyPipeProcessors("clipboardCopy", textToCopy);
      if (textToCopy) {
        copyToClipboard(textToCopy);
        apiRef2.current.publishEvent("clipboardCopy", textToCopy);
      }
    }, [apiRef2, ignoreValueFormatter, clipboardCopyCellDelimiter]);
    useGridNativeEventListener(apiRef2, apiRef2.current.rootElementRef, "keydown", handleCopy);
    useGridApiOptionHandler(apiRef2, "clipboardCopy", props.onClipboardCopy);
  };
  const columnMenuStateInitializer = (state) => _extends({}, state, {
    columnMenu: {
      open: false
    }
  });
  const useGridColumnMenu = (apiRef2) => {
    const logger = useGridLogger(apiRef2, "useGridColumnMenu");
    const showColumnMenu = React__namespace.useCallback((field) => {
      const shouldUpdate = apiRef2.current.setState((state) => {
        if (state.columnMenu.open && state.columnMenu.field === field) {
          return state;
        }
        logger.debug("Opening Column Menu");
        return _extends({}, state, {
          columnMenu: {
            open: true,
            field
          }
        });
      });
      if (shouldUpdate) {
        apiRef2.current.hidePreferences();
        apiRef2.current.forceUpdate();
      }
    }, [apiRef2, logger]);
    const hideColumnMenu = React__namespace.useCallback(() => {
      const columnMenuState = gridColumnMenuSelector(apiRef2.current.state);
      if (columnMenuState.field) {
        const columnLookup = gridColumnLookupSelector(apiRef2);
        const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef2);
        const orderedFields = gridColumnFieldsSelector(apiRef2);
        let fieldToFocus = columnMenuState.field;
        if (!columnLookup[fieldToFocus]) {
          fieldToFocus = orderedFields[0];
        }
        if (columnVisibilityModel[fieldToFocus] === false) {
          const visibleOrderedFields = orderedFields.filter((field) => {
            if (field === fieldToFocus) {
              return true;
            }
            return columnVisibilityModel[field] !== false;
          });
          const fieldIndex = visibleOrderedFields.indexOf(fieldToFocus);
          fieldToFocus = visibleOrderedFields[fieldIndex + 1] || visibleOrderedFields[fieldIndex - 1];
        }
        apiRef2.current.setColumnHeaderFocus(fieldToFocus);
      }
      const shouldUpdate = apiRef2.current.setState((state) => {
        if (!state.columnMenu.open && state.columnMenu.field === void 0) {
          return state;
        }
        logger.debug("Hiding Column Menu");
        return _extends({}, state, {
          columnMenu: _extends({}, state.columnMenu, {
            open: false,
            field: void 0
          })
        });
      });
      if (shouldUpdate) {
        apiRef2.current.forceUpdate();
      }
    }, [apiRef2, logger]);
    const toggleColumnMenu = React__namespace.useCallback((field) => {
      logger.debug("Toggle Column Menu");
      const columnMenu = gridColumnMenuSelector(apiRef2.current.state);
      if (!columnMenu.open || columnMenu.field !== field) {
        showColumnMenu(field);
      } else {
        hideColumnMenu();
      }
    }, [apiRef2, logger, showColumnMenu, hideColumnMenu]);
    const columnMenuApi = {
      showColumnMenu,
      hideColumnMenu,
      toggleColumnMenu
    };
    useGridApiMethod(apiRef2, columnMenuApi, "public");
    useGridApiEventHandler(apiRef2, "columnResizeStart", hideColumnMenu);
    useGridApiEventHandler(apiRef2, "virtualScrollerWheel", apiRef2.current.hideColumnMenu);
    useGridApiEventHandler(apiRef2, "virtualScrollerTouchMove", apiRef2.current.hideColumnMenu);
  };
  const COLUMNS_DIMENSION_PROPERTIES = ["maxWidth", "minWidth", "width", "flex"];
  function computeFlexColumnsWidth({
    initialFreeSpace,
    totalFlexUnits,
    flexColumns
  }) {
    const uniqueFlexColumns = new Set(flexColumns.map((col) => col.field));
    const flexColumnsLookup = {
      all: {},
      frozenFields: [],
      freeze: (field) => {
        const value = flexColumnsLookup.all[field];
        if (value && value.frozen !== true) {
          flexColumnsLookup.all[field].frozen = true;
          flexColumnsLookup.frozenFields.push(field);
        }
      }
    };
    function loopOverFlexItems() {
      if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {
        return;
      }
      const violationsLookup = {
        min: {},
        max: {}
      };
      let remainingFreeSpace = initialFreeSpace;
      let flexUnits = totalFlexUnits;
      let totalViolation = 0;
      flexColumnsLookup.frozenFields.forEach((field) => {
        remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;
        flexUnits -= flexColumnsLookup.all[field].flex;
      });
      for (let i = 0; i < flexColumns.length; i += 1) {
        const column2 = flexColumns[i];
        if (flexColumnsLookup.all[column2.field] && flexColumnsLookup.all[column2.field].frozen === true) {
          continue;
        }
        const widthPerFlexUnit = remainingFreeSpace / flexUnits;
        let computedWidth = widthPerFlexUnit * column2.flex;
        if (computedWidth < column2.minWidth) {
          totalViolation += column2.minWidth - computedWidth;
          computedWidth = column2.minWidth;
          violationsLookup.min[column2.field] = true;
        } else if (computedWidth > column2.maxWidth) {
          totalViolation += column2.maxWidth - computedWidth;
          computedWidth = column2.maxWidth;
          violationsLookup.max[column2.field] = true;
        }
        flexColumnsLookup.all[column2.field] = {
          frozen: false,
          computedWidth,
          flex: column2.flex
        };
      }
      if (totalViolation < 0) {
        Object.keys(violationsLookup.max).forEach((field) => {
          flexColumnsLookup.freeze(field);
        });
      } else if (totalViolation > 0) {
        Object.keys(violationsLookup.min).forEach((field) => {
          flexColumnsLookup.freeze(field);
        });
      } else {
        flexColumns.forEach(({
          field
        }) => {
          flexColumnsLookup.freeze(field);
        });
      }
      loopOverFlexItems();
    }
    loopOverFlexItems();
    return flexColumnsLookup.all;
  }
  const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {
    const columnsLookup = {};
    let totalFlexUnits = 0;
    let widthAllocatedBeforeFlex = 0;
    const flexColumns = [];
    rawState.orderedFields.forEach((columnField) => {
      const newColumn = _extends({}, rawState.lookup[columnField]);
      if (rawState.columnVisibilityModel[columnField] === false) {
        newColumn.computedWidth = 0;
      } else {
        let computedWidth;
        if (newColumn.flex && newColumn.flex > 0) {
          totalFlexUnits += newColumn.flex;
          computedWidth = 0;
          flexColumns.push(newColumn);
        } else {
          computedWidth = clamp(newColumn.width || GRID_STRING_COL_DEF.width, newColumn.minWidth || GRID_STRING_COL_DEF.minWidth, newColumn.maxWidth || GRID_STRING_COL_DEF.maxWidth);
        }
        widthAllocatedBeforeFlex += computedWidth;
        newColumn.computedWidth = computedWidth;
      }
      columnsLookup[columnField] = newColumn;
    });
    const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);
    if (totalFlexUnits > 0 && viewportInnerWidth > 0) {
      const computedColumnWidths = computeFlexColumnsWidth({
        initialFreeSpace,
        totalFlexUnits,
        flexColumns
      });
      Object.keys(computedColumnWidths).forEach((field) => {
        columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;
      });
    }
    return _extends({}, rawState, {
      lookup: columnsLookup
    });
  };
  const applyInitialState = (columnsState, initialState) => {
    if (!initialState) {
      return columnsState;
    }
    const {
      orderedFields = [],
      dimensions = {}
    } = initialState;
    const columnsWithUpdatedDimensions = Object.keys(dimensions);
    if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {
      return columnsState;
    }
    const orderedFieldsLookup = {};
    const cleanOrderedFields = [];
    for (let i = 0; i < orderedFields.length; i += 1) {
      const field = orderedFields[i];
      if (columnsState.lookup[field]) {
        orderedFieldsLookup[field] = true;
        cleanOrderedFields.push(field);
      }
    }
    const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter((field) => !orderedFieldsLookup[field])];
    const newColumnLookup = _extends({}, columnsState.lookup);
    for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {
      const field = columnsWithUpdatedDimensions[i];
      const newColDef = _extends({}, newColumnLookup[field], {
        hasBeenResized: true
      });
      Object.entries(dimensions[field]).forEach(([key, value]) => {
        newColDef[key] = value === -1 ? Infinity : value;
      });
      newColumnLookup[field] = newColDef;
    }
    const newColumnsState = _extends({}, columnsState, {
      orderedFields: newOrderedFields,
      lookup: newColumnLookup
    });
    return newColumnsState;
  };
  function getDefaultColTypeDef(columnTypes, type) {
    let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
    if (type && columnTypes[type]) {
      colDef = columnTypes[type];
    }
    return colDef;
  }
  const createColumnsState = ({
    apiRef: apiRef2,
    columnsToUpsert,
    initialState,
    columnTypes,
    columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef2),
    keepOnlyColumnsToUpsert = false
  }) => {
    var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current;
    const isInsideStateInitializer = !apiRef2.current.state.columns;
    let columnsState;
    if (isInsideStateInitializer) {
      columnsState = {
        orderedFields: [],
        lookup: {},
        columnVisibilityModel
      };
    } else {
      const currentState = gridColumnsStateSelector(apiRef2.current.state);
      columnsState = {
        orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],
        lookup: _extends({}, currentState.lookup),
        // Will be cleaned later if keepOnlyColumnsToUpsert=true
        columnVisibilityModel
      };
    }
    let columnsToKeep = {};
    if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
      columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {
        [key]: false
      }), {});
    }
    columnsToUpsert.forEach((newColumn) => {
      const {
        field
      } = newColumn;
      columnsToKeep[field] = true;
      let existingState = columnsState.lookup[field];
      if (existingState == null) {
        existingState = _extends({}, getDefaultColTypeDef(columnTypes, newColumn.type), {
          field,
          hasBeenResized: false
        });
        columnsState.orderedFields.push(field);
      } else if (keepOnlyColumnsToUpsert) {
        columnsState.orderedFields.push(field);
      }
      if (existingState && existingState.type !== newColumn.type) {
        existingState = _extends({}, existingState, getDefaultColTypeDef(columnTypes, newColumn.type), {
          field
        });
      }
      let hasBeenResized = existingState.hasBeenResized;
      COLUMNS_DIMENSION_PROPERTIES.forEach((key) => {
        if (newColumn[key] !== void 0) {
          hasBeenResized = true;
          if (newColumn[key] === -1) {
            newColumn[key] = Infinity;
          }
        }
      });
      columnsState.lookup[field] = _extends({}, existingState, newColumn, {
        hasBeenResized
      });
    });
    if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
      Object.keys(columnsState.lookup).forEach((field) => {
        if (!columnsToKeep[field]) {
          delete columnsState.lookup[field];
        }
      });
    }
    const columnsStateWithPreProcessing = apiRef2.current.unstable_applyPipeProcessors("hydrateColumns", columnsState);
    const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);
    return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef2.current).getRootDimensions) == null || (_apiRef$current$getRo2 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);
  };
  const mergeColumnsState = (columnsState) => (state) => _extends({}, state, {
    columns: columnsState
  });
  function getFirstNonSpannedColumnToRender({
    firstColumnToRender,
    apiRef: apiRef2,
    firstRowToRender,
    lastRowToRender,
    visibleRows
  }) {
    let firstNonSpannedColumnToRender = firstColumnToRender;
    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {
      const row = visibleRows[i];
      if (row) {
        const rowId = visibleRows[i].id;
        const cellColSpanInfo = apiRef2.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);
        if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {
          firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;
        }
      }
    }
    return firstNonSpannedColumnToRender;
  }
  function getFirstColumnIndexToRender({
    firstColumnIndex,
    minColumnIndex,
    columnBuffer,
    firstRowToRender,
    lastRowToRender,
    apiRef: apiRef2,
    visibleRows
  }) {
    const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);
    const firstColumnToRender = getFirstNonSpannedColumnToRender({
      firstColumnToRender: initialFirstColumnToRender,
      apiRef: apiRef2,
      firstRowToRender,
      lastRowToRender,
      visibleRows
    });
    return firstColumnToRender;
  }
  function getTotalHeaderHeight(apiRef2, headerHeight) {
    const densityFactor = gridDensityFactorSelector(apiRef2);
    const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef2);
    return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);
  }
  const defaultColumnTypes = getGridDefaultColumnTypes();
  const columnsStateInitializer = (state, props, apiRef2) => {
    var _props$initialState, _ref, _props$columnVisibili, _props$initialState2;
    const columnsState = createColumnsState({
      apiRef: apiRef2,
      columnTypes: defaultColumnTypes,
      columnsToUpsert: props.columns,
      initialState: (_props$initialState = props.initialState) == null ? void 0 : _props$initialState.columns,
      columnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.columns) == null ? void 0 : _props$initialState2.columnVisibilityModel) != null ? _ref : {},
      keepOnlyColumnsToUpsert: true
    });
    return _extends({}, state, {
      columns: columnsState
    });
  };
  function useGridColumns(apiRef2, props) {
    var _props$initialState4, _props$slotProps2;
    const logger = useGridLogger(apiRef2, "useGridColumns");
    const columnTypes = defaultColumnTypes;
    const previousColumnsProp = React__namespace.useRef(props.columns);
    const previousColumnTypesProp = React__namespace.useRef(columnTypes);
    apiRef2.current.registerControlState({
      stateId: "visibleColumns",
      propModel: props.columnVisibilityModel,
      propOnChange: props.onColumnVisibilityModelChange,
      stateSelector: gridColumnVisibilityModelSelector,
      changeEvent: "columnVisibilityModelChange"
    });
    const setGridColumnsState = React__namespace.useCallback((columnsState) => {
      logger.debug("Updating columns state.");
      apiRef2.current.setState(mergeColumnsState(columnsState));
      apiRef2.current.forceUpdate();
      apiRef2.current.publishEvent("columnsChange", columnsState.orderedFields);
    }, [logger, apiRef2]);
    const getColumn = React__namespace.useCallback((field) => gridColumnLookupSelector(apiRef2)[field], [apiRef2]);
    const getAllColumns = React__namespace.useCallback(() => gridColumnDefinitionsSelector(apiRef2), [apiRef2]);
    const getVisibleColumns = React__namespace.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef2), [apiRef2]);
    const getColumnIndex = React__namespace.useCallback((field, useVisibleColumns = true) => {
      const columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef2) : gridColumnDefinitionsSelector(apiRef2);
      return columns.findIndex((col) => col.field === field);
    }, [apiRef2]);
    const getColumnPosition = React__namespace.useCallback((field) => {
      const index = getColumnIndex(field);
      return gridColumnPositionsSelector(apiRef2)[index];
    }, [apiRef2, getColumnIndex]);
    const setColumnVisibilityModel = React__namespace.useCallback((model) => {
      const currentModel = gridColumnVisibilityModelSelector(apiRef2);
      if (currentModel !== model) {
        apiRef2.current.setState((state) => _extends({}, state, {
          columns: createColumnsState({
            apiRef: apiRef2,
            columnTypes,
            columnsToUpsert: [],
            initialState: void 0,
            columnVisibilityModel: model,
            keepOnlyColumnsToUpsert: false
          })
        }));
        apiRef2.current.forceUpdate();
      }
    }, [apiRef2, columnTypes]);
    const updateColumns = React__namespace.useCallback((columns) => {
      const columnsState = createColumnsState({
        apiRef: apiRef2,
        columnTypes,
        columnsToUpsert: columns,
        initialState: void 0,
        keepOnlyColumnsToUpsert: false
      });
      setGridColumnsState(columnsState);
    }, [apiRef2, setGridColumnsState, columnTypes]);
    const setColumnVisibility = React__namespace.useCallback((field, isVisible) => {
      var _columnVisibilityMode;
      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef2);
      const isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;
      if (isVisible !== isCurrentlyVisible) {
        const newModel = _extends({}, columnVisibilityModel, {
          [field]: isVisible
        });
        apiRef2.current.setColumnVisibilityModel(newModel);
      }
    }, [apiRef2]);
    const getColumnIndexRelativeToVisibleColumns = React__namespace.useCallback((field) => {
      const allColumns = gridColumnFieldsSelector(apiRef2);
      return allColumns.findIndex((col) => col === field);
    }, [apiRef2]);
    const setColumnIndex = React__namespace.useCallback((field, targetIndexPosition) => {
      const allColumns = gridColumnFieldsSelector(apiRef2);
      const oldIndexPosition = getColumnIndexRelativeToVisibleColumns(field);
      if (oldIndexPosition === targetIndexPosition) {
        return;
      }
      logger.debug(`Moving column ${field} to index ${targetIndexPosition}`);
      const updatedColumns = [...allColumns];
      const fieldRemoved = updatedColumns.splice(oldIndexPosition, 1)[0];
      updatedColumns.splice(targetIndexPosition, 0, fieldRemoved);
      setGridColumnsState(_extends({}, gridColumnsStateSelector(apiRef2.current.state), {
        orderedFields: updatedColumns
      }));
      const params = {
        column: apiRef2.current.getColumn(field),
        targetIndex: apiRef2.current.getColumnIndexRelativeToVisibleColumns(field),
        oldIndex: oldIndexPosition
      };
      apiRef2.current.publishEvent("columnIndexChange", params);
    }, [apiRef2, logger, setGridColumnsState, getColumnIndexRelativeToVisibleColumns]);
    const setColumnWidth = React__namespace.useCallback((field, width2) => {
      logger.debug(`Updating column ${field} width to ${width2}`);
      const column2 = apiRef2.current.getColumn(field);
      const newColumn = _extends({}, column2, {
        width: width2
      });
      apiRef2.current.updateColumns([newColumn]);
      apiRef2.current.publishEvent("columnWidthChange", {
        element: apiRef2.current.getColumnHeaderElement(field),
        colDef: newColumn,
        width: width2
      });
    }, [apiRef2, logger]);
    const columnApi = {
      getColumn,
      getAllColumns,
      getColumnIndex,
      getColumnPosition,
      getVisibleColumns,
      getColumnIndexRelativeToVisibleColumns,
      updateColumns,
      setColumnVisibilityModel,
      setColumnVisibility,
      setColumnWidth
    };
    const columnReorderApi = {
      setColumnIndex
    };
    useGridApiMethod(apiRef2, columnApi, "public");
    useGridApiMethod(apiRef2, columnReorderApi, props.signature === GridSignature.DataGrid ? "private" : "public");
    const stateExportPreProcessing = React__namespace.useCallback((prevState, context) => {
      var _props$initialState$c, _props$initialState3;
      const columnsStateToExport = {};
      const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef2);
      const shouldExportColumnVisibilityModel = (
        // Always export if the `exportOnlyDirtyModels` property is not activated
        !context.exportOnlyDirtyModels || // Always export if the model is controlled
        props.columnVisibilityModel != null || // Always export if the model has been initialized
        // TODO v6 Do a nullish check instead to export even if the initial model equals "{}"
        Object.keys((_props$initialState$c = (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.columns) == null ? void 0 : _props$initialState3.columnVisibilityModel) != null ? _props$initialState$c : {}).length > 0 || // Always export if the model is not empty
        Object.keys(columnVisibilityModelToExport).length > 0
      );
      if (shouldExportColumnVisibilityModel) {
        columnsStateToExport.columnVisibilityModel = columnVisibilityModelToExport;
      }
      columnsStateToExport.orderedFields = gridColumnFieldsSelector(apiRef2);
      const columns = gridColumnDefinitionsSelector(apiRef2);
      const dimensions = {};
      columns.forEach((colDef) => {
        if (colDef.hasBeenResized) {
          const colDefDimensions = {};
          COLUMNS_DIMENSION_PROPERTIES.forEach((propertyName) => {
            let propertyValue = colDef[propertyName];
            if (propertyValue === Infinity) {
              propertyValue = -1;
            }
            colDefDimensions[propertyName] = propertyValue;
          });
          dimensions[colDef.field] = colDefDimensions;
        }
      });
      if (Object.keys(dimensions).length > 0) {
        columnsStateToExport.dimensions = dimensions;
      }
      return _extends({}, prevState, {
        columns: columnsStateToExport
      });
    }, [apiRef2, props.columnVisibilityModel, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.columns]);
    const stateRestorePreProcessing = React__namespace.useCallback((params, context) => {
      var _context$stateToResto;
      const columnVisibilityModelToImport = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;
      const initialState = context.stateToRestore.columns;
      if (columnVisibilityModelToImport == null && initialState == null) {
        return params;
      }
      const columnsState = createColumnsState({
        apiRef: apiRef2,
        columnTypes,
        columnsToUpsert: [],
        initialState,
        columnVisibilityModel: columnVisibilityModelToImport,
        keepOnlyColumnsToUpsert: false
      });
      apiRef2.current.setState(mergeColumnsState(columnsState));
      if (initialState != null) {
        apiRef2.current.publishEvent("columnsChange", columnsState.orderedFields);
      }
      return params;
    }, [apiRef2, columnTypes]);
    const preferencePanelPreProcessing = React__namespace.useCallback((initialValue, value) => {
      if (value === GridPreferencePanelsValue.columns) {
        var _props$slotProps;
        const ColumnsPanel = props.slots.columnsPanel;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnsPanel, _extends({}, (_props$slotProps = props.slotProps) == null ? void 0 : _props$slotProps.columnsPanel));
      }
      return initialValue;
    }, [props.slots.columnsPanel, (_props$slotProps2 = props.slotProps) == null ? void 0 : _props$slotProps2.columnsPanel]);
    const addColumnMenuItems = React__namespace.useCallback((columnMenuItems) => {
      if (props.disableColumnSelector) {
        return columnMenuItems;
      }
      return [...columnMenuItems, "columnMenuColumnsItem"];
    }, [props.disableColumnSelector]);
    useGridRegisterPipeProcessor(apiRef2, "columnMenu", addColumnMenuItems);
    useGridRegisterPipeProcessor(apiRef2, "exportState", stateExportPreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "restoreState", stateRestorePreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "preferencePanel", preferencePanelPreProcessing);
    const prevInnerWidth = React__namespace.useRef(null);
    const handleGridSizeChange = (viewportInnerSize) => {
      if (prevInnerWidth.current !== viewportInnerSize.width) {
        prevInnerWidth.current = viewportInnerSize.width;
        setGridColumnsState(hydrateColumnsWidth(gridColumnsStateSelector(apiRef2.current.state), viewportInnerSize.width));
      }
    };
    useGridApiEventHandler(apiRef2, "viewportInnerSizeChange", handleGridSizeChange);
    const hydrateColumns = React__namespace.useCallback(() => {
      logger.info(`Columns pipe processing have changed, regenerating the columns`);
      const columnsState = createColumnsState({
        apiRef: apiRef2,
        columnTypes,
        columnsToUpsert: [],
        initialState: void 0,
        keepOnlyColumnsToUpsert: false
      });
      setGridColumnsState(columnsState);
    }, [apiRef2, logger, setGridColumnsState, columnTypes]);
    useGridRegisterPipeApplier(apiRef2, "hydrateColumns", hydrateColumns);
    const isFirstRender = React__namespace.useRef(true);
    React__namespace.useEffect(() => {
      if (isFirstRender.current) {
        isFirstRender.current = false;
        return;
      }
      logger.info(`GridColumns have changed, new length ${props.columns.length}`);
      if (previousColumnsProp.current === props.columns && previousColumnTypesProp.current === columnTypes) {
        return;
      }
      const columnsState = createColumnsState({
        apiRef: apiRef2,
        columnTypes,
        initialState: void 0,
        // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`
        columnsToUpsert: props.columns,
        keepOnlyColumnsToUpsert: true
      });
      previousColumnsProp.current = props.columns;
      previousColumnTypesProp.current = columnTypes;
      setGridColumnsState(columnsState);
    }, [logger, apiRef2, setGridColumnsState, props.columns, columnTypes]);
    React__namespace.useEffect(() => {
      if (props.columnVisibilityModel !== void 0) {
        apiRef2.current.setColumnVisibilityModel(props.columnVisibilityModel);
      }
    }, [apiRef2, logger, props.columnVisibilityModel]);
  }
  const COMPACT_DENSITY_FACTOR = 0.7;
  const COMFORTABLE_DENSITY_FACTOR = 1.3;
  const DENSITY_FACTORS = {
    compact: COMPACT_DENSITY_FACTOR,
    comfortable: COMFORTABLE_DENSITY_FACTOR,
    standard: 1
  };
  const densityStateInitializer = (state, props) => _extends({}, state, {
    density: {
      value: props.density,
      factor: DENSITY_FACTORS[props.density]
    }
  });
  const useGridDensity = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useDensity");
    const setDensity = React__namespace.useCallback((newDensity) => {
      logger.debug(`Set grid density to ${newDensity}`);
      apiRef2.current.setState((state) => {
        const currentDensityState = gridDensitySelector(state);
        const newDensityState = {
          value: newDensity,
          factor: DENSITY_FACTORS[newDensity]
        };
        if (isDeepEqual(currentDensityState, newDensityState)) {
          return state;
        }
        return _extends({}, state, {
          density: newDensityState
        });
      });
      apiRef2.current.forceUpdate();
    }, [logger, apiRef2]);
    React__namespace.useEffect(() => {
      apiRef2.current.setDensity(props.density);
    }, [apiRef2, props.density]);
    const densityApi = {
      setDensity
    };
    useGridApiMethod(apiRef2, densityApi, "public");
  };
  function exportAs(blob, extension = "csv", filename = document.title || "untitled") {
    const fullName = `${filename}.${extension}`;
    if ("download" in HTMLAnchorElement.prototype) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fullName;
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(url);
      });
      return;
    }
    throw new Error("MUI: exportAs not supported");
  }
  const getColumnsToExport = ({
    apiRef: apiRef2,
    options
  }) => {
    const columns = gridColumnDefinitionsSelector(apiRef2);
    if (options.fields) {
      return options.fields.reduce((currentColumns, field) => {
        const column2 = columns.find((col) => col.field === field);
        if (column2) {
          currentColumns.push(column2);
        }
        return currentColumns;
      }, []);
    }
    const validColumns = options.allColumns ? columns : gridVisibleColumnDefinitionsSelector(apiRef2);
    return validColumns.filter((column2) => !column2.disableExport);
  };
  const defaultGetRowsToExport = ({
    apiRef: apiRef2
  }) => {
    var _pinnedRows$top, _pinnedRows$bottom;
    const filteredSortedRowIds = gridFilteredSortedRowIdsSelector(apiRef2);
    const rowTree = gridRowTreeSelector(apiRef2);
    const selectedRows = apiRef2.current.getSelectedRows();
    const bodyRows = filteredSortedRowIds.filter((id) => rowTree[id].type !== "footer");
    const pinnedRows = gridPinnedRowsSelector(apiRef2);
    const topPinnedRowsIds = (pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.map((row) => row.id)) || [];
    const bottomPinnedRowsIds = (pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.map((row) => row.id)) || [];
    bodyRows.unshift(...topPinnedRowsIds);
    bodyRows.push(...bottomPinnedRowsIds);
    if (selectedRows.size > 0) {
      return bodyRows.filter((id) => selectedRows.has(id));
    }
    return bodyRows;
  };
  const useGridCsvExport = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useGridCsvExport");
    const ignoreValueFormatterProp = props.unstable_ignoreValueFormatterDuringExport;
    const ignoreValueFormatter = (typeof ignoreValueFormatterProp === "object" ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.csvExport : ignoreValueFormatterProp) || false;
    const getDataAsCsv = React__namespace.useCallback((options = {}) => {
      var _options$getRowsToExp, _options$includeHeade, _options$includeColum;
      logger.debug(`Get data as CSV`);
      const exportedColumns = getColumnsToExport({
        apiRef: apiRef2,
        options
      });
      const getRowsToExport = (_options$getRowsToExp = options.getRowsToExport) != null ? _options$getRowsToExp : defaultGetRowsToExport;
      const exportedRowIds = getRowsToExport({
        apiRef: apiRef2
      });
      return buildCSV({
        columns: exportedColumns,
        rowIds: exportedRowIds,
        delimiterCharacter: options.delimiter || ",",
        includeHeaders: (_options$includeHeade = options.includeHeaders) != null ? _options$includeHeade : true,
        includeColumnGroupsHeaders: (_options$includeColum = options.includeColumnGroupsHeaders) != null ? _options$includeColum : true,
        ignoreValueFormatter,
        apiRef: apiRef2
      });
    }, [logger, apiRef2, ignoreValueFormatter]);
    const exportDataAsCsv = React__namespace.useCallback((options) => {
      logger.debug(`Export data as CSV`);
      const csv = getDataAsCsv(options);
      const blob = new Blob([options != null && options.utf8WithBom ? new Uint8Array([239, 187, 191]) : "", csv], {
        type: "text/csv"
      });
      exportAs(blob, "csv", options == null ? void 0 : options.fileName);
    }, [logger, getDataAsCsv]);
    const csvExportApi = {
      getDataAsCsv,
      exportDataAsCsv
    };
    useGridApiMethod(apiRef2, csvExportApi, "public");
    const addExportMenuButtons = React__namespace.useCallback((initialValue, options) => {
      var _options$csvOptions;
      if ((_options$csvOptions = options.csvOptions) != null && _options$csvOptions.disableToolbarButton) {
        return initialValue;
      }
      return [...initialValue, {
        component: /* @__PURE__ */ jsxRuntimeExports.jsx(GridCsvExportMenuItem, {
          options: options.csvOptions
        }),
        componentName: "csvExport"
      }];
    }, []);
    useGridRegisterPipeProcessor(apiRef2, "exportMenu", addExportMenuButtons);
  };
  function raf() {
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        resolve();
      });
    });
  }
  function buildPrintWindow(title) {
    const iframeEl = document.createElement("iframe");
    iframeEl.style.position = "absolute";
    iframeEl.style.width = "0px";
    iframeEl.style.height = "0px";
    iframeEl.title = title || document.title;
    return iframeEl;
  }
  const useGridPrintExport = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useGridPrintExport");
    const doc = React__namespace.useRef(null);
    const previousGridState = React__namespace.useRef(null);
    const previousColumnVisibility = React__namespace.useRef({});
    React__namespace.useEffect(() => {
      doc.current = ownerDocument(apiRef2.current.rootElementRef.current);
    }, [apiRef2]);
    const updateGridColumnsForPrint = React__namespace.useCallback((fields, allColumns) => new Promise((resolve) => {
      const exportedColumnFields = getColumnsToExport({
        apiRef: apiRef2,
        options: {
          fields,
          allColumns
        }
      }).map((column2) => column2.field);
      const columns = gridColumnDefinitionsSelector(apiRef2);
      const newColumnVisibilityModel = {};
      columns.forEach((column2) => {
        newColumnVisibilityModel[column2.field] = exportedColumnFields.includes(column2.field);
      });
      apiRef2.current.setColumnVisibilityModel(newColumnVisibilityModel);
      resolve();
    }), [apiRef2]);
    const handlePrintWindowLoad = React__namespace.useCallback((printWindow, options) => {
      var _querySelector, _querySelector2;
      const normalizeOptions = _extends({
        copyStyles: true,
        hideToolbar: false,
        hideFooter: false
      }, options);
      const printDoc = printWindow.contentDocument;
      if (!printDoc) {
        return;
      }
      const rowsMeta = gridRowsMetaSelector(apiRef2.current.state);
      const gridRootElement = apiRef2.current.rootElementRef.current;
      const gridClone = gridRootElement.cloneNode(true);
      const gridMain = gridClone.querySelector(`.${gridClasses.main}`);
      gridMain.style.overflow = "visible";
      gridClone.style.contain = "size";
      const columnHeaders = gridClone.querySelector(`.${gridClasses.columnHeaders}`);
      const columnHeadersInner = columnHeaders.querySelector(`.${gridClasses.columnHeadersInner}`);
      columnHeadersInner.style.width = "100%";
      let gridToolbarElementHeight = ((_querySelector = gridRootElement.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _querySelector.offsetHeight) || 0;
      let gridFooterElementHeight = ((_querySelector2 = gridRootElement.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _querySelector2.offsetHeight) || 0;
      if (normalizeOptions.hideToolbar) {
        var _gridClone$querySelec;
        (_gridClone$querySelec = gridClone.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _gridClone$querySelec.remove();
        gridToolbarElementHeight = 0;
      }
      if (normalizeOptions.hideFooter) {
        var _gridClone$querySelec2;
        (_gridClone$querySelec2 = gridClone.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _gridClone$querySelec2.remove();
        gridFooterElementHeight = 0;
      }
      gridClone.style.height = `${rowsMeta.currentPageTotalHeight + getTotalHeaderHeight(apiRef2, props.columnHeaderHeight) + gridToolbarElementHeight + gridFooterElementHeight}px`;
      gridClone.style.boxSizing = "content-box";
      const container = document.createElement("div");
      container.appendChild(gridClone);
      printDoc.body.innerHTML = container.innerHTML;
      const defaultPageStyle = typeof normalizeOptions.pageStyle === "function" ? normalizeOptions.pageStyle() : normalizeOptions.pageStyle;
      if (typeof defaultPageStyle === "string") {
        const styleElement = printDoc.createElement("style");
        styleElement.appendChild(printDoc.createTextNode(defaultPageStyle));
        printDoc.head.appendChild(styleElement);
      }
      if (normalizeOptions.bodyClassName) {
        printDoc.body.classList.add(...normalizeOptions.bodyClassName.split(" "));
      }
      const stylesheetLoadPromises = [];
      if (normalizeOptions.copyStyles) {
        const rootCandidate = gridRootElement.getRootNode();
        const root = rootCandidate.constructor.name === "ShadowRoot" ? rootCandidate : doc.current;
        const headStyleElements = root.querySelectorAll("style, link[rel='stylesheet']");
        for (let i = 0; i < headStyleElements.length; i += 1) {
          const node2 = headStyleElements[i];
          if (node2.tagName === "STYLE") {
            const newHeadStyleElements = printDoc.createElement(node2.tagName);
            const sheet = node2.sheet;
            if (sheet) {
              let styleCSS = "";
              for (let j = 0; j < sheet.cssRules.length; j += 1) {
                if (typeof sheet.cssRules[j].cssText === "string") {
                  styleCSS += `${sheet.cssRules[j].cssText}\r
`;
                }
              }
              newHeadStyleElements.appendChild(printDoc.createTextNode(styleCSS));
              printDoc.head.appendChild(newHeadStyleElements);
            }
          } else if (node2.getAttribute("href")) {
            const newHeadStyleElements = printDoc.createElement(node2.tagName);
            for (let j = 0; j < node2.attributes.length; j += 1) {
              const attr = node2.attributes[j];
              if (attr) {
                newHeadStyleElements.setAttribute(attr.nodeName, attr.nodeValue || "");
              }
            }
            stylesheetLoadPromises.push(new Promise((resolve) => {
              newHeadStyleElements.addEventListener("load", () => resolve());
            }));
            printDoc.head.appendChild(newHeadStyleElements);
          }
        }
      }
      {
        Promise.all(stylesheetLoadPromises).then(() => {
          printWindow.contentWindow.print();
        });
      }
    }, [apiRef2, doc, props.columnHeaderHeight]);
    const handlePrintWindowAfterPrint = React__namespace.useCallback((printWindow) => {
      var _previousGridState$cu;
      doc.current.body.removeChild(printWindow);
      apiRef2.current.restoreState(previousGridState.current || {});
      if (!((_previousGridState$cu = previousGridState.current) != null && (_previousGridState$cu = _previousGridState$cu.columns) != null && _previousGridState$cu.columnVisibilityModel)) {
        apiRef2.current.setColumnVisibilityModel(previousColumnVisibility.current);
      }
      apiRef2.current.unstable_enableVirtualization();
      previousGridState.current = null;
      previousColumnVisibility.current = {};
    }, [apiRef2]);
    const exportDataAsPrint = React__namespace.useCallback(async (options) => {
      logger.debug(`Export data as Print`);
      if (!apiRef2.current.rootElementRef.current) {
        throw new Error("MUI: No grid root element available.");
      }
      previousGridState.current = apiRef2.current.exportState();
      previousColumnVisibility.current = gridColumnVisibilityModelSelector(apiRef2);
      if (props.pagination) {
        const visibleRowCount = gridExpandedRowCountSelector(apiRef2);
        apiRef2.current.setPageSize(visibleRowCount);
      }
      await updateGridColumnsForPrint(options == null ? void 0 : options.fields, options == null ? void 0 : options.allColumns);
      apiRef2.current.unstable_disableVirtualization();
      await raf();
      const printWindow = buildPrintWindow(options == null ? void 0 : options.fileName);
      {
        printWindow.onload = () => {
          handlePrintWindowLoad(printWindow, options);
          const mediaQueryList = printWindow.contentWindow.matchMedia("print");
          mediaQueryList.addEventListener("change", (mql) => {
            const isAfterPrint = mql.matches === false;
            if (isAfterPrint) {
              handlePrintWindowAfterPrint(printWindow);
            }
          });
        };
        doc.current.body.appendChild(printWindow);
      }
    }, [props, logger, apiRef2, handlePrintWindowLoad, handlePrintWindowAfterPrint, updateGridColumnsForPrint]);
    const printExportApi = {
      exportDataAsPrint
    };
    useGridApiMethod(apiRef2, printExportApi, "public");
    const addExportMenuButtons = React__namespace.useCallback((initialValue, options) => {
      var _options$printOptions;
      if ((_options$printOptions = options.printOptions) != null && _options$printOptions.disableToolbarButton) {
        return initialValue;
      }
      return [...initialValue, {
        component: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPrintExportMenuItem, {
          options: options.printOptions
        }),
        componentName: "printExport"
      }];
    }, []);
    useGridRegisterPipeProcessor(apiRef2, "exportMenu", addExportMenuButtons);
  };
  let hasEval;
  try {
    hasEval = eval("true");
  } catch (_2) {
    hasEval = false;
  }
  const cleanFilterItem = (item, apiRef2) => {
    const cleanItem = _extends({}, item);
    if (cleanItem.id == null) {
      cleanItem.id = Math.round(Math.random() * 1e5);
    }
    if (cleanItem.operator == null) {
      const column2 = gridColumnLookupSelector(apiRef2)[cleanItem.field];
      cleanItem.operator = column2 && column2.filterOperators[0].value;
    }
    return cleanItem;
  };
  const filterModelDisableMultiColumnsFilteringWarning = buildWarning(["MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.", "If you are using the community version of the `DataGrid`, this prop is always `true`."], "error");
  const filterModelMissingItemIdWarning = buildWarning("MUI: The `id` field is required on `filterModel.items` when you use multiple filters.", "error");
  const filterModelMissingItemOperatorWarning = buildWarning("MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.", "error");
  const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef2) => {
    const hasSeveralItems = model.items.length > 1;
    let items2;
    if (hasSeveralItems && disableMultipleColumnsFiltering) {
      filterModelDisableMultiColumnsFilteringWarning();
      items2 = [model.items[0]];
    } else {
      items2 = model.items;
    }
    const hasItemsWithoutIds = hasSeveralItems && items2.some((item) => item.id == null);
    const hasItemWithoutOperator = items2.some((item) => item.operator == null);
    if (hasItemsWithoutIds) {
      filterModelMissingItemIdWarning();
    }
    if (hasItemWithoutOperator) {
      filterModelMissingItemOperatorWarning();
    }
    if (hasItemWithoutOperator || hasItemsWithoutIds) {
      return _extends({}, model, {
        items: items2.map((item) => cleanFilterItem(item, apiRef2))
      });
    }
    if (model.items !== items2) {
      return _extends({}, model, {
        items: items2
      });
    }
    return model;
  };
  const mergeStateWithFilterModel = (filterModel2, disableMultipleColumnsFiltering, apiRef2) => (filteringState) => _extends({}, filteringState, {
    filterModel: sanitizeFilterModel(filterModel2, disableMultipleColumnsFiltering, apiRef2)
  });
  const getFilterCallbackFromItem = (filterItem2, apiRef2) => {
    if (!filterItem2.field || !filterItem2.operator) {
      return null;
    }
    const column2 = apiRef2.current.getColumn(filterItem2.field);
    if (!column2) {
      return null;
    }
    let parsedValue;
    if (column2.valueParser) {
      var _filterItem$value;
      const parser = column2.valueParser;
      parsedValue = Array.isArray(filterItem2.value) ? (_filterItem$value = filterItem2.value) == null ? void 0 : _filterItem$value.map((x2) => parser(x2)) : parser(filterItem2.value);
    } else {
      parsedValue = filterItem2.value;
    }
    const newFilterItem = _extends({}, filterItem2, {
      value: parsedValue
    });
    const filterOperators = column2.filterOperators;
    if (!(filterOperators != null && filterOperators.length)) {
      throw new Error(`MUI: No filter operators found for column '${column2.field}'.`);
    }
    const filterOperator = filterOperators.find((operator) => operator.value === newFilterItem.operator);
    if (!filterOperator) {
      throw new Error(`MUI: No filter operator found for column '${column2.field}' and operator value '${newFilterItem.operator}'.`);
    }
    const hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);
    const hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);
    if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {
      const applyFilterOnRow2 = filterOperator.getApplyFilterFnV7(newFilterItem, column2);
      if (typeof applyFilterOnRow2 !== "function") {
        return null;
      }
      return {
        v7: true,
        item: newFilterItem,
        fn: (row) => {
          const value = apiRef2.current.getRowValue(row, column2);
          return applyFilterOnRow2(value, row, column2, apiRef2);
        }
      };
    }
    const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column2);
    if (typeof applyFilterOnRow !== "function") {
      return null;
    }
    return {
      v7: false,
      item: newFilterItem,
      fn: (rowId) => {
        const params = apiRef2.current.getCellParams(rowId, newFilterItem.field);
        GLOBAL_API_REF.current = apiRef2;
        const result = applyFilterOnRow(params);
        GLOBAL_API_REF.current = null;
        return result;
      }
    };
  };
  let filterItemsApplierId = 1;
  const buildAggregatedFilterItemsApplier = (getRowId, filterModel, apiRef, disableEval) => {
    const {
      items
    } = filterModel;
    const appliers = items.map((item) => getFilterCallbackFromItem(item, apiRef)).filter((callback) => !!callback);
    if (appliers.length === 0) {
      return null;
    }
    if (!hasEval || disableEval) {
      return (row, shouldApplyFilter) => {
        const resultPerItemId = {};
        for (let i = 0; i < appliers.length; i += 1) {
          const applier = appliers[i];
          if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {
            resultPerItemId[applier.item.id] = applier.v7 ? applier.fn(row) : applier.fn(getRowId ? getRowId(row) : row.id);
          }
        }
        return resultPerItemId;
      };
    }
    const filterItemTemplate = `(function filterItem$$(row, shouldApplyFilter) {
      ${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join("\n")}

      const result$$ = {
      ${appliers.map((applier, i) => `${JSON.stringify(String(applier.item.id))}:
          !shouldApply${i} ?
            false :
            ${applier.v7 ? `appliers[${i}].fn(row)` : `appliers[${i}].fn(${getRowId ? "getRowId(row)" : "row.id"})`},
      `).join("\n")}};

      return result$$;
    })`;
    const filterItem = eval(filterItemTemplate.replaceAll("$$", String(filterItemsApplierId)));
    filterItemsApplierId += 1;
    return filterItem;
  };
  const buildAggregatedQuickFilterApplier = (getRowId2, filterModel2, apiRef2) => {
    var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;
    const quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel2.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];
    if (quickFilterValues.length === 0) {
      return null;
    }
    const quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel2.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;
    const columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef2) : gridColumnFieldsSelector(apiRef2);
    const appliersPerField = [];
    columnFields.forEach((field) => {
      const column2 = apiRef2.current.getColumn(field);
      const getApplyQuickFilterFn = column2 == null ? void 0 : column2.getApplyQuickFilterFn;
      const getApplyQuickFilterFnV7 = column2 == null ? void 0 : column2.getApplyQuickFilterFnV7;
      const hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);
      const hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);
      if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {
        appliersPerField.push({
          column: column2,
          appliers: quickFilterValues.map((value) => ({
            v7: true,
            fn: getApplyQuickFilterFnV7(value, column2, apiRef2)
          }))
        });
      } else if (getApplyQuickFilterFn) {
        appliersPerField.push({
          column: column2,
          appliers: quickFilterValues.map((value) => ({
            v7: false,
            fn: getApplyQuickFilterFn(value, column2, apiRef2)
          }))
        });
      }
    });
    return function isRowMatchingQuickFilter(row, shouldApplyFilter) {
      const result = {};
      const usedCellParams = {};
      outer:
        for (let v2 = 0; v2 < quickFilterValues.length; v2 += 1) {
          const filterValue = quickFilterValues[v2];
          for (let i = 0; i < appliersPerField.length; i += 1) {
            const {
              column: column2,
              appliers: appliers2
            } = appliersPerField[i];
            const {
              field
            } = column2;
            if (shouldApplyFilter && !shouldApplyFilter(field)) {
              continue;
            }
            const applier = appliers2[v2];
            const value = apiRef2.current.getRowValue(row, column2);
            if (applier.fn === null) {
              continue;
            }
            if (applier.v7) {
              const isMatching = applier.fn(value, row, column2, apiRef2);
              if (isMatching) {
                result[filterValue] = true;
                continue outer;
              }
            } else {
              var _usedCellParams$field;
              const cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef2.current.getCellParams(getRowId2 ? getRowId2(row) : row.id, field);
              usedCellParams[field] = cellParams;
              const isMatching = applier.fn(cellParams);
              if (isMatching) {
                result[filterValue] = true;
                continue outer;
              }
            }
          }
          result[filterValue] = false;
        }
      return result;
    };
  };
  const buildAggregatedFilterApplier = (getRowId2, filterModel2, apiRef2, disableEval2) => {
    const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(getRowId2, filterModel2, apiRef2, disableEval2);
    const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(getRowId2, filterModel2, apiRef2);
    return function isRowMatchingFilters(row, shouldApplyFilter, result) {
      var _isRowMatchingFilterI, _isRowMatchingQuickFi;
      result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;
      result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;
    };
  };
  const isNotNull = (result) => result != null;
  const filterModelItems = (cache, apiRef2, items2) => {
    if (!cache.cleanedFilterItems) {
      cache.cleanedFilterItems = items2.filter((item) => getFilterCallbackFromItem(item, apiRef2) !== null);
    }
    return cache.cleanedFilterItems;
  };
  const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel2, apiRef2, cache) => {
    const cleanedFilterItems = filterModelItems(cache, apiRef2, filterModel2.items);
    const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);
    const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);
    if (cleanedFilterItemResults.length > 0) {
      var _filterModel$logicOpe;
      const filterItemPredicate = (item) => {
        return cleanedFilterItemResults.some((filterItemResult) => filterItemResult[item.id]);
      };
      const logicOperator = (_filterModel$logicOpe = filterModel2.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;
      if (logicOperator === GridLogicOperator.And) {
        const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);
        if (!passesAllFilters) {
          return false;
        }
      } else {
        const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);
        if (!passesSomeFilters) {
          return false;
        }
      }
    }
    if (cleanedQuickFilterResults.length > 0 && filterModel2.quickFilterValues != null) {
      var _filterModel$quickFil4;
      const quickFilterValuePredicate = (value) => {
        return cleanedQuickFilterResults.some((quickFilterValueResult) => quickFilterValueResult[value]);
      };
      const quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel2.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;
      if (quickFilterLogicOperator === GridLogicOperator.And) {
        const passesAllQuickFilterValues = filterModel2.quickFilterValues.every(quickFilterValuePredicate);
        if (!passesAllQuickFilterValues) {
          return false;
        }
      } else {
        const passesSomeQuickFilterValues = filterModel2.quickFilterValues.some(quickFilterValuePredicate);
        if (!passesSomeQuickFilterValues) {
          return false;
        }
      }
    }
    return true;
  };
  const filterStateInitializer = (state, props, apiRef2) => {
    var _ref, _props$filterModel, _props$initialState;
    const filterModel2 = (_ref = (_props$filterModel = props.filterModel) != null ? _props$filterModel : (_props$initialState = props.initialState) == null || (_props$initialState = _props$initialState.filter) == null ? void 0 : _props$initialState.filterModel) != null ? _ref : getDefaultGridFilterModel();
    return _extends({}, state, {
      filter: {
        filterModel: sanitizeFilterModel(filterModel2, props.disableMultipleColumnsFiltering, apiRef2),
        filteredRowsLookup: {},
        filteredDescendantCountLookup: {}
      },
      visibleRowsLookup: {}
    });
  };
  const getVisibleRowsLookup = (params) => {
    return params.filteredRowsLookup;
  };
  function getVisibleRowsLookupState(apiRef2, state) {
    return apiRef2.current.applyStrategyProcessor("visibleRowsLookupCreation", {
      tree: state.rows.tree,
      filteredRowsLookup: state.filter.filteredRowsLookup
    });
  }
  function createMemoizedValues() {
    return defaultMemoize(Object.values);
  }
  const useGridFilter = (apiRef2, props) => {
    var _props$initialState3, _props$slotProps2;
    const logger = useGridLogger(apiRef2, "useGridFilter");
    apiRef2.current.registerControlState({
      stateId: "filter",
      propModel: props.filterModel,
      propOnChange: props.onFilterModelChange,
      stateSelector: gridFilterModelSelector,
      changeEvent: "filterModelChange"
    });
    const updateFilteredRows = React__namespace.useCallback(() => {
      apiRef2.current.setState((state) => {
        const filterModel2 = gridFilterModelSelector(state, apiRef2.current.instanceId);
        const isRowMatchingFilters = props.filterMode === "client" ? buildAggregatedFilterApplier(props.getRowId, filterModel2, apiRef2, props.disableEval) : null;
        const filteringResult = apiRef2.current.applyStrategyProcessor("filtering", {
          isRowMatchingFilters,
          filterModel: filterModel2 != null ? filterModel2 : getDefaultGridFilterModel()
        });
        const newState = _extends({}, state, {
          filter: _extends({}, state.filter, filteringResult)
        });
        const visibleRowsLookupState = getVisibleRowsLookupState(apiRef2, newState);
        return _extends({}, newState, {
          visibleRowsLookup: visibleRowsLookupState
        });
      });
      apiRef2.current.publishEvent("filteredRowsSet");
    }, [apiRef2, props.filterMode, props.getRowId, props.disableEval]);
    const addColumnMenuItem = React__namespace.useCallback((columnMenuItems, colDef) => {
      if (colDef == null || colDef.filterable === false || props.disableColumnFilter) {
        return columnMenuItems;
      }
      return [...columnMenuItems, "columnMenuFilterItem"];
    }, [props.disableColumnFilter]);
    const applyFilters = React__namespace.useCallback(() => {
      updateFilteredRows();
      apiRef2.current.forceUpdate();
    }, [apiRef2, updateFilteredRows]);
    const upsertFilterItem = React__namespace.useCallback((item) => {
      const filterModel2 = gridFilterModelSelector(apiRef2);
      const items2 = [...filterModel2.items];
      const itemIndex = items2.findIndex((filterItem2) => filterItem2.id === item.id);
      if (itemIndex === -1) {
        items2.push(item);
      } else {
        items2[itemIndex] = item;
      }
      apiRef2.current.setFilterModel(_extends({}, filterModel2, {
        items: items2
      }), "upsertFilterItem");
    }, [apiRef2]);
    const upsertFilterItems = React__namespace.useCallback((items2) => {
      const filterModel2 = gridFilterModelSelector(apiRef2);
      const existingItems = [...filterModel2.items];
      items2.forEach((item) => {
        const itemIndex = items2.findIndex((filterItem2) => filterItem2.id === item.id);
        if (itemIndex === -1) {
          existingItems.push(item);
        } else {
          existingItems[itemIndex] = item;
        }
      });
      apiRef2.current.setFilterModel(_extends({}, filterModel2, {
        items: items2
      }), "upsertFilterItems");
    }, [apiRef2]);
    const deleteFilterItem = React__namespace.useCallback((itemToDelete) => {
      const filterModel2 = gridFilterModelSelector(apiRef2);
      const items2 = filterModel2.items.filter((item) => item.id !== itemToDelete.id);
      if (items2.length === filterModel2.items.length) {
        return;
      }
      apiRef2.current.setFilterModel(_extends({}, filterModel2, {
        items: items2
      }), "deleteFilterItem");
    }, [apiRef2]);
    const showFilterPanel = React__namespace.useCallback((targetColumnField, panelId, labelId) => {
      logger.debug("Displaying filter panel");
      if (targetColumnField) {
        const filterModel2 = gridFilterModelSelector(apiRef2);
        const filterItemsWithValue = filterModel2.items.filter((item) => {
          var _column$filterOperato;
          if (item.value !== void 0) {
            if (Array.isArray(item.value) && item.value.length === 0) {
              return false;
            }
            return true;
          }
          const column2 = apiRef2.current.getColumn(item.field);
          const filterOperator = (_column$filterOperato = column2.filterOperators) == null ? void 0 : _column$filterOperato.find((operator) => operator.value === item.operator);
          const requiresFilterValue = typeof (filterOperator == null ? void 0 : filterOperator.requiresFilterValue) === "undefined" ? true : filterOperator == null ? void 0 : filterOperator.requiresFilterValue;
          if (requiresFilterValue) {
            return false;
          }
          return true;
        });
        let newFilterItems;
        const filterItemOnTarget = filterItemsWithValue.find((item) => item.field === targetColumnField);
        const targetColumn = apiRef2.current.getColumn(targetColumnField);
        if (filterItemOnTarget) {
          newFilterItems = filterItemsWithValue;
        } else if (props.disableMultipleColumnsFiltering) {
          newFilterItems = [cleanFilterItem({
            field: targetColumnField,
            operator: targetColumn.filterOperators[0].value
          }, apiRef2)];
        } else {
          newFilterItems = [...filterItemsWithValue, cleanFilterItem({
            field: targetColumnField,
            operator: targetColumn.filterOperators[0].value
          }, apiRef2)];
        }
        apiRef2.current.setFilterModel(_extends({}, filterModel2, {
          items: newFilterItems
        }));
      }
      apiRef2.current.showPreferences(GridPreferencePanelsValue.filters, panelId, labelId);
    }, [apiRef2, logger, props.disableMultipleColumnsFiltering]);
    const hideFilterPanel = React__namespace.useCallback(() => {
      logger.debug("Hiding filter panel");
      apiRef2.current.hidePreferences();
    }, [apiRef2, logger]);
    const setFilterLogicOperator = React__namespace.useCallback((logicOperator) => {
      const filterModel2 = gridFilterModelSelector(apiRef2);
      if (filterModel2.logicOperator === logicOperator) {
        return;
      }
      apiRef2.current.setFilterModel(_extends({}, filterModel2, {
        logicOperator
      }), "changeLogicOperator");
    }, [apiRef2]);
    const setQuickFilterValues = React__namespace.useCallback((values2) => {
      const filterModel2 = gridFilterModelSelector(apiRef2);
      if (isDeepEqual(filterModel2.quickFilterValues, values2)) {
        return;
      }
      apiRef2.current.setFilterModel(_extends({}, filterModel2, {
        quickFilterValues: [...values2]
      }));
    }, [apiRef2]);
    const setFilterModel = React__namespace.useCallback((model, reason) => {
      const currentModel = gridFilterModelSelector(apiRef2);
      if (currentModel !== model) {
        logger.debug("Setting filter model");
        apiRef2.current.updateControlState("filter", mergeStateWithFilterModel(model, props.disableMultipleColumnsFiltering, apiRef2), reason);
        apiRef2.current.unstable_applyFilters();
      }
    }, [apiRef2, logger, props.disableMultipleColumnsFiltering]);
    const filterApi = {
      setFilterLogicOperator,
      unstable_applyFilters: applyFilters,
      deleteFilterItem,
      upsertFilterItem,
      upsertFilterItems,
      setFilterModel,
      showFilterPanel,
      hideFilterPanel,
      setQuickFilterValues
    };
    useGridApiMethod(apiRef2, filterApi, "public");
    const stateExportPreProcessing = React__namespace.useCallback((prevState, context) => {
      var _props$initialState2;
      const filterModelToExport = gridFilterModelSelector(apiRef2);
      const shouldExportFilterModel = (
        // Always export if the `exportOnlyDirtyModels` property is not activated
        !context.exportOnlyDirtyModels || // Always export if the model is controlled
        props.filterModel != null || // Always export if the model has been initialized
        ((_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.filter) == null ? void 0 : _props$initialState2.filterModel) != null || // Export if the model is not equal to the default value
        !isDeepEqual(filterModelToExport, getDefaultGridFilterModel())
      );
      if (!shouldExportFilterModel) {
        return prevState;
      }
      return _extends({}, prevState, {
        filter: {
          filterModel: filterModelToExport
        }
      });
    }, [apiRef2, props.filterModel, (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.filter) == null ? void 0 : _props$initialState3.filterModel]);
    const stateRestorePreProcessing = React__namespace.useCallback((params, context) => {
      var _context$stateToResto;
      const filterModel2 = (_context$stateToResto = context.stateToRestore.filter) == null ? void 0 : _context$stateToResto.filterModel;
      if (filterModel2 == null) {
        return params;
      }
      apiRef2.current.updateControlState("filter", mergeStateWithFilterModel(filterModel2, props.disableMultipleColumnsFiltering, apiRef2), "restoreState");
      return _extends({}, params, {
        callbacks: [...params.callbacks, apiRef2.current.unstable_applyFilters]
      });
    }, [apiRef2, props.disableMultipleColumnsFiltering]);
    const preferencePanelPreProcessing = React__namespace.useCallback((initialValue, value) => {
      if (value === GridPreferencePanelsValue.filters) {
        var _props$slotProps;
        const FilterPanel = props.slots.filterPanel;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FilterPanel, _extends({}, (_props$slotProps = props.slotProps) == null ? void 0 : _props$slotProps.filterPanel));
      }
      return initialValue;
    }, [props.slots.filterPanel, (_props$slotProps2 = props.slotProps) == null ? void 0 : _props$slotProps2.filterPanel]);
    const {
      getRowId: getRowId2
    } = props;
    const getRowsRef = useLazyRef(createMemoizedValues);
    const flatFilteringMethod = React__namespace.useCallback((params) => {
      if (props.filterMode !== "client" || !params.isRowMatchingFilters) {
        return {
          filteredRowsLookup: {},
          filteredDescendantCountLookup: {}
        };
      }
      const dataRowIdToModelLookup = gridRowsLookupSelector(apiRef2);
      const filteredRowsLookup = {};
      const {
        isRowMatchingFilters
      } = params;
      const filterCache = {};
      const result = {
        passingFilterItems: null,
        passingQuickFilterValues: null
      };
      const rows = getRowsRef.current(apiRef2.current.state.rows.dataRowIdToModelLookup);
      for (let i = 0; i < rows.length; i += 1) {
        const row = rows[i];
        const id = getRowId2 ? getRowId2(row) : row.id;
        isRowMatchingFilters(row, void 0, result);
        const isRowPassing = passFilterLogic([result.passingFilterItems], [result.passingQuickFilterValues], params.filterModel, apiRef2, filterCache);
        filteredRowsLookup[id] = isRowPassing;
      }
      const footerId = "auto-generated-group-footer-root";
      const footer = dataRowIdToModelLookup[footerId];
      if (footer) {
        filteredRowsLookup[footerId] = true;
      }
      return {
        filteredRowsLookup,
        filteredDescendantCountLookup: {}
      };
    }, [apiRef2, props.filterMode, getRowId2, getRowsRef]);
    useGridRegisterPipeProcessor(apiRef2, "columnMenu", addColumnMenuItem);
    useGridRegisterPipeProcessor(apiRef2, "exportState", stateExportPreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "restoreState", stateRestorePreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "preferencePanel", preferencePanelPreProcessing);
    useGridRegisterStrategyProcessor(apiRef2, GRID_DEFAULT_STRATEGY, "filtering", flatFilteringMethod);
    useGridRegisterStrategyProcessor(apiRef2, GRID_DEFAULT_STRATEGY, "visibleRowsLookupCreation", getVisibleRowsLookup);
    const handleColumnsChange = React__namespace.useCallback(() => {
      logger.debug("onColUpdated - GridColumns changed, applying filters");
      const filterModel2 = gridFilterModelSelector(apiRef2);
      const filterableColumnsLookup = gridFilterableColumnLookupSelector(apiRef2);
      const newFilterItems = filterModel2.items.filter((item) => item.field && filterableColumnsLookup[item.field]);
      if (newFilterItems.length < filterModel2.items.length) {
        apiRef2.current.setFilterModel(_extends({}, filterModel2, {
          items: newFilterItems
        }));
      }
    }, [apiRef2, logger]);
    const handleStrategyProcessorChange = React__namespace.useCallback((methodName) => {
      if (methodName === "filtering") {
        apiRef2.current.unstable_applyFilters();
      }
    }, [apiRef2]);
    const updateVisibleRowsLookupState = React__namespace.useCallback(() => {
      apiRef2.current.setState((state) => {
        return _extends({}, state, {
          visibleRowsLookup: getVisibleRowsLookupState(apiRef2, state)
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2]);
    useGridApiEventHandler(apiRef2, "rowsSet", updateFilteredRows);
    useGridApiEventHandler(apiRef2, "columnsChange", handleColumnsChange);
    useGridApiEventHandler(apiRef2, "activeStrategyProcessorChange", handleStrategyProcessorChange);
    useGridApiEventHandler(apiRef2, "rowExpansionChange", updateVisibleRowsLookupState);
    useGridApiEventHandler(apiRef2, "columnVisibilityModelChange", () => {
      const filterModel2 = gridFilterModelSelector(apiRef2);
      if (filterModel2.quickFilterValues && filterModel2.quickFilterExcludeHiddenColumns) {
        apiRef2.current.unstable_applyFilters();
      }
    });
    useFirstRender(() => {
      apiRef2.current.unstable_applyFilters();
    });
    useEnhancedEffect$1(() => {
      if (props.filterModel !== void 0) {
        apiRef2.current.setFilterModel(props.filterModel);
      }
    }, [apiRef2, logger, props.filterModel]);
  };
  const focusStateInitializer = (state) => _extends({}, state, {
    focus: {
      cell: null,
      columnHeader: null,
      columnHeaderFilter: null,
      columnGroupHeader: null
    },
    tabIndex: {
      cell: null,
      columnHeader: null,
      columnHeaderFilter: null,
      columnGroupHeader: null
    }
  });
  const useGridFocus = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useGridFocus");
    const lastClickedCell = React__namespace.useRef(null);
    const publishCellFocusOut = React__namespace.useCallback((cell, event) => {
      if (cell) {
        if (apiRef2.current.getRow(cell.id)) {
          apiRef2.current.publishEvent("cellFocusOut", apiRef2.current.getCellParams(cell.id, cell.field), event);
        }
      }
    }, [apiRef2]);
    const setCellFocus = React__namespace.useCallback((id, field) => {
      const focusedCell = gridFocusCellSelector(apiRef2);
      if ((focusedCell == null ? void 0 : focusedCell.id) === id && (focusedCell == null ? void 0 : focusedCell.field) === field) {
        return;
      }
      apiRef2.current.setState((state) => {
        logger.debug(`Focusing on cell with id=${id} and field=${field}`);
        return _extends({}, state, {
          tabIndex: {
            cell: {
              id,
              field
            },
            columnHeader: null,
            columnHeaderFilter: null,
            columnGroupHeader: null
          },
          focus: {
            cell: {
              id,
              field
            },
            columnHeader: null,
            columnHeaderFilter: null,
            columnGroupHeader: null
          }
        });
      });
      apiRef2.current.forceUpdate();
      if (!apiRef2.current.getRow(id)) {
        return;
      }
      if (focusedCell) {
        publishCellFocusOut(focusedCell, {});
      }
      apiRef2.current.publishEvent("cellFocusIn", apiRef2.current.getCellParams(id, field));
    }, [apiRef2, logger, publishCellFocusOut]);
    const setColumnHeaderFocus = React__namespace.useCallback((field, event = {}) => {
      const cell = gridFocusCellSelector(apiRef2);
      publishCellFocusOut(cell, event);
      apiRef2.current.setState((state) => {
        logger.debug(`Focusing on column header with colIndex=${field}`);
        return _extends({}, state, {
          tabIndex: {
            columnHeader: {
              field
            },
            columnHeaderFilter: null,
            cell: null,
            columnGroupHeader: null
          },
          focus: {
            columnHeader: {
              field
            },
            columnHeaderFilter: null,
            cell: null,
            columnGroupHeader: null
          }
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2, logger, publishCellFocusOut]);
    const setColumnHeaderFilterFocus = React__namespace.useCallback((field, event = {}) => {
      const cell = gridFocusCellSelector(apiRef2);
      publishCellFocusOut(cell, event);
      apiRef2.current.setState((state) => {
        logger.debug(`Focusing on column header filter with colIndex=${field}`);
        return _extends({}, state, {
          tabIndex: {
            columnHeader: null,
            columnHeaderFilter: {
              field
            },
            cell: null,
            columnGroupHeader: null
          },
          focus: {
            columnHeader: null,
            columnHeaderFilter: {
              field
            },
            cell: null,
            columnGroupHeader: null
          }
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2, logger, publishCellFocusOut]);
    const setColumnGroupHeaderFocus = React__namespace.useCallback((field, depth, event = {}) => {
      const cell = gridFocusCellSelector(apiRef2);
      if (cell) {
        apiRef2.current.publishEvent("cellFocusOut", apiRef2.current.getCellParams(cell.id, cell.field), event);
      }
      apiRef2.current.setState((state) => {
        return _extends({}, state, {
          tabIndex: {
            columnGroupHeader: {
              field,
              depth
            },
            columnHeader: null,
            columnHeaderFilter: null,
            cell: null
          },
          focus: {
            columnGroupHeader: {
              field,
              depth
            },
            columnHeader: null,
            columnHeaderFilter: null,
            cell: null
          }
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2]);
    const getColumnGroupHeaderFocus = React__namespace.useCallback(() => unstable_gridFocusColumnGroupHeaderSelector(apiRef2), [apiRef2]);
    const moveFocusToRelativeCell = React__namespace.useCallback((id, field, direction) => {
      let columnIndexToFocus = apiRef2.current.getColumnIndex(field);
      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef2);
      const currentPage = getVisibleRows(apiRef2, {
        pagination: props.pagination,
        paginationMode: props.paginationMode
      });
      const pinnedRows = gridPinnedRowsSelector(apiRef2);
      const currentPageRows = [].concat(pinnedRows.top || [], currentPage.rows, pinnedRows.bottom || []);
      let rowIndexToFocus = currentPageRows.findIndex((row) => row.id === id);
      if (direction === "right") {
        columnIndexToFocus += 1;
      } else if (direction === "left") {
        columnIndexToFocus -= 1;
      } else {
        rowIndexToFocus += 1;
      }
      if (columnIndexToFocus >= visibleColumns.length) {
        rowIndexToFocus += 1;
        if (rowIndexToFocus < currentPageRows.length) {
          columnIndexToFocus = 0;
        }
      } else if (columnIndexToFocus < 0) {
        rowIndexToFocus -= 1;
        if (rowIndexToFocus >= 0) {
          columnIndexToFocus = visibleColumns.length - 1;
        }
      }
      rowIndexToFocus = clamp(rowIndexToFocus, 0, currentPageRows.length - 1);
      const rowToFocus = currentPageRows[rowIndexToFocus];
      if (!rowToFocus) {
        return;
      }
      const colSpanInfo = apiRef2.current.unstable_getCellColSpanInfo(rowToFocus.id, columnIndexToFocus);
      if (colSpanInfo && colSpanInfo.spannedByColSpan) {
        if (direction === "left" || direction === "below") {
          columnIndexToFocus = colSpanInfo.leftVisibleCellIndex;
        } else if (direction === "right") {
          columnIndexToFocus = colSpanInfo.rightVisibleCellIndex;
        }
      }
      columnIndexToFocus = clamp(columnIndexToFocus, 0, visibleColumns.length - 1);
      const columnToFocus = visibleColumns[columnIndexToFocus];
      apiRef2.current.setCellFocus(rowToFocus.id, columnToFocus.field);
    }, [apiRef2, props.pagination, props.paginationMode]);
    const handleCellDoubleClick = React__namespace.useCallback(({
      id,
      field
    }) => {
      apiRef2.current.setCellFocus(id, field);
    }, [apiRef2]);
    const handleCellKeyDown = React__namespace.useCallback((params, event) => {
      if (event.key === "Enter" || event.key === "Tab" || event.key === "Shift" || isNavigationKey(event.key)) {
        return;
      }
      apiRef2.current.setCellFocus(params.id, params.field);
    }, [apiRef2]);
    const handleColumnHeaderFocus = React__namespace.useCallback(({
      field
    }, event) => {
      if (event.target !== event.currentTarget) {
        return;
      }
      apiRef2.current.setColumnHeaderFocus(field, event);
    }, [apiRef2]);
    const handleColumnGroupHeaderFocus = React__namespace.useCallback(({
      fields,
      depth
    }, event) => {
      if (event.target !== event.currentTarget) {
        return;
      }
      const focusedColumnGroup = unstable_gridFocusColumnGroupHeaderSelector(apiRef2);
      if (focusedColumnGroup !== null && focusedColumnGroup.depth === depth && fields.includes(focusedColumnGroup.field)) {
        return;
      }
      apiRef2.current.setColumnGroupHeaderFocus(fields[0], depth, event);
    }, [apiRef2]);
    const handleBlur = React__namespace.useCallback((_2, event) => {
      var _event$relatedTarget;
      if ((_event$relatedTarget = event.relatedTarget) != null && _event$relatedTarget.className.includes(gridClasses.columnHeader)) {
        return;
      }
      logger.debug(`Clearing focus`);
      apiRef2.current.setState((state) => _extends({}, state, {
        focus: {
          cell: null,
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      }));
    }, [logger, apiRef2]);
    const handleCellMouseDown = React__namespace.useCallback((params) => {
      lastClickedCell.current = params;
    }, []);
    const handleDocumentClick = React__namespace.useCallback((event) => {
      const cellParams = lastClickedCell.current;
      lastClickedCell.current = null;
      const focusedCell = gridFocusCellSelector(apiRef2);
      const canUpdateFocus = apiRef2.current.unstable_applyPipeProcessors("canUpdateFocus", true, {
        event,
        cell: cellParams
      });
      if (!canUpdateFocus) {
        return;
      }
      if (!focusedCell) {
        if (cellParams) {
          apiRef2.current.setCellFocus(cellParams.id, cellParams.field);
        }
        return;
      }
      if ((cellParams == null ? void 0 : cellParams.id) === focusedCell.id && (cellParams == null ? void 0 : cellParams.field) === focusedCell.field) {
        return;
      }
      const cellElement = apiRef2.current.getCellElement(focusedCell.id, focusedCell.field);
      if (cellElement != null && cellElement.contains(event.target)) {
        return;
      }
      if (cellParams) {
        apiRef2.current.setCellFocus(cellParams.id, cellParams.field);
      } else {
        apiRef2.current.setState((state) => _extends({}, state, {
          focus: {
            cell: null,
            columnHeader: null,
            columnHeaderFilter: null,
            columnGroupHeader: null
          }
        }));
        apiRef2.current.forceUpdate();
        publishCellFocusOut(focusedCell, event);
      }
    }, [apiRef2, publishCellFocusOut]);
    const handleCellModeChange = React__namespace.useCallback((params) => {
      if (params.cellMode === "view") {
        return;
      }
      const cell = gridFocusCellSelector(apiRef2);
      if ((cell == null ? void 0 : cell.id) !== params.id || (cell == null ? void 0 : cell.field) !== params.field) {
        apiRef2.current.setCellFocus(params.id, params.field);
      }
    }, [apiRef2]);
    const handleRowSet = React__namespace.useCallback(() => {
      const cell = gridFocusCellSelector(apiRef2);
      if (cell && !apiRef2.current.getRow(cell.id)) {
        apiRef2.current.setState((state) => _extends({}, state, {
          focus: {
            cell: null,
            columnHeader: null,
            columnHeaderFilter: null,
            columnGroupHeader: null
          }
        }));
      }
    }, [apiRef2]);
    const handlePaginationModelChange = useEventCallback(() => {
      const currentFocusedCell = gridFocusCellSelector(apiRef2);
      if (!currentFocusedCell) {
        return;
      }
      const currentPage = getVisibleRows(apiRef2, {
        pagination: props.pagination,
        paginationMode: props.paginationMode
      });
      const rowIsInCurrentPage = currentPage.rows.find((row) => row.id === currentFocusedCell.id);
      if (rowIsInCurrentPage) {
        return;
      }
      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef2);
      apiRef2.current.setState((state) => {
        return _extends({}, state, {
          tabIndex: {
            cell: {
              id: currentPage.rows[0].id,
              field: visibleColumns[0].field
            },
            columnGroupHeader: null,
            columnHeader: null,
            columnHeaderFilter: null
          }
        });
      });
    });
    const focusApi = {
      setCellFocus,
      setColumnHeaderFocus,
      setColumnHeaderFilterFocus
    };
    const focusPrivateApi = {
      moveFocusToRelativeCell,
      setColumnGroupHeaderFocus,
      getColumnGroupHeaderFocus
    };
    useGridApiMethod(apiRef2, focusApi, "public");
    useGridApiMethod(apiRef2, focusPrivateApi, "private");
    React__namespace.useEffect(() => {
      const doc = ownerDocument(apiRef2.current.rootElementRef.current);
      doc.addEventListener("mouseup", handleDocumentClick);
      return () => {
        doc.removeEventListener("mouseup", handleDocumentClick);
      };
    }, [apiRef2, handleDocumentClick]);
    useGridApiEventHandler(apiRef2, "columnHeaderBlur", handleBlur);
    useGridApiEventHandler(apiRef2, "headerFilterBlur", handleBlur);
    useGridApiEventHandler(apiRef2, "cellDoubleClick", handleCellDoubleClick);
    useGridApiEventHandler(apiRef2, "cellMouseDown", handleCellMouseDown);
    useGridApiEventHandler(apiRef2, "cellKeyDown", handleCellKeyDown);
    useGridApiEventHandler(apiRef2, "cellModeChange", handleCellModeChange);
    useGridApiEventHandler(apiRef2, "columnHeaderFocus", handleColumnHeaderFocus);
    useGridApiEventHandler(apiRef2, "columnGroupHeaderFocus", handleColumnGroupHeaderFocus);
    useGridApiEventHandler(apiRef2, "rowsSet", handleRowSet);
    useGridApiEventHandler(apiRef2, "paginationModelChange", handlePaginationModelChange);
  };
  function enrichPageRowsWithPinnedRows(apiRef2, rows) {
    const pinnedRows = gridPinnedRowsSelector(apiRef2) || {};
    return [...pinnedRows.top || [], ...rows, ...pinnedRows.bottom || []];
  }
  const getLeftColumnIndex = ({
    currentColIndex,
    firstColIndex,
    lastColIndex,
    direction
  }) => {
    if (direction === "rtl") {
      if (currentColIndex < lastColIndex) {
        return currentColIndex + 1;
      }
    } else if (direction === "ltr") {
      if (currentColIndex > firstColIndex) {
        return currentColIndex - 1;
      }
    }
    return null;
  };
  const getRightColumnIndex = ({
    currentColIndex,
    firstColIndex,
    lastColIndex,
    direction
  }) => {
    if (direction === "rtl") {
      if (currentColIndex > firstColIndex) {
        return currentColIndex - 1;
      }
    } else if (direction === "ltr") {
      if (currentColIndex < lastColIndex) {
        return currentColIndex + 1;
      }
    }
    return null;
  };
  const useGridKeyboardNavigation = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useGridKeyboardNavigation");
    const initialCurrentPageRows = useGridVisibleRows(apiRef2, props).rows;
    const theme = useTheme();
    const currentPageRows = React__namespace.useMemo(() => enrichPageRowsWithPinnedRows(apiRef2, initialCurrentPageRows), [apiRef2, initialCurrentPageRows]);
    const headerFilteringEnabled = (
      // @ts-expect-error // TODO move relevant code to the `DataGridPro`
      props.signature !== "DataGrid" && props.unstable_headerFilters
    );
    const goToCell = React__namespace.useCallback((colIndex, rowId, closestColumnToUse = "left") => {
      const visibleSortedRows = gridExpandedSortedRowEntriesSelector(apiRef2);
      const nextCellColSpanInfo = apiRef2.current.unstable_getCellColSpanInfo(rowId, colIndex);
      if (nextCellColSpanInfo && nextCellColSpanInfo.spannedByColSpan) {
        if (closestColumnToUse === "left") {
          colIndex = nextCellColSpanInfo.leftVisibleCellIndex;
        } else if (closestColumnToUse === "right") {
          colIndex = nextCellColSpanInfo.rightVisibleCellIndex;
        }
      }
      const rowIndexRelativeToAllRows = visibleSortedRows.findIndex((row) => row.id === rowId);
      logger.debug(`Navigating to cell row ${rowIndexRelativeToAllRows}, col ${colIndex}`);
      apiRef2.current.scrollToIndexes({
        colIndex,
        rowIndex: rowIndexRelativeToAllRows
      });
      const field = apiRef2.current.getVisibleColumns()[colIndex].field;
      apiRef2.current.setCellFocus(rowId, field);
    }, [apiRef2, logger]);
    const goToHeader = React__namespace.useCallback((colIndex, event) => {
      logger.debug(`Navigating to header col ${colIndex}`);
      apiRef2.current.scrollToIndexes({
        colIndex
      });
      const field = apiRef2.current.getVisibleColumns()[colIndex].field;
      apiRef2.current.setColumnHeaderFocus(field, event);
    }, [apiRef2, logger]);
    const goToHeaderFilter = React__namespace.useCallback((colIndex, event) => {
      logger.debug(`Navigating to header filter col ${colIndex}`);
      apiRef2.current.scrollToIndexes({
        colIndex
      });
      const field = apiRef2.current.getVisibleColumns()[colIndex].field;
      apiRef2.current.setColumnHeaderFilterFocus(field, event);
    }, [apiRef2, logger]);
    const goToGroupHeader = React__namespace.useCallback((colIndex, depth, event) => {
      logger.debug(`Navigating to header col ${colIndex}`);
      apiRef2.current.scrollToIndexes({
        colIndex
      });
      const {
        field
      } = apiRef2.current.getVisibleColumns()[colIndex];
      apiRef2.current.setColumnGroupHeaderFocus(field, depth, event);
    }, [apiRef2, logger]);
    const getRowIdFromIndex = React__namespace.useCallback((rowIndex) => {
      return currentPageRows == null ? void 0 : currentPageRows[rowIndex].id;
    }, [currentPageRows]);
    const handleColumnHeaderKeyDown = React__namespace.useCallback((params, event) => {
      const headerTitleNode = event.currentTarget.querySelector(`.${gridClasses.columnHeaderTitleContainerContent}`);
      const isFromInsideContent = !!headerTitleNode && headerTitleNode.contains(event.target);
      if (isFromInsideContent && params.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field) {
        return;
      }
      const dimensions = apiRef2.current.getRootDimensions();
      if (!dimensions) {
        return;
      }
      const viewportPageSize = apiRef2.current.getViewportPageSize();
      const colIndexBefore = params.field ? apiRef2.current.getColumnIndex(params.field) : 0;
      const firstRowIndexInPage = 0;
      const lastRowIndexInPage = currentPageRows.length - 1;
      const firstColIndex = 0;
      const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef2).length - 1;
      const columnGroupMaxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef2);
      let shouldPreventDefault = true;
      switch (event.key) {
        case "ArrowDown": {
          {
            if (headerFilteringEnabled) {
              goToHeaderFilter(colIndexBefore, event);
            } else {
              goToCell(colIndexBefore, getRowIdFromIndex(firstRowIndexInPage));
            }
          }
          break;
        }
        case "ArrowRight": {
          const rightColIndex = getRightColumnIndex({
            currentColIndex: colIndexBefore,
            firstColIndex,
            lastColIndex,
            direction: theme.direction
          });
          if (rightColIndex !== null) {
            goToHeader(rightColIndex, event);
          }
          break;
        }
        case "ArrowLeft": {
          const leftColIndex = getLeftColumnIndex({
            currentColIndex: colIndexBefore,
            firstColIndex,
            lastColIndex,
            direction: theme.direction
          });
          if (leftColIndex !== null) {
            goToHeader(leftColIndex, event);
          }
          break;
        }
        case "ArrowUp": {
          if (columnGroupMaxDepth > 0) {
            goToGroupHeader(colIndexBefore, columnGroupMaxDepth - 1, event);
          }
          break;
        }
        case "PageDown": {
          if (lastRowIndexInPage !== null) {
            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
          }
          break;
        }
        case "Home": {
          goToHeader(firstColIndex, event);
          break;
        }
        case "End": {
          goToHeader(lastColIndex, event);
          break;
        }
        case "Enter": {
          if (event.ctrlKey || event.metaKey) {
            apiRef2.current.toggleColumnMenu(params.field);
          }
          break;
        }
        case " ": {
          break;
        }
        default: {
          shouldPreventDefault = false;
        }
      }
      if (shouldPreventDefault) {
        event.preventDefault();
      }
    }, [apiRef2, currentPageRows.length, headerFilteringEnabled, goToHeaderFilter, goToCell, getRowIdFromIndex, theme.direction, goToHeader, goToGroupHeader]);
    const handleHeaderFilterKeyDown = React__namespace.useCallback((params, event) => {
      const dimensions = apiRef2.current.getRootDimensions();
      if (!dimensions) {
        return;
      }
      const isEditing = unstable_gridHeaderFilteringEditFieldSelector(apiRef2) === params.field;
      const isHeaderMenuOpen = unstable_gridHeaderFilteringMenuSelector(apiRef2) === params.field;
      if (isEditing || isHeaderMenuOpen || !isNavigationKey(event.key)) {
        return;
      }
      const viewportPageSize = apiRef2.current.getViewportPageSize();
      const colIndexBefore = params.field ? apiRef2.current.getColumnIndex(params.field) : 0;
      const firstRowIndexInPage = 0;
      const lastRowIndexInPage = currentPageRows.length - 1;
      const firstColIndex = 0;
      const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef2).length - 1;
      let shouldPreventDefault = true;
      switch (event.key) {
        case "ArrowDown": {
          const rowId = getRowIdFromIndex(firstRowIndexInPage);
          if (rowId != null) {
            goToCell(colIndexBefore, rowId);
          }
          break;
        }
        case "ArrowRight": {
          const rightColIndex = getRightColumnIndex({
            currentColIndex: colIndexBefore,
            firstColIndex,
            lastColIndex,
            direction: theme.direction
          });
          if (rightColIndex !== null) {
            goToHeaderFilter(rightColIndex, event);
          }
          break;
        }
        case "ArrowLeft": {
          const leftColIndex = getLeftColumnIndex({
            currentColIndex: colIndexBefore,
            firstColIndex,
            lastColIndex,
            direction: theme.direction
          });
          if (leftColIndex !== null) {
            goToHeaderFilter(leftColIndex, event);
          } else {
            apiRef2.current.setColumnHeaderFilterFocus(params.field, event);
          }
          break;
        }
        case "ArrowUp": {
          goToHeader(colIndexBefore, event);
          break;
        }
        case "PageDown": {
          if (lastRowIndexInPage !== null) {
            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
          }
          break;
        }
        case "Home": {
          goToHeaderFilter(firstColIndex, event);
          break;
        }
        case "End": {
          goToHeaderFilter(lastColIndex, event);
          break;
        }
        case " ": {
          break;
        }
        default: {
          shouldPreventDefault = false;
        }
      }
      if (shouldPreventDefault) {
        event.preventDefault();
      }
    }, [apiRef2, currentPageRows.length, goToHeaderFilter, theme.direction, goToHeader, goToCell, getRowIdFromIndex]);
    const handleColumnGroupHeaderKeyDown = React__namespace.useCallback((params, event) => {
      const dimensions = apiRef2.current.getRootDimensions();
      if (!dimensions) {
        return;
      }
      const focusedColumnGroup = unstable_gridFocusColumnGroupHeaderSelector(apiRef2);
      if (focusedColumnGroup === null) {
        return;
      }
      const {
        field: currentField,
        depth: currentDepth
      } = focusedColumnGroup;
      const {
        fields,
        depth,
        maxDepth
      } = params;
      const viewportPageSize = apiRef2.current.getViewportPageSize();
      const currentColIndex = apiRef2.current.getColumnIndex(currentField);
      const colIndexBefore = currentField ? apiRef2.current.getColumnIndex(currentField) : 0;
      const firstRowIndexInPage = 0;
      const lastRowIndexInPage = currentPageRows.length - 1;
      const firstColIndex = 0;
      const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef2).length - 1;
      let shouldPreventDefault = true;
      switch (event.key) {
        case "ArrowDown": {
          if (depth === maxDepth - 1) {
            goToHeader(currentColIndex, event);
          } else {
            goToGroupHeader(currentColIndex, currentDepth + 1, event);
          }
          break;
        }
        case "ArrowUp": {
          if (depth > 0) {
            goToGroupHeader(currentColIndex, currentDepth - 1, event);
          }
          break;
        }
        case "ArrowRight": {
          const remainingRightColumns = fields.length - fields.indexOf(currentField) - 1;
          if (currentColIndex + remainingRightColumns + 1 <= lastColIndex) {
            goToGroupHeader(currentColIndex + remainingRightColumns + 1, currentDepth, event);
          }
          break;
        }
        case "ArrowLeft": {
          const remainingLeftColumns = fields.indexOf(currentField);
          if (currentColIndex - remainingLeftColumns - 1 >= firstColIndex) {
            goToGroupHeader(currentColIndex - remainingLeftColumns - 1, currentDepth, event);
          }
          break;
        }
        case "PageDown": {
          if (lastRowIndexInPage !== null) {
            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
          }
          break;
        }
        case "Home": {
          goToGroupHeader(firstColIndex, currentDepth, event);
          break;
        }
        case "End": {
          goToGroupHeader(lastColIndex, currentDepth, event);
          break;
        }
        case " ": {
          break;
        }
        default: {
          shouldPreventDefault = false;
        }
      }
      if (shouldPreventDefault) {
        event.preventDefault();
      }
    }, [apiRef2, currentPageRows.length, goToHeader, goToGroupHeader, goToCell, getRowIdFromIndex]);
    const handleCellKeyDown = React__namespace.useCallback((params, event) => {
      if (!event.currentTarget.contains(event.target)) {
        return;
      }
      const cellParams = apiRef2.current.getCellParams(params.id, params.field);
      if (cellParams.cellMode === GridCellModes.Edit || !isNavigationKey(event.key)) {
        return;
      }
      const canUpdateFocus = apiRef2.current.unstable_applyPipeProcessors("canUpdateFocus", true, {
        event,
        cell: cellParams
      });
      if (!canUpdateFocus) {
        return;
      }
      const dimensions = apiRef2.current.getRootDimensions();
      if (currentPageRows.length === 0 || !dimensions) {
        return;
      }
      const direction = theme.direction;
      const viewportPageSize = apiRef2.current.getViewportPageSize();
      const colIndexBefore = params.field ? apiRef2.current.getColumnIndex(params.field) : 0;
      const rowIndexBefore = currentPageRows.findIndex((row) => row.id === params.id);
      const firstRowIndexInPage = 0;
      const lastRowIndexInPage = currentPageRows.length - 1;
      const firstColIndex = 0;
      const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef2).length - 1;
      let shouldPreventDefault = true;
      switch (event.key) {
        case "ArrowDown": {
          if (rowIndexBefore < lastRowIndexInPage) {
            goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore + 1));
          }
          break;
        }
        case "ArrowUp": {
          if (rowIndexBefore > firstRowIndexInPage) {
            goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore - 1));
          } else if (headerFilteringEnabled) {
            goToHeaderFilter(colIndexBefore, event);
          } else {
            goToHeader(colIndexBefore, event);
          }
          break;
        }
        case "ArrowRight": {
          const rightColIndex = getRightColumnIndex({
            currentColIndex: colIndexBefore,
            firstColIndex,
            lastColIndex,
            direction
          });
          if (rightColIndex !== null) {
            goToCell(rightColIndex, getRowIdFromIndex(rowIndexBefore), direction === "rtl" ? "left" : "right");
          }
          break;
        }
        case "ArrowLeft": {
          const leftColIndex = getLeftColumnIndex({
            currentColIndex: colIndexBefore,
            firstColIndex,
            lastColIndex,
            direction
          });
          if (leftColIndex !== null) {
            goToCell(leftColIndex, getRowIdFromIndex(rowIndexBefore), direction === "rtl" ? "right" : "left");
          }
          break;
        }
        case "Tab": {
          if (event.shiftKey && colIndexBefore > firstColIndex) {
            goToCell(colIndexBefore - 1, getRowIdFromIndex(rowIndexBefore), "left");
          } else if (!event.shiftKey && colIndexBefore < lastColIndex) {
            goToCell(colIndexBefore + 1, getRowIdFromIndex(rowIndexBefore), "right");
          }
          break;
        }
        case " ": {
          const field = params.field;
          if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
            break;
          }
          const colDef = params.colDef;
          if (colDef && colDef.type === "treeDataGroup") {
            break;
          }
          if (!event.shiftKey && rowIndexBefore < lastRowIndexInPage) {
            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));
          }
          break;
        }
        case "PageDown": {
          if (rowIndexBefore < lastRowIndexInPage) {
            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));
          }
          break;
        }
        case "PageUp": {
          const nextRowIndex = Math.max(rowIndexBefore - viewportPageSize, firstRowIndexInPage);
          if (nextRowIndex !== rowIndexBefore && nextRowIndex >= firstRowIndexInPage) {
            goToCell(colIndexBefore, getRowIdFromIndex(nextRowIndex));
          } else {
            goToHeader(colIndexBefore, event);
          }
          break;
        }
        case "Home": {
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            goToCell(firstColIndex, getRowIdFromIndex(firstRowIndexInPage));
          } else {
            goToCell(firstColIndex, getRowIdFromIndex(rowIndexBefore));
          }
          break;
        }
        case "End": {
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            goToCell(lastColIndex, getRowIdFromIndex(lastRowIndexInPage));
          } else {
            goToCell(lastColIndex, getRowIdFromIndex(rowIndexBefore));
          }
          break;
        }
        default: {
          shouldPreventDefault = false;
        }
      }
      if (shouldPreventDefault) {
        event.preventDefault();
      }
    }, [apiRef2, currentPageRows, theme.direction, goToCell, getRowIdFromIndex, headerFilteringEnabled, goToHeaderFilter, goToHeader]);
    const checkIfCanStartEditing = React__namespace.useCallback((initialValue, {
      event
    }) => {
      if (event.key === " ") {
        return false;
      }
      return initialValue;
    }, []);
    useGridRegisterPipeProcessor(apiRef2, "canStartEditing", checkIfCanStartEditing);
    useGridApiEventHandler(apiRef2, "columnHeaderKeyDown", handleColumnHeaderKeyDown);
    useGridApiEventHandler(apiRef2, "headerFilterKeyDown", handleHeaderFilterKeyDown);
    useGridApiEventHandler(apiRef2, "columnGroupHeaderKeyDown", handleColumnGroupHeaderKeyDown);
    useGridApiEventHandler(apiRef2, "cellKeyDown", handleCellKeyDown);
  };
  const paginationStateInitializer = (state, props) => {
    var _props$paginationMode, _props$initialState;
    const paginationModel = _extends({}, getDefaultGridPaginationModel(props.autoPageSize), (_props$paginationMode = props.paginationModel) != null ? _props$paginationMode : (_props$initialState = props.initialState) == null || (_props$initialState = _props$initialState.pagination) == null ? void 0 : _props$initialState.paginationModel);
    throwIfPageSizeExceedsTheLimit(paginationModel.pageSize, props.signature);
    return _extends({}, state, {
      pagination: {
        paginationModel
      }
    });
  };
  const mergeStateWithPaginationModel = (rowCount, signature, paginationModelProp) => (paginationState) => {
    var _paginationModelProp$;
    let paginationModel = paginationState.paginationModel;
    const pageSize2 = (_paginationModelProp$ = paginationModelProp == null ? void 0 : paginationModelProp.pageSize) != null ? _paginationModelProp$ : paginationModel.pageSize;
    const pageCount = getPageCount(rowCount, pageSize2);
    if (paginationModelProp && ((paginationModelProp == null ? void 0 : paginationModelProp.page) !== paginationModel.page || (paginationModelProp == null ? void 0 : paginationModelProp.pageSize) !== paginationModel.pageSize)) {
      paginationModel = paginationModelProp;
    }
    const validPage = getValidPage(paginationModel.page, pageCount);
    if (validPage !== paginationModel.page) {
      paginationModel = _extends({}, paginationModel, {
        page: validPage
      });
    }
    throwIfPageSizeExceedsTheLimit(paginationModel.pageSize, signature);
    return {
      paginationModel
    };
  };
  const useGridPagination = (apiRef2, props) => {
    var _props$initialState3;
    const logger = useGridLogger(apiRef2, "useGridPagination");
    const visibleTopLevelRowCount = useGridSelector(apiRef2, gridFilteredTopLevelRowCountSelector);
    const densityFactor = useGridSelector(apiRef2, gridDensityFactorSelector);
    const rowHeight = Math.floor(props.rowHeight * densityFactor);
    apiRef2.current.registerControlState({
      stateId: "pagination",
      propModel: props.paginationModel,
      propOnChange: props.onPaginationModelChange,
      stateSelector: gridPaginationModelSelector,
      changeEvent: "paginationModelChange"
    });
    const setPage = React__namespace.useCallback((page) => {
      const currentModel = gridPaginationModelSelector(apiRef2);
      if (page === currentModel.page) {
        return;
      }
      logger.debug(`Setting page to ${page}`);
      apiRef2.current.setPaginationModel({
        page,
        pageSize: currentModel.pageSize
      });
    }, [apiRef2, logger]);
    const setPageSize = React__namespace.useCallback((pageSize2) => {
      const currentModel = gridPaginationModelSelector(apiRef2);
      if (pageSize2 === currentModel.pageSize) {
        return;
      }
      logger.debug(`Setting page size to ${pageSize2}`);
      apiRef2.current.setPaginationModel({
        pageSize: pageSize2,
        page: currentModel.page
      });
    }, [apiRef2, logger]);
    const setPaginationModel = React__namespace.useCallback((paginationModel) => {
      var _props$rowCount;
      const currentModel = gridPaginationModelSelector(apiRef2);
      if (paginationModel === currentModel) {
        return;
      }
      logger.debug("Setting 'paginationModel' to", paginationModel);
      apiRef2.current.updateControlState("pagination", mergeStateWithPaginationModel((_props$rowCount = props.rowCount) != null ? _props$rowCount : visibleTopLevelRowCount, props.signature, paginationModel), "setPaginationModel");
      apiRef2.current.forceUpdate();
    }, [apiRef2, logger, props.rowCount, props.signature, visibleTopLevelRowCount]);
    const pageApi = {
      setPage,
      setPageSize,
      setPaginationModel
    };
    useGridApiMethod(apiRef2, pageApi, "public");
    const stateExportPreProcessing = React__namespace.useCallback((prevState, context) => {
      var _props$initialState2;
      const paginationModel = gridPaginationModelSelector(apiRef2);
      const shouldExportPaginationModel = (
        // Always export if the `exportOnlyDirtyModels` property is not activated
        !context.exportOnlyDirtyModels || // Always export if the `paginationModel` is controlled
        props.paginationModel != null || // Always export if the `paginationModel` has been initialized
        ((_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.pagination) == null ? void 0 : _props$initialState2.paginationModel) != null || // Export if `page` or `pageSize` is not equal to the default value
        paginationModel.page !== 0 && paginationModel.pageSize !== defaultPageSize(props.autoPageSize)
      );
      if (!shouldExportPaginationModel) {
        return prevState;
      }
      return _extends({}, prevState, {
        pagination: _extends({}, prevState.pagination, {
          paginationModel
        })
      });
    }, [apiRef2, props.paginationModel, (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.pagination) == null ? void 0 : _props$initialState3.paginationModel, props.autoPageSize]);
    const stateRestorePreProcessing = React__namespace.useCallback((params, context) => {
      var _context$stateToResto, _context$stateToResto2, _props$rowCount2;
      const paginationModel = (_context$stateToResto = context.stateToRestore.pagination) != null && _context$stateToResto.paginationModel ? _extends({}, getDefaultGridPaginationModel(props.autoPageSize), (_context$stateToResto2 = context.stateToRestore.pagination) == null ? void 0 : _context$stateToResto2.paginationModel) : gridPaginationModelSelector(apiRef2);
      apiRef2.current.updateControlState("pagination", mergeStateWithPaginationModel((_props$rowCount2 = props.rowCount) != null ? _props$rowCount2 : visibleTopLevelRowCount, props.signature, paginationModel), "stateRestorePreProcessing");
      return params;
    }, [apiRef2, props.autoPageSize, props.rowCount, props.signature, visibleTopLevelRowCount]);
    useGridRegisterPipeProcessor(apiRef2, "exportState", stateExportPreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "restoreState", stateRestorePreProcessing);
    const handlePaginationModelChange = () => {
      var _apiRef$current$virtu;
      const paginationModel = gridPaginationModelSelector(apiRef2);
      if ((_apiRef$current$virtu = apiRef2.current.virtualScrollerRef) != null && _apiRef$current$virtu.current) {
        apiRef2.current.scrollToIndexes({
          rowIndex: paginationModel.page * paginationModel.pageSize
        });
      }
      apiRef2.current.forceUpdate();
    };
    const handleUpdateAutoPageSize = React__namespace.useCallback(() => {
      const dimensions = apiRef2.current.getRootDimensions();
      if (!props.autoPageSize || !dimensions) {
        return;
      }
      const pinnedRowsHeight = calculatePinnedRowsHeight(apiRef2);
      const maximumPageSizeWithoutScrollBar = Math.floor((dimensions.viewportInnerSize.height - pinnedRowsHeight.top - pinnedRowsHeight.bottom) / rowHeight);
      apiRef2.current.setPageSize(maximumPageSizeWithoutScrollBar);
    }, [apiRef2, props.autoPageSize, rowHeight]);
    useGridApiEventHandler(apiRef2, "viewportInnerSizeChange", handleUpdateAutoPageSize);
    useGridApiEventHandler(apiRef2, "paginationModelChange", handlePaginationModelChange);
    React__namespace.useEffect(() => {
    }, [props.rowCount, props.paginationMode]);
    React__namespace.useEffect(() => {
      var _props$rowCount3;
      apiRef2.current.updateControlState("pagination", mergeStateWithPaginationModel((_props$rowCount3 = props.rowCount) != null ? _props$rowCount3 : visibleTopLevelRowCount, props.signature, props.paginationModel));
    }, [apiRef2, props.paginationModel, props.rowCount, props.paginationMode, visibleTopLevelRowCount, props.signature]);
    React__namespace.useEffect(() => {
      handleUpdateAutoPageSize();
    }, [handleUpdateAutoPageSize]);
  };
  const preferencePanelStateInitializer = (state, props) => {
    var _props$initialState$p, _props$initialState;
    return _extends({}, state, {
      preferencePanel: (_props$initialState$p = (_props$initialState = props.initialState) == null ? void 0 : _props$initialState.preferencePanel) != null ? _props$initialState$p : {
        open: false
      }
    });
  };
  const useGridPreferencesPanel = (apiRef2, props) => {
    var _props$initialState3;
    const logger = useGridLogger(apiRef2, "useGridPreferencesPanel");
    const hideTimeout = React__namespace.useRef();
    const immediateTimeout = React__namespace.useRef();
    const hidePreferences = React__namespace.useCallback(() => {
      logger.debug("Hiding Preferences Panel");
      const preferencePanelState = gridPreferencePanelStateSelector(apiRef2.current.state);
      if (preferencePanelState.openedPanelValue) {
        apiRef2.current.publishEvent("preferencePanelClose", {
          openedPanelValue: preferencePanelState.openedPanelValue
        });
      }
      apiRef2.current.setState((state) => _extends({}, state, {
        preferencePanel: {
          open: false
        }
      }));
      apiRef2.current.forceUpdate();
    }, [apiRef2, logger]);
    const doNotHidePanel = React__namespace.useCallback(() => {
      immediateTimeout.current = setTimeout(() => clearTimeout(hideTimeout.current), 0);
    }, []);
    const hidePreferencesDelayed = React__namespace.useCallback(() => {
      hideTimeout.current = setTimeout(hidePreferences, 100);
    }, [hidePreferences]);
    const showPreferences = React__namespace.useCallback((newValue, panelId, labelId) => {
      logger.debug("Opening Preferences Panel");
      doNotHidePanel();
      apiRef2.current.setState((state) => _extends({}, state, {
        preferencePanel: _extends({}, state.preferencePanel, {
          open: true,
          openedPanelValue: newValue,
          panelId,
          labelId
        })
      }));
      apiRef2.current.publishEvent("preferencePanelOpen", {
        openedPanelValue: newValue
      });
      apiRef2.current.forceUpdate();
    }, [logger, doNotHidePanel, apiRef2]);
    useGridApiMethod(apiRef2, {
      showPreferences,
      hidePreferences: hidePreferencesDelayed
    }, "public");
    const stateExportPreProcessing = React__namespace.useCallback((prevState, context) => {
      var _props$initialState2;
      const preferencePanelToExport = gridPreferencePanelStateSelector(apiRef2.current.state);
      const shouldExportPreferencePanel = (
        // Always export if the `exportOnlyDirtyModels` property is not activated
        !context.exportOnlyDirtyModels || // Always export if the panel was initialized
        ((_props$initialState2 = props.initialState) == null ? void 0 : _props$initialState2.preferencePanel) != null || // Always export if the panel is opened
        preferencePanelToExport.open
      );
      if (!shouldExportPreferencePanel) {
        return prevState;
      }
      return _extends({}, prevState, {
        preferencePanel: preferencePanelToExport
      });
    }, [apiRef2, (_props$initialState3 = props.initialState) == null ? void 0 : _props$initialState3.preferencePanel]);
    const stateRestorePreProcessing = React__namespace.useCallback((params, context) => {
      const preferencePanel = context.stateToRestore.preferencePanel;
      if (preferencePanel != null) {
        apiRef2.current.setState((state) => _extends({}, state, {
          preferencePanel
        }));
      }
      return params;
    }, [apiRef2]);
    useGridRegisterPipeProcessor(apiRef2, "exportState", stateExportPreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "restoreState", stateRestorePreProcessing);
    React__namespace.useEffect(() => {
      return () => {
        clearTimeout(hideTimeout.current);
        clearTimeout(immediateTimeout.current);
      };
    }, []);
  };
  const _excluded$f = ["id", "field"], _excluded2$2 = ["id", "field"];
  const missingOnProcessRowUpdateErrorWarning$1 = buildWarning(["MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.", "To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.", "For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence."], "error");
  const useGridCellEditing = (apiRef2, props) => {
    const [cellModesModel, setCellModesModel] = React__namespace.useState({});
    const cellModesModelRef = React__namespace.useRef(cellModesModel);
    const prevCellModesModel = React__namespace.useRef({});
    const {
      processRowUpdate,
      onProcessRowUpdateError,
      cellModesModel: cellModesModelProp,
      onCellModesModelChange
    } = props;
    const runIfEditModeIsCell = (callback) => (...args) => {
      if (props.editMode === GridEditModes.Cell) {
        callback(...args);
      }
    };
    const throwIfNotEditable = React__namespace.useCallback((id, field) => {
      const params = apiRef2.current.getCellParams(id, field);
      if (!apiRef2.current.isCellEditable(params)) {
        throw new Error(`MUI: The cell with id=${id} and field=${field} is not editable.`);
      }
    }, [apiRef2]);
    const throwIfNotInMode = React__namespace.useCallback((id, field, mode) => {
      if (apiRef2.current.getCellMode(id, field) !== mode) {
        throw new Error(`MUI: The cell with id=${id} and field=${field} is not in ${mode} mode.`);
      }
    }, [apiRef2]);
    const handleCellDoubleClick = React__namespace.useCallback((params, event) => {
      if (!params.isEditable) {
        return;
      }
      if (params.cellMode === GridCellModes.Edit) {
        return;
      }
      const newParams = _extends({}, params, {
        reason: GridCellEditStartReasons.cellDoubleClick
      });
      apiRef2.current.publishEvent("cellEditStart", newParams, event);
    }, [apiRef2]);
    const handleCellFocusOut = React__namespace.useCallback((params, event) => {
      if (params.cellMode === GridCellModes.View) {
        return;
      }
      if (apiRef2.current.getCellMode(params.id, params.field) === GridCellModes.View) {
        return;
      }
      const newParams = _extends({}, params, {
        reason: GridCellEditStopReasons.cellFocusOut
      });
      apiRef2.current.publishEvent("cellEditStop", newParams, event);
    }, [apiRef2]);
    const handleCellKeyDown = React__namespace.useCallback((params, event) => {
      if (params.cellMode === GridCellModes.Edit) {
        if (event.which === 229) {
          return;
        }
        let reason;
        if (event.key === "Escape") {
          reason = GridCellEditStopReasons.escapeKeyDown;
        } else if (event.key === "Enter") {
          reason = GridCellEditStopReasons.enterKeyDown;
        } else if (event.key === "Tab") {
          reason = event.shiftKey ? GridCellEditStopReasons.shiftTabKeyDown : GridCellEditStopReasons.tabKeyDown;
          event.preventDefault();
        }
        if (reason) {
          const newParams = _extends({}, params, {
            reason
          });
          apiRef2.current.publishEvent("cellEditStop", newParams, event);
        }
      } else if (params.isEditable) {
        let reason;
        const canStartEditing = apiRef2.current.unstable_applyPipeProcessors("canStartEditing", true, {
          event,
          cellParams: params,
          editMode: "cell"
        });
        if (!canStartEditing) {
          return;
        }
        if (isPrintableKey(event)) {
          reason = GridCellEditStartReasons.printableKeyDown;
        } else if ((event.ctrlKey || event.metaKey) && event.key === "v") {
          reason = GridCellEditStartReasons.printableKeyDown;
        } else if (event.key === "Enter") {
          reason = GridCellEditStartReasons.enterKeyDown;
        } else if (event.key === "Delete" || event.key === "Backspace") {
          reason = GridCellEditStartReasons.deleteKeyDown;
        }
        if (reason) {
          const newParams = _extends({}, params, {
            reason,
            key: event.key
          });
          apiRef2.current.publishEvent("cellEditStart", newParams, event);
        }
      }
    }, [apiRef2]);
    const handleCellEditStart = React__namespace.useCallback((params) => {
      const {
        id,
        field,
        reason,
        key,
        colDef
      } = params;
      const startCellEditModeParams = {
        id,
        field
      };
      if (reason === GridCellEditStartReasons.printableKeyDown) {
        if (React__namespace.version.startsWith("17")) {
          startCellEditModeParams.deleteValue = true;
        } else {
          const initialValue = colDef.valueParser ? colDef.valueParser(key) : key;
          startCellEditModeParams.initialValue = initialValue;
        }
      } else if (reason === GridCellEditStartReasons.deleteKeyDown) {
        startCellEditModeParams.deleteValue = true;
      }
      apiRef2.current.startCellEditMode(startCellEditModeParams);
    }, [apiRef2]);
    const handleCellEditStop = React__namespace.useCallback((params) => {
      const {
        id,
        field,
        reason
      } = params;
      apiRef2.current.runPendingEditCellValueMutation(id, field);
      let cellToFocusAfter;
      if (reason === GridCellEditStopReasons.enterKeyDown) {
        cellToFocusAfter = "below";
      } else if (reason === GridCellEditStopReasons.tabKeyDown) {
        cellToFocusAfter = "right";
      } else if (reason === GridCellEditStopReasons.shiftTabKeyDown) {
        cellToFocusAfter = "left";
      }
      const ignoreModifications = reason === "escapeKeyDown";
      apiRef2.current.stopCellEditMode({
        id,
        field,
        ignoreModifications,
        cellToFocusAfter
      });
    }, [apiRef2]);
    useGridApiEventHandler(apiRef2, "cellDoubleClick", runIfEditModeIsCell(handleCellDoubleClick));
    useGridApiEventHandler(apiRef2, "cellFocusOut", runIfEditModeIsCell(handleCellFocusOut));
    useGridApiEventHandler(apiRef2, "cellKeyDown", runIfEditModeIsCell(handleCellKeyDown));
    useGridApiEventHandler(apiRef2, "cellEditStart", runIfEditModeIsCell(handleCellEditStart));
    useGridApiEventHandler(apiRef2, "cellEditStop", runIfEditModeIsCell(handleCellEditStop));
    useGridApiOptionHandler(apiRef2, "cellEditStart", props.onCellEditStart);
    useGridApiOptionHandler(apiRef2, "cellEditStop", props.onCellEditStop);
    const getCellMode = React__namespace.useCallback((id, field) => {
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      const isEditing = editingState[id] && editingState[id][field];
      return isEditing ? GridCellModes.Edit : GridCellModes.View;
    }, [apiRef2]);
    const updateCellModesModel = useEventCallback((newModel) => {
      const isNewModelDifferentFromProp = newModel !== props.cellModesModel;
      if (onCellModesModelChange && isNewModelDifferentFromProp) {
        onCellModesModelChange(newModel, {});
      }
      if (props.cellModesModel && isNewModelDifferentFromProp) {
        return;
      }
      setCellModesModel(newModel);
      cellModesModelRef.current = newModel;
      apiRef2.current.publishEvent("cellModesModelChange", newModel);
    });
    const updateFieldInCellModesModel = React__namespace.useCallback((id, field, newProps) => {
      const newModel = _extends({}, cellModesModelRef.current);
      if (newProps !== null) {
        newModel[id] = _extends({}, newModel[id], {
          [field]: _extends({}, newProps)
        });
      } else {
        const _newModel$id = newModel[id], otherFields = _objectWithoutPropertiesLoose(_newModel$id, [field].map(_toPropertyKey));
        newModel[id] = otherFields;
        if (Object.keys(newModel[id]).length === 0) {
          delete newModel[id];
        }
      }
      updateCellModesModel(newModel);
    }, [updateCellModesModel]);
    const updateOrDeleteFieldState = React__namespace.useCallback((id, field, newProps) => {
      apiRef2.current.setState((state) => {
        const newEditingState = _extends({}, state.editRows);
        if (newProps !== null) {
          newEditingState[id] = _extends({}, newEditingState[id], {
            [field]: _extends({}, newProps)
          });
        } else {
          delete newEditingState[id][field];
          if (Object.keys(newEditingState[id]).length === 0) {
            delete newEditingState[id];
          }
        }
        return _extends({}, state, {
          editRows: newEditingState
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2]);
    const startCellEditMode = React__namespace.useCallback((params) => {
      const {
        id,
        field
      } = params, other = _objectWithoutPropertiesLoose(params, _excluded$f);
      throwIfNotEditable(id, field);
      throwIfNotInMode(id, field, GridCellModes.View);
      updateFieldInCellModesModel(id, field, _extends({
        mode: GridCellModes.Edit
      }, other));
    }, [throwIfNotEditable, throwIfNotInMode, updateFieldInCellModesModel]);
    const updateStateToStartCellEditMode = useEventCallback((params) => {
      const {
        id,
        field,
        deleteValue,
        initialValue
      } = params;
      let newValue = apiRef2.current.getCellValue(id, field);
      let unstable_updateValueOnRender = false;
      if (deleteValue || initialValue) {
        newValue = deleteValue ? "" : initialValue;
        unstable_updateValueOnRender = true;
      }
      const newProps = {
        value: newValue,
        error: false,
        isProcessingProps: false,
        unstable_updateValueOnRender
      };
      updateOrDeleteFieldState(id, field, newProps);
      apiRef2.current.setCellFocus(id, field);
    });
    const stopCellEditMode = React__namespace.useCallback((params) => {
      const {
        id,
        field
      } = params, other = _objectWithoutPropertiesLoose(params, _excluded2$2);
      throwIfNotInMode(id, field, GridCellModes.Edit);
      updateFieldInCellModesModel(id, field, _extends({
        mode: GridCellModes.View
      }, other));
    }, [throwIfNotInMode, updateFieldInCellModesModel]);
    const updateStateToStopCellEditMode = useEventCallback(async (params) => {
      const {
        id,
        field,
        ignoreModifications,
        cellToFocusAfter = "none"
      } = params;
      throwIfNotInMode(id, field, GridCellModes.Edit);
      apiRef2.current.runPendingEditCellValueMutation(id, field);
      const finishCellEditMode = () => {
        updateOrDeleteFieldState(id, field, null);
        updateFieldInCellModesModel(id, field, null);
        if (cellToFocusAfter !== "none") {
          apiRef2.current.moveFocusToRelativeCell(id, field, cellToFocusAfter);
        }
      };
      if (ignoreModifications) {
        finishCellEditMode();
        return;
      }
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      const {
        error,
        isProcessingProps
      } = editingState[id][field];
      if (error || isProcessingProps) {
        prevCellModesModel.current[id][field].mode = GridCellModes.Edit;
        updateFieldInCellModesModel(id, field, {
          mode: GridCellModes.Edit
        });
        return;
      }
      const rowUpdate = apiRef2.current.getRowWithUpdatedValuesFromCellEditing(id, field);
      if (processRowUpdate) {
        const handleError = (errorThrown) => {
          prevCellModesModel.current[id][field].mode = GridCellModes.Edit;
          updateFieldInCellModesModel(id, field, {
            mode: GridCellModes.Edit
          });
          if (onProcessRowUpdateError) {
            onProcessRowUpdateError(errorThrown);
          } else {
            missingOnProcessRowUpdateErrorWarning$1();
          }
        };
        try {
          const row = apiRef2.current.getRow(id);
          Promise.resolve(processRowUpdate(rowUpdate, row)).then((finalRowUpdate) => {
            apiRef2.current.updateRows([finalRowUpdate]);
            finishCellEditMode();
          }).catch(handleError);
        } catch (errorThrown) {
          handleError(errorThrown);
        }
      } else {
        apiRef2.current.updateRows([rowUpdate]);
        finishCellEditMode();
      }
    });
    const setCellEditingEditCellValue = React__namespace.useCallback(async (params) => {
      var _editingState$id;
      const {
        id,
        field,
        value,
        debounceMs,
        unstable_skipValueParser: skipValueParser
      } = params;
      throwIfNotEditable(id, field);
      throwIfNotInMode(id, field, GridCellModes.Edit);
      const column2 = apiRef2.current.getColumn(field);
      const row = apiRef2.current.getRow(id);
      let parsedValue = value;
      if (column2.valueParser && !skipValueParser) {
        parsedValue = column2.valueParser(value, apiRef2.current.getCellParams(id, field));
      }
      let editingState = gridEditRowsStateSelector(apiRef2.current.state);
      let newProps = _extends({}, editingState[id][field], {
        value: parsedValue,
        changeReason: debounceMs ? "debouncedSetEditCellValue" : "setEditCellValue"
      });
      if (column2.preProcessEditCellProps) {
        const hasChanged = value !== editingState[id][field].value;
        newProps = _extends({}, newProps, {
          isProcessingProps: true
        });
        updateOrDeleteFieldState(id, field, newProps);
        newProps = await Promise.resolve(column2.preProcessEditCellProps({
          id,
          row,
          props: newProps,
          hasChanged
        }));
      }
      if (apiRef2.current.getCellMode(id, field) === GridCellModes.View) {
        return false;
      }
      editingState = gridEditRowsStateSelector(apiRef2.current.state);
      newProps = _extends({}, newProps, {
        isProcessingProps: false
      });
      newProps.value = column2.preProcessEditCellProps ? editingState[id][field].value : parsedValue;
      updateOrDeleteFieldState(id, field, newProps);
      editingState = gridEditRowsStateSelector(apiRef2.current.state);
      return !((_editingState$id = editingState[id]) != null && (_editingState$id = _editingState$id[field]) != null && _editingState$id.error);
    }, [apiRef2, throwIfNotEditable, throwIfNotInMode, updateOrDeleteFieldState]);
    const getRowWithUpdatedValuesFromCellEditing = React__namespace.useCallback((id, field) => {
      const column2 = apiRef2.current.getColumn(field);
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      const row = apiRef2.current.getRow(id);
      if (!editingState[id] || !editingState[id][field]) {
        return apiRef2.current.getRow(id);
      }
      const {
        value
      } = editingState[id][field];
      return column2.valueSetter ? column2.valueSetter({
        value,
        row
      }) : _extends({}, row, {
        [field]: value
      });
    }, [apiRef2]);
    const editingApi = {
      getCellMode,
      startCellEditMode,
      stopCellEditMode
    };
    const editingPrivateApi = {
      setCellEditingEditCellValue,
      getRowWithUpdatedValuesFromCellEditing
    };
    useGridApiMethod(apiRef2, editingApi, "public");
    useGridApiMethod(apiRef2, editingPrivateApi, "private");
    React__namespace.useEffect(() => {
      if (cellModesModelProp) {
        updateCellModesModel(cellModesModelProp);
      }
    }, [cellModesModelProp, updateCellModesModel]);
    React__namespace.useEffect(() => {
      const idToIdLookup = gridRowsDataRowIdToIdLookupSelector(apiRef2);
      const copyOfPrevCellModes = prevCellModesModel.current;
      prevCellModesModel.current = deepClone(cellModesModel);
      Object.entries(cellModesModel).forEach(([id, fields]) => {
        Object.entries(fields).forEach(([field, params]) => {
          var _copyOfPrevCellModes$, _idToIdLookup$id;
          const prevMode = ((_copyOfPrevCellModes$ = copyOfPrevCellModes[id]) == null || (_copyOfPrevCellModes$ = _copyOfPrevCellModes$[field]) == null ? void 0 : _copyOfPrevCellModes$.mode) || GridCellModes.View;
          const originalId = (_idToIdLookup$id = idToIdLookup[id]) != null ? _idToIdLookup$id : id;
          if (params.mode === GridCellModes.Edit && prevMode === GridCellModes.View) {
            updateStateToStartCellEditMode(_extends({
              id: originalId,
              field
            }, params));
          } else if (params.mode === GridCellModes.View && prevMode === GridCellModes.Edit) {
            updateStateToStopCellEditMode(_extends({
              id: originalId,
              field
            }, params));
          }
        });
      });
    }, [apiRef2, cellModesModel, updateStateToStartCellEditMode, updateStateToStopCellEditMode]);
  };
  const _excluded$e = ["id"], _excluded2$1 = ["id"];
  const missingOnProcessRowUpdateErrorWarning = buildWarning(["MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.", "To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.", "For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence."], "error");
  const useGridRowEditing = (apiRef2, props) => {
    const [rowModesModel, setRowModesModel] = React__namespace.useState({});
    const rowModesModelRef = React__namespace.useRef(rowModesModel);
    const prevRowModesModel = React__namespace.useRef({});
    const focusTimeout = React__namespace.useRef(null);
    const nextFocusedCell = React__namespace.useRef(null);
    const {
      processRowUpdate,
      onProcessRowUpdateError,
      rowModesModel: rowModesModelProp,
      onRowModesModelChange
    } = props;
    const runIfEditModeIsRow = (callback) => (...args) => {
      if (props.editMode === GridEditModes.Row) {
        callback(...args);
      }
    };
    const throwIfNotEditable = React__namespace.useCallback((id, field) => {
      const params = apiRef2.current.getCellParams(id, field);
      if (!apiRef2.current.isCellEditable(params)) {
        throw new Error(`MUI: The cell with id=${id} and field=${field} is not editable.`);
      }
    }, [apiRef2]);
    const throwIfNotInMode = React__namespace.useCallback((id, mode) => {
      if (apiRef2.current.getRowMode(id) !== mode) {
        throw new Error(`MUI: The row with id=${id} is not in ${mode} mode.`);
      }
    }, [apiRef2]);
    const handleCellDoubleClick = React__namespace.useCallback((params, event) => {
      if (!params.isEditable) {
        return;
      }
      if (apiRef2.current.getRowMode(params.id) === GridRowModes.Edit) {
        return;
      }
      const rowParams = apiRef2.current.getRowParams(params.id);
      const newParams = _extends({}, rowParams, {
        field: params.field,
        reason: GridRowEditStartReasons.cellDoubleClick
      });
      apiRef2.current.publishEvent("rowEditStart", newParams, event);
    }, [apiRef2]);
    const handleCellFocusIn = React__namespace.useCallback((params) => {
      nextFocusedCell.current = params;
    }, []);
    const handleCellFocusOut = React__namespace.useCallback((params, event) => {
      if (!params.isEditable) {
        return;
      }
      if (apiRef2.current.getRowMode(params.id) === GridRowModes.View) {
        return;
      }
      nextFocusedCell.current = null;
      focusTimeout.current = setTimeout(() => {
        var _nextFocusedCell$curr;
        focusTimeout.current = null;
        if (((_nextFocusedCell$curr = nextFocusedCell.current) == null ? void 0 : _nextFocusedCell$curr.id) !== params.id) {
          if (!apiRef2.current.getRow(params.id)) {
            return;
          }
          if (apiRef2.current.getRowMode(params.id) === GridRowModes.View) {
            return;
          }
          const rowParams = apiRef2.current.getRowParams(params.id);
          const newParams = _extends({}, rowParams, {
            field: params.field,
            reason: GridRowEditStopReasons.rowFocusOut
          });
          apiRef2.current.publishEvent("rowEditStop", newParams, event);
        }
      });
    }, [apiRef2]);
    React__namespace.useEffect(() => {
      return () => {
        clearTimeout(focusTimeout.current);
      };
    }, []);
    const handleCellKeyDown = React__namespace.useCallback((params, event) => {
      if (params.cellMode === GridRowModes.Edit) {
        if (event.which === 229) {
          return;
        }
        let reason;
        if (event.key === "Escape") {
          reason = GridRowEditStopReasons.escapeKeyDown;
        } else if (event.key === "Enter") {
          reason = GridRowEditStopReasons.enterKeyDown;
        } else if (event.key === "Tab") {
          const columnFields = gridVisibleColumnFieldsSelector(apiRef2).filter((field) => {
            const column2 = apiRef2.current.getColumn(field);
            if (column2.type === GRID_ACTIONS_COLUMN_TYPE) {
              return true;
            }
            return apiRef2.current.isCellEditable(apiRef2.current.getCellParams(params.id, field));
          });
          if (event.shiftKey) {
            if (params.field === columnFields[0]) {
              reason = GridRowEditStopReasons.shiftTabKeyDown;
            }
          } else if (params.field === columnFields[columnFields.length - 1]) {
            reason = GridRowEditStopReasons.tabKeyDown;
          }
          event.preventDefault();
          if (!reason) {
            const index = columnFields.findIndex((field) => field === params.field);
            const nextFieldToFocus = columnFields[event.shiftKey ? index - 1 : index + 1];
            apiRef2.current.setCellFocus(params.id, nextFieldToFocus);
          }
        }
        if (reason) {
          const newParams = _extends({}, apiRef2.current.getRowParams(params.id), {
            reason,
            field: params.field
          });
          apiRef2.current.publishEvent("rowEditStop", newParams, event);
        }
      } else if (params.isEditable) {
        let reason;
        const canStartEditing = apiRef2.current.unstable_applyPipeProcessors("canStartEditing", true, {
          event,
          cellParams: params,
          editMode: "row"
        });
        if (!canStartEditing) {
          return;
        }
        if (isPrintableKey(event)) {
          reason = GridRowEditStartReasons.printableKeyDown;
        } else if ((event.ctrlKey || event.metaKey) && event.key === "v") {
          reason = GridRowEditStartReasons.printableKeyDown;
        } else if (event.key === "Enter") {
          reason = GridRowEditStartReasons.enterKeyDown;
        } else if (event.key === "Delete" || event.key === "Backspace") {
          reason = GridRowEditStartReasons.deleteKeyDown;
        }
        if (reason) {
          const rowParams = apiRef2.current.getRowParams(params.id);
          const newParams = _extends({}, rowParams, {
            field: params.field,
            key: event.key,
            reason
          });
          apiRef2.current.publishEvent("rowEditStart", newParams, event);
        }
      }
    }, [apiRef2]);
    const handleRowEditStart = React__namespace.useCallback((params) => {
      const {
        id,
        field,
        reason,
        key,
        columns
      } = params;
      const startRowEditModeParams = {
        id,
        fieldToFocus: field
      };
      if (reason === GridRowEditStartReasons.printableKeyDown) {
        if (React__namespace.version.startsWith("17")) {
          startRowEditModeParams.deleteValue = !!field;
        } else {
          const colDef = columns.find((col) => col.field === field);
          startRowEditModeParams.initialValue = colDef.valueParser ? colDef.valueParser(key) : key;
        }
      } else if (reason === GridRowEditStartReasons.deleteKeyDown) {
        startRowEditModeParams.deleteValue = !!field;
      }
      apiRef2.current.startRowEditMode(startRowEditModeParams);
    }, [apiRef2]);
    const handleRowEditStop = React__namespace.useCallback((params) => {
      const {
        id,
        reason,
        field
      } = params;
      apiRef2.current.runPendingEditCellValueMutation(id);
      let cellToFocusAfter;
      if (reason === GridRowEditStopReasons.enterKeyDown) {
        cellToFocusAfter = "below";
      } else if (reason === GridRowEditStopReasons.tabKeyDown) {
        cellToFocusAfter = "right";
      } else if (reason === GridRowEditStopReasons.shiftTabKeyDown) {
        cellToFocusAfter = "left";
      }
      const ignoreModifications = reason === "escapeKeyDown";
      apiRef2.current.stopRowEditMode({
        id,
        ignoreModifications,
        field,
        cellToFocusAfter
      });
    }, [apiRef2]);
    useGridApiEventHandler(apiRef2, "cellDoubleClick", runIfEditModeIsRow(handleCellDoubleClick));
    useGridApiEventHandler(apiRef2, "cellFocusIn", runIfEditModeIsRow(handleCellFocusIn));
    useGridApiEventHandler(apiRef2, "cellFocusOut", runIfEditModeIsRow(handleCellFocusOut));
    useGridApiEventHandler(apiRef2, "cellKeyDown", runIfEditModeIsRow(handleCellKeyDown));
    useGridApiEventHandler(apiRef2, "rowEditStart", runIfEditModeIsRow(handleRowEditStart));
    useGridApiEventHandler(apiRef2, "rowEditStop", runIfEditModeIsRow(handleRowEditStop));
    useGridApiOptionHandler(apiRef2, "rowEditStart", props.onRowEditStart);
    useGridApiOptionHandler(apiRef2, "rowEditStop", props.onRowEditStop);
    const getRowMode = React__namespace.useCallback((id) => {
      if (props.editMode === GridEditModes.Cell) {
        return GridRowModes.View;
      }
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      const isEditing = editingState[id] && Object.keys(editingState[id]).length > 0;
      return isEditing ? GridRowModes.Edit : GridRowModes.View;
    }, [apiRef2, props.editMode]);
    const updateRowModesModel = useEventCallback((newModel) => {
      const isNewModelDifferentFromProp = newModel !== props.rowModesModel;
      if (onRowModesModelChange && isNewModelDifferentFromProp) {
        onRowModesModelChange(newModel, {});
      }
      if (props.rowModesModel && isNewModelDifferentFromProp) {
        return;
      }
      setRowModesModel(newModel);
      rowModesModelRef.current = newModel;
      apiRef2.current.publishEvent("rowModesModelChange", newModel);
    });
    const updateRowInRowModesModel = React__namespace.useCallback((id, newProps) => {
      const newModel = _extends({}, rowModesModelRef.current);
      if (newProps !== null) {
        newModel[id] = _extends({}, newProps);
      } else {
        delete newModel[id];
      }
      updateRowModesModel(newModel);
    }, [updateRowModesModel]);
    const updateOrDeleteRowState = React__namespace.useCallback((id, newProps) => {
      apiRef2.current.setState((state) => {
        const newEditingState = _extends({}, state.editRows);
        if (newProps !== null) {
          newEditingState[id] = newProps;
        } else {
          delete newEditingState[id];
        }
        return _extends({}, state, {
          editRows: newEditingState
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2]);
    const updateOrDeleteFieldState = React__namespace.useCallback((id, field, newProps) => {
      apiRef2.current.setState((state) => {
        const newEditingState = _extends({}, state.editRows);
        if (newProps !== null) {
          newEditingState[id] = _extends({}, newEditingState[id], {
            [field]: _extends({}, newProps)
          });
        } else {
          delete newEditingState[id][field];
          if (Object.keys(newEditingState[id]).length === 0) {
            delete newEditingState[id];
          }
        }
        return _extends({}, state, {
          editRows: newEditingState
        });
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2]);
    const startRowEditMode = React__namespace.useCallback((params) => {
      const {
        id
      } = params, other = _objectWithoutPropertiesLoose(params, _excluded$e);
      throwIfNotInMode(id, GridRowModes.View);
      updateRowInRowModesModel(id, _extends({
        mode: GridRowModes.Edit
      }, other));
    }, [throwIfNotInMode, updateRowInRowModesModel]);
    const updateStateToStartRowEditMode = useEventCallback((params) => {
      const {
        id,
        fieldToFocus,
        deleteValue,
        initialValue
      } = params;
      const columnFields = gridColumnFieldsSelector(apiRef2);
      const newProps = columnFields.reduce((acc, field) => {
        const cellParams = apiRef2.current.getCellParams(id, field);
        if (!cellParams.isEditable) {
          return acc;
        }
        let newValue = apiRef2.current.getCellValue(id, field);
        let unstable_updateValueOnRender = false;
        if (fieldToFocus === field && (deleteValue || initialValue)) {
          newValue = deleteValue ? "" : initialValue;
          unstable_updateValueOnRender = true;
        }
        acc[field] = {
          value: newValue,
          error: false,
          isProcessingProps: false,
          unstable_updateValueOnRender
        };
        return acc;
      }, {});
      updateOrDeleteRowState(id, newProps);
      if (fieldToFocus) {
        apiRef2.current.setCellFocus(id, fieldToFocus);
      }
    });
    const stopRowEditMode = React__namespace.useCallback((params) => {
      const {
        id
      } = params, other = _objectWithoutPropertiesLoose(params, _excluded2$1);
      throwIfNotInMode(id, GridRowModes.Edit);
      updateRowInRowModesModel(id, _extends({
        mode: GridRowModes.View
      }, other));
    }, [throwIfNotInMode, updateRowInRowModesModel]);
    const updateStateToStopRowEditMode = useEventCallback((params) => {
      const {
        id,
        ignoreModifications,
        field: focusedField,
        cellToFocusAfter = "none"
      } = params;
      apiRef2.current.runPendingEditCellValueMutation(id);
      const finishRowEditMode = () => {
        if (cellToFocusAfter !== "none" && focusedField) {
          apiRef2.current.moveFocusToRelativeCell(id, focusedField, cellToFocusAfter);
        }
        updateOrDeleteRowState(id, null);
        updateRowInRowModesModel(id, null);
      };
      if (ignoreModifications) {
        finishRowEditMode();
        return;
      }
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      const row = apiRef2.current.getRow(id);
      const isSomeFieldProcessingProps = Object.values(editingState[id]).some((fieldProps) => fieldProps.isProcessingProps);
      if (isSomeFieldProcessingProps) {
        prevRowModesModel.current[id].mode = GridRowModes.Edit;
        return;
      }
      const hasSomeFieldWithError = Object.values(editingState[id]).some((fieldProps) => fieldProps.error);
      if (hasSomeFieldWithError) {
        prevRowModesModel.current[id].mode = GridRowModes.Edit;
        updateRowInRowModesModel(id, {
          mode: GridRowModes.Edit
        });
        return;
      }
      const rowUpdate = apiRef2.current.getRowWithUpdatedValuesFromRowEditing(id);
      if (processRowUpdate) {
        const handleError = (errorThrown) => {
          prevRowModesModel.current[id].mode = GridRowModes.Edit;
          updateRowInRowModesModel(id, {
            mode: GridRowModes.Edit
          });
          if (onProcessRowUpdateError) {
            onProcessRowUpdateError(errorThrown);
          } else {
            missingOnProcessRowUpdateErrorWarning();
          }
        };
        try {
          Promise.resolve(processRowUpdate(rowUpdate, row)).then((finalRowUpdate) => {
            apiRef2.current.updateRows([finalRowUpdate]);
            finishRowEditMode();
          }).catch(handleError);
        } catch (errorThrown) {
          handleError(errorThrown);
        }
      } else {
        apiRef2.current.updateRows([rowUpdate]);
        finishRowEditMode();
      }
    });
    const setRowEditingEditCellValue = React__namespace.useCallback((params) => {
      const {
        id,
        field,
        value,
        debounceMs,
        unstable_skipValueParser: skipValueParser
      } = params;
      throwIfNotEditable(id, field);
      const column2 = apiRef2.current.getColumn(field);
      const row = apiRef2.current.getRow(id);
      let parsedValue = value;
      if (column2.valueParser && !skipValueParser) {
        parsedValue = column2.valueParser(value, apiRef2.current.getCellParams(id, field));
      }
      let editingState = gridEditRowsStateSelector(apiRef2.current.state);
      let newProps = _extends({}, editingState[id][field], {
        value: parsedValue,
        changeReason: debounceMs ? "debouncedSetEditCellValue" : "setEditCellValue"
      });
      if (!column2.preProcessEditCellProps) {
        updateOrDeleteFieldState(id, field, newProps);
      }
      return new Promise((resolve) => {
        const promises = [];
        if (column2.preProcessEditCellProps) {
          const hasChanged = newProps.value !== editingState[id][field].value;
          newProps = _extends({}, newProps, {
            isProcessingProps: true
          });
          updateOrDeleteFieldState(id, field, newProps);
          const _editingState$id = editingState[id], otherFieldsProps = _objectWithoutPropertiesLoose(_editingState$id, [field].map(_toPropertyKey));
          const promise = Promise.resolve(column2.preProcessEditCellProps({
            id,
            row,
            props: newProps,
            hasChanged,
            otherFieldsProps
          })).then((processedProps) => {
            if (apiRef2.current.getRowMode(id) === GridRowModes.View) {
              resolve(false);
              return;
            }
            editingState = gridEditRowsStateSelector(apiRef2.current.state);
            processedProps = _extends({}, processedProps, {
              isProcessingProps: false
            });
            processedProps.value = column2.preProcessEditCellProps ? editingState[id][field].value : parsedValue;
            updateOrDeleteFieldState(id, field, processedProps);
          });
          promises.push(promise);
        }
        Object.entries(editingState[id]).forEach(([thisField, fieldProps]) => {
          if (thisField === field) {
            return;
          }
          const fieldColumn = apiRef2.current.getColumn(thisField);
          if (!fieldColumn.preProcessEditCellProps) {
            return;
          }
          fieldProps = _extends({}, fieldProps, {
            isProcessingProps: true
          });
          updateOrDeleteFieldState(id, thisField, fieldProps);
          editingState = gridEditRowsStateSelector(apiRef2.current.state);
          const _editingState$id2 = editingState[id], otherFieldsProps = _objectWithoutPropertiesLoose(_editingState$id2, [thisField].map(_toPropertyKey));
          const promise = Promise.resolve(fieldColumn.preProcessEditCellProps({
            id,
            row,
            props: fieldProps,
            hasChanged: false,
            otherFieldsProps
          })).then((processedProps) => {
            if (apiRef2.current.getRowMode(id) === GridRowModes.View) {
              resolve(false);
              return;
            }
            processedProps = _extends({}, processedProps, {
              isProcessingProps: false
            });
            updateOrDeleteFieldState(id, thisField, processedProps);
          });
          promises.push(promise);
        });
        Promise.all(promises).then(() => {
          if (apiRef2.current.getRowMode(id) === GridRowModes.Edit) {
            editingState = gridEditRowsStateSelector(apiRef2.current.state);
            resolve(!editingState[id][field].error);
          } else {
            resolve(false);
          }
        });
      });
    }, [apiRef2, throwIfNotEditable, updateOrDeleteFieldState]);
    const getRowWithUpdatedValuesFromRowEditing = React__namespace.useCallback((id) => {
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      const row = apiRef2.current.getRow(id);
      if (!editingState[id]) {
        return apiRef2.current.getRow(id);
      }
      let rowUpdate = _extends({}, row);
      Object.entries(editingState[id]).forEach(([field, fieldProps]) => {
        const column2 = apiRef2.current.getColumn(field);
        if (column2.valueSetter) {
          rowUpdate = column2.valueSetter({
            value: fieldProps.value,
            row: rowUpdate
          });
        } else {
          rowUpdate[field] = fieldProps.value;
        }
      });
      return rowUpdate;
    }, [apiRef2]);
    const editingApi = {
      getRowMode,
      startRowEditMode,
      stopRowEditMode
    };
    const editingPrivateApi = {
      setRowEditingEditCellValue,
      getRowWithUpdatedValuesFromRowEditing
    };
    useGridApiMethod(apiRef2, editingApi, "public");
    useGridApiMethod(apiRef2, editingPrivateApi, "private");
    React__namespace.useEffect(() => {
      if (rowModesModelProp) {
        updateRowModesModel(rowModesModelProp);
      }
    }, [rowModesModelProp, updateRowModesModel]);
    React__namespace.useEffect(() => {
      const idToIdLookup = gridRowsDataRowIdToIdLookupSelector(apiRef2);
      const copyOfPrevRowModesModel = prevRowModesModel.current;
      prevRowModesModel.current = deepClone(rowModesModel);
      Object.entries(rowModesModel).forEach(([id, params]) => {
        var _copyOfPrevRowModesMo, _idToIdLookup$id;
        const prevMode = ((_copyOfPrevRowModesMo = copyOfPrevRowModesModel[id]) == null ? void 0 : _copyOfPrevRowModesMo.mode) || GridRowModes.View;
        const originalId = (_idToIdLookup$id = idToIdLookup[id]) != null ? _idToIdLookup$id : id;
        if (params.mode === GridRowModes.Edit && prevMode === GridRowModes.View) {
          updateStateToStartRowEditMode(_extends({
            id: originalId
          }, params));
        } else if (params.mode === GridRowModes.View && prevMode === GridRowModes.Edit) {
          updateStateToStopRowEditMode(_extends({
            id: originalId
          }, params));
        }
      });
    }, [apiRef2, rowModesModel, updateStateToStartRowEditMode, updateStateToStopRowEditMode]);
  };
  const editingStateInitializer = (state) => _extends({}, state, {
    editRows: {}
  });
  const useGridEditing = (apiRef2, props) => {
    useGridCellEditing(apiRef2, props);
    useGridRowEditing(apiRef2, props);
    const debounceMap = React__namespace.useRef({});
    const {
      isCellEditable: isCellEditableProp
    } = props;
    const isCellEditable = React__namespace.useCallback((params) => {
      if (isAutoGeneratedRow(params.rowNode)) {
        return false;
      }
      if (!params.colDef.editable) {
        return false;
      }
      if (!params.colDef.renderEditCell) {
        return false;
      }
      if (isCellEditableProp) {
        return isCellEditableProp(params);
      }
      return true;
    }, [isCellEditableProp]);
    const maybeDebounce = (id, field, debounceMs, callback) => {
      if (!debounceMs) {
        callback();
        return;
      }
      if (!debounceMap.current[id]) {
        debounceMap.current[id] = {};
      }
      if (debounceMap.current[id][field]) {
        const [timeout2] = debounceMap.current[id][field];
        clearTimeout(timeout2);
      }
      const runImmediately = () => {
        const [timeout2] = debounceMap.current[id][field];
        clearTimeout(timeout2);
        callback();
        delete debounceMap.current[id][field];
      };
      const timeout = setTimeout(() => {
        callback();
        delete debounceMap.current[id][field];
      }, debounceMs);
      debounceMap.current[id][field] = [timeout, runImmediately];
    };
    React__namespace.useEffect(() => {
      const debounces = debounceMap.current;
      return () => {
        Object.entries(debounces).forEach(([id, fields]) => {
          Object.keys(fields).forEach((field) => {
            const [timeout] = debounces[id][field];
            clearTimeout(timeout);
            delete debounces[id][field];
          });
        });
      };
    }, []);
    const runPendingEditCellValueMutation = React__namespace.useCallback((id, field) => {
      if (!debounceMap.current[id]) {
        return;
      }
      if (!field) {
        Object.keys(debounceMap.current[id]).forEach((debouncedField) => {
          const [, runCallback] = debounceMap.current[id][debouncedField];
          runCallback();
        });
      } else if (debounceMap.current[id][field]) {
        const [, runCallback] = debounceMap.current[id][field];
        runCallback();
      }
    }, []);
    const setEditCellValue = React__namespace.useCallback((params) => {
      const {
        id,
        field,
        debounceMs
      } = params;
      return new Promise((resolve) => {
        maybeDebounce(id, field, debounceMs, async () => {
          const setEditCellValueToCall = props.editMode === GridEditModes.Row ? apiRef2.current.setRowEditingEditCellValue : apiRef2.current.setCellEditingEditCellValue;
          if (apiRef2.current.getCellMode(id, field) === GridCellModes.Edit) {
            const result = await setEditCellValueToCall(params);
            resolve(result);
          }
        });
      });
    }, [apiRef2, props.editMode]);
    const getRowWithUpdatedValues = React__namespace.useCallback((id, field) => {
      return props.editMode === GridEditModes.Cell ? apiRef2.current.getRowWithUpdatedValuesFromCellEditing(id, field) : apiRef2.current.getRowWithUpdatedValuesFromRowEditing(id);
    }, [apiRef2, props.editMode]);
    const getEditCellMeta = React__namespace.useCallback((id, field) => {
      var _editingState$id$fiel, _editingState$id;
      const editingState = gridEditRowsStateSelector(apiRef2.current.state);
      return (_editingState$id$fiel = (_editingState$id = editingState[id]) == null ? void 0 : _editingState$id[field]) != null ? _editingState$id$fiel : null;
    }, [apiRef2]);
    const editingSharedApi = {
      isCellEditable,
      setEditCellValue,
      getRowWithUpdatedValues,
      unstable_getEditCellMeta: getEditCellMeta
    };
    const editingSharedPrivateApi = {
      runPendingEditCellValueMutation
    };
    useGridApiMethod(apiRef2, editingSharedApi, "public");
    useGridApiMethod(apiRef2, editingSharedPrivateApi, "private");
  };
  const rowsStateInitializer = (state, props, apiRef2) => {
    apiRef2.current.caches.rows = createRowsInternalCache({
      rows: props.rows,
      getRowId: props.getRowId,
      loading: props.loading,
      rowCount: props.rowCount
    });
    return _extends({}, state, {
      rows: getRowsStateFromCache({
        apiRef: apiRef2,
        rowCountProp: props.rowCount,
        loadingProp: props.loading,
        previousTree: null,
        previousTreeDepths: null
      })
    });
  };
  const useGridRows = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useGridRows");
    const currentPage = useGridVisibleRows(apiRef2, props);
    const lastUpdateMs = React__namespace.useRef(Date.now());
    const timeout = React__namespace.useRef(null);
    const getRow = React__namespace.useCallback((id) => {
      const model = gridRowsLookupSelector(apiRef2)[id];
      if (model) {
        return model;
      }
      const node2 = apiRef2.current.getRowNode(id);
      if (node2 && isAutoGeneratedRow(node2)) {
        return {
          [GRID_ID_AUTOGENERATED]: id
        };
      }
      return null;
    }, [apiRef2]);
    const getRowIdProp = props.getRowId;
    const getRowId2 = React__namespace.useCallback((row) => {
      if (GRID_ID_AUTOGENERATED in row) {
        return row[GRID_ID_AUTOGENERATED];
      }
      if (getRowIdProp) {
        return getRowIdProp(row);
      }
      return row.id;
    }, [getRowIdProp]);
    const lookup = React__namespace.useMemo(() => currentPage.rows.reduce((acc, {
      id
    }, index) => {
      acc[id] = index;
      return acc;
    }, {}), [currentPage.rows]);
    const throttledRowsChange = React__namespace.useCallback(({
      cache,
      throttle
    }) => {
      const run = () => {
        timeout.current = null;
        lastUpdateMs.current = Date.now();
        apiRef2.current.setState((state) => _extends({}, state, {
          rows: getRowsStateFromCache({
            apiRef: apiRef2,
            rowCountProp: props.rowCount,
            loadingProp: props.loading,
            previousTree: gridRowTreeSelector(apiRef2),
            previousTreeDepths: gridRowTreeDepthsSelector(apiRef2)
          })
        }));
        apiRef2.current.publishEvent("rowsSet");
        apiRef2.current.forceUpdate();
      };
      if (timeout.current) {
        clearTimeout(timeout.current);
        timeout.current = null;
      }
      apiRef2.current.caches.rows = cache;
      if (!throttle) {
        run();
        return;
      }
      const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);
      if (throttleRemainingTimeMs > 0) {
        timeout.current = setTimeout(run, throttleRemainingTimeMs);
        return;
      }
      run();
    }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef2]);
    const setRows = React__namespace.useCallback((rows) => {
      logger.debug(`Updating all rows, new length ${rows.length}`);
      const cache = createRowsInternalCache({
        rows,
        getRowId: props.getRowId,
        loading: props.loading,
        rowCount: props.rowCount
      });
      const prevCache = apiRef2.current.caches.rows;
      cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;
      throttledRowsChange({
        cache,
        throttle: true
      });
    }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef2]);
    const updateRows = React__namespace.useCallback((updates) => {
      if (props.signature === GridSignature.DataGrid && updates.length > 1) {
        throw new Error(["MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
      }
      const nonPinnedRowsUpdates = [];
      updates.forEach((update) => {
        const id = getRowIdFromRowModel(update, props.getRowId, "A row was provided without id when calling updateRows():");
        const rowNode = apiRef2.current.getRowNode(id);
        if ((rowNode == null ? void 0 : rowNode.type) === "pinnedRow") {
          const pinnedRowsCache = apiRef2.current.caches.pinnedRows;
          const prevModel = pinnedRowsCache.idLookup[id];
          if (prevModel) {
            pinnedRowsCache.idLookup[id] = _extends({}, prevModel, update);
          }
        } else {
          nonPinnedRowsUpdates.push(update);
        }
      });
      const cache = updateCacheWithNewRows({
        updates: nonPinnedRowsUpdates,
        getRowId: props.getRowId,
        previousCache: apiRef2.current.caches.rows
      });
      throttledRowsChange({
        cache,
        throttle: true
      });
    }, [props.signature, props.getRowId, throttledRowsChange, apiRef2]);
    const getRowModels = React__namespace.useCallback(() => {
      const dataRows = gridDataRowIdsSelector(apiRef2);
      const idRowsLookup = gridRowsLookupSelector(apiRef2);
      return new Map(dataRows.map((id) => {
        var _idRowsLookup$id;
        return [id, (_idRowsLookup$id = idRowsLookup[id]) != null ? _idRowsLookup$id : {}];
      }));
    }, [apiRef2]);
    const getRowsCount = React__namespace.useCallback(() => gridRowCountSelector(apiRef2), [apiRef2]);
    const getAllRowIds = React__namespace.useCallback(() => gridDataRowIdsSelector(apiRef2), [apiRef2]);
    const getRowIndexRelativeToVisibleRows = React__namespace.useCallback((id) => lookup[id], [lookup]);
    const setRowChildrenExpansion = React__namespace.useCallback((id, isExpanded) => {
      const currentNode = apiRef2.current.getRowNode(id);
      if (!currentNode) {
        throw new Error(`MUI: No row with id #${id} found`);
      }
      if (currentNode.type !== "group") {
        throw new Error("MUI: Only group nodes can be expanded or collapsed");
      }
      const newNode = _extends({}, currentNode, {
        childrenExpanded: isExpanded
      });
      apiRef2.current.setState((state) => {
        return _extends({}, state, {
          rows: _extends({}, state.rows, {
            tree: _extends({}, state.rows.tree, {
              [id]: newNode
            })
          })
        });
      });
      apiRef2.current.forceUpdate();
      apiRef2.current.publishEvent("rowExpansionChange", newNode);
    }, [apiRef2]);
    const getRowNode = React__namespace.useCallback((id) => {
      var _ref;
      return (_ref = gridRowTreeSelector(apiRef2)[id]) != null ? _ref : null;
    }, [apiRef2]);
    const getRowGroupChildren = React__namespace.useCallback(({
      skipAutoGeneratedRows = true,
      groupId,
      applySorting,
      applyFiltering
    }) => {
      const tree = gridRowTreeSelector(apiRef2);
      let children;
      if (applySorting) {
        const groupNode = tree[groupId];
        if (!groupNode) {
          return [];
        }
        const sortedRowIds = gridSortedRowIdsSelector(apiRef2);
        children = [];
        const startIndex = sortedRowIds.findIndex((id) => id === groupId) + 1;
        for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {
          const id = sortedRowIds[index];
          if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {
            children.push(id);
          }
        }
      } else {
        children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);
      }
      if (applyFiltering) {
        const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef2);
        children = children.filter((childId) => filteredRowsLookup[childId] !== false);
      }
      return children;
    }, [apiRef2]);
    const setRowIndex = React__namespace.useCallback((rowId, targetIndex) => {
      const node2 = apiRef2.current.getRowNode(rowId);
      if (!node2) {
        throw new Error(`MUI: No row with id #${rowId} found`);
      }
      if (node2.parent !== GRID_ROOT_GROUP_ID) {
        throw new Error(`MUI: The row reordering do not support reordering of grouped rows yet`);
      }
      if (node2.type !== "leaf") {
        throw new Error(`MUI: The row reordering do not support reordering of footer or grouping rows`);
      }
      apiRef2.current.setState((state) => {
        const group = gridRowTreeSelector(state, apiRef2.current.instanceId)[GRID_ROOT_GROUP_ID];
        const allRows = group.children;
        const oldIndex = allRows.findIndex((row) => row === rowId);
        if (oldIndex === -1 || oldIndex === targetIndex) {
          return state;
        }
        logger.debug(`Moving row ${rowId} to index ${targetIndex}`);
        const updatedRows = [...allRows];
        updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);
        return _extends({}, state, {
          rows: _extends({}, state.rows, {
            tree: _extends({}, state.rows.tree, {
              [GRID_ROOT_GROUP_ID]: _extends({}, group, {
                children: updatedRows
              })
            })
          })
        });
      });
      apiRef2.current.publishEvent("rowsSet");
    }, [apiRef2, logger]);
    const replaceRows = React__namespace.useCallback((firstRowToRender, newRows) => {
      if (props.signature === GridSignature.DataGrid && newRows.length > 1) {
        throw new Error(["MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
      }
      if (newRows.length === 0) {
        return;
      }
      const treeDepth = gridRowMaximumTreeDepthSelector(apiRef2);
      if (treeDepth > 1) {
        throw new Error("`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping");
      }
      const tree = _extends({}, gridRowTreeSelector(apiRef2));
      const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef2));
      const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef2));
      const rootGroup = tree[GRID_ROOT_GROUP_ID];
      const rootGroupChildren = [...rootGroup.children];
      for (let i = 0; i < newRows.length; i += 1) {
        const rowModel = newRows[i];
        const rowId = getRowIdFromRowModel(rowModel, props.getRowId, "A row was provided without id when calling replaceRows().");
        const [replacedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);
        delete dataRowIdToModelLookup[replacedRowId];
        delete dataRowIdToIdLookup[replacedRowId];
        delete tree[replacedRowId];
        const rowTreeNodeConfig = {
          id: rowId,
          depth: 0,
          parent: GRID_ROOT_GROUP_ID,
          type: "leaf",
          groupingKey: null
        };
        dataRowIdToModelLookup[rowId] = rowModel;
        dataRowIdToIdLookup[rowId] = rowId;
        tree[rowId] = rowTreeNodeConfig;
      }
      tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {
        children: rootGroupChildren
      });
      const dataRowIds = rootGroupChildren.filter((childId) => tree[childId].type === "leaf");
      apiRef2.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;
      apiRef2.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;
      apiRef2.current.setState((state) => _extends({}, state, {
        rows: _extends({}, state.rows, {
          dataRowIdToModelLookup,
          dataRowIdToIdLookup,
          dataRowIds,
          tree
        })
      }));
      apiRef2.current.publishEvent("rowsSet");
    }, [apiRef2, props.signature, props.getRowId]);
    const rowApi = {
      getRow,
      getRowId: getRowId2,
      getRowModels,
      getRowsCount,
      getAllRowIds,
      setRows,
      updateRows,
      getRowNode,
      getRowIndexRelativeToVisibleRows,
      unstable_replaceRows: replaceRows
    };
    const rowProApi = {
      setRowIndex,
      setRowChildrenExpansion,
      getRowGroupChildren
    };
    const groupRows = React__namespace.useCallback(() => {
      logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);
      let cache;
      if (apiRef2.current.caches.rows.rowsBeforePartialUpdates === props.rows) {
        cache = _extends({}, apiRef2.current.caches.rows, {
          updates: {
            type: "full",
            rows: gridDataRowIdsSelector(apiRef2)
          }
        });
      } else {
        cache = createRowsInternalCache({
          rows: props.rows,
          getRowId: props.getRowId,
          loading: props.loading,
          rowCount: props.rowCount
        });
      }
      throttledRowsChange({
        cache,
        throttle: false
      });
    }, [logger, apiRef2, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);
    const handleStrategyProcessorChange = React__namespace.useCallback((methodName) => {
      if (methodName === "rowTreeCreation") {
        groupRows();
      }
    }, [groupRows]);
    const handleStrategyActivityChange = React__namespace.useCallback(() => {
      if (apiRef2.current.getActiveStrategy("rowTree") !== gridRowGroupingNameSelector(apiRef2)) {
        groupRows();
      }
    }, [apiRef2, groupRows]);
    useGridApiEventHandler(apiRef2, "activeStrategyProcessorChange", handleStrategyProcessorChange);
    useGridApiEventHandler(apiRef2, "strategyAvailabilityChange", handleStrategyActivityChange);
    const applyHydrateRowsProcessor = React__namespace.useCallback(() => {
      apiRef2.current.setState((state) => {
        const response = apiRef2.current.unstable_applyPipeProcessors("hydrateRows", {
          tree: gridRowTreeSelector(state, apiRef2.current.instanceId),
          treeDepths: gridRowTreeDepthsSelector(state, apiRef2.current.instanceId),
          dataRowIds: gridDataRowIdsSelector(state, apiRef2.current.instanceId),
          dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef2.current.instanceId),
          dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef2.current.instanceId)
        });
        return _extends({}, state, {
          rows: _extends({}, state.rows, response, {
            totalTopLevelRowCount: getTopLevelRowCount({
              tree: response.tree,
              rowCountProp: props.rowCount
            })
          })
        });
      });
      apiRef2.current.publishEvent("rowsSet");
      apiRef2.current.forceUpdate();
    }, [apiRef2, props.rowCount]);
    useGridRegisterPipeApplier(apiRef2, "hydrateRows", applyHydrateRowsProcessor);
    useGridApiMethod(apiRef2, rowApi, "public");
    useGridApiMethod(apiRef2, rowProApi, props.signature === GridSignature.DataGrid ? "private" : "public");
    React__namespace.useEffect(() => {
      return () => {
        if (timeout.current !== null) {
          clearTimeout(timeout.current);
        }
      };
    }, []);
    const isFirstRender = React__namespace.useRef(true);
    React__namespace.useEffect(() => {
      if (isFirstRender.current) {
        isFirstRender.current = false;
        return;
      }
      const areNewRowsAlreadyInState = apiRef2.current.caches.rows.rowsBeforePartialUpdates === props.rows;
      const isNewLoadingAlreadyInState = apiRef2.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;
      const isNewRowCountAlreadyInState = apiRef2.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;
      if (areNewRowsAlreadyInState) {
        if (!isNewLoadingAlreadyInState) {
          apiRef2.current.setState((state) => _extends({}, state, {
            rows: _extends({}, state.rows, {
              loading: props.loading
            })
          }));
          apiRef2.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;
          apiRef2.current.forceUpdate();
        }
        if (!isNewRowCountAlreadyInState) {
          apiRef2.current.setState((state) => _extends({}, state, {
            rows: _extends({}, state.rows, {
              totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),
              totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)
            })
          }));
          apiRef2.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;
          apiRef2.current.forceUpdate();
        }
        return;
      }
      logger.debug(`Updating all rows, new length ${props.rows.length}`);
      throttledRowsChange({
        cache: createRowsInternalCache({
          rows: props.rows,
          getRowId: props.getRowId,
          loading: props.loading,
          rowCount: props.rowCount
        }),
        throttle: false
      });
    }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef2]);
  };
  const createFlatRowTree = (rows) => {
    const tree = {
      [GRID_ROOT_GROUP_ID]: _extends({}, buildRootGroup(), {
        children: rows
      })
    };
    for (let i = 0; i < rows.length; i += 1) {
      const rowId = rows[i];
      tree[rowId] = {
        id: rowId,
        depth: 0,
        parent: GRID_ROOT_GROUP_ID,
        type: "leaf",
        groupingKey: null
      };
    }
    return {
      groupingName: GRID_DEFAULT_STRATEGY,
      tree,
      treeDepths: {
        0: rows.length
      },
      dataRowIds: rows
    };
  };
  const updateFlatRowTree = ({
    previousTree,
    actions
  }) => {
    const tree = _extends({}, previousTree);
    const idsToRemoveFromRootGroup = {};
    for (let i = 0; i < actions.remove.length; i += 1) {
      const idToDelete = actions.remove[i];
      idsToRemoveFromRootGroup[idToDelete] = true;
      delete tree[idToDelete];
    }
    for (let i = 0; i < actions.insert.length; i += 1) {
      const idToInsert = actions.insert[i];
      tree[idToInsert] = {
        id: idToInsert,
        depth: 0,
        parent: GRID_ROOT_GROUP_ID,
        type: "leaf",
        groupingKey: null
      };
    }
    const rootGroup = tree[GRID_ROOT_GROUP_ID];
    let rootGroupChildren = [...rootGroup.children, ...actions.insert];
    if (Object.values(idsToRemoveFromRootGroup).length) {
      rootGroupChildren = rootGroupChildren.filter((id) => !idsToRemoveFromRootGroup[id]);
    }
    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {
      children: rootGroupChildren
    });
    return {
      groupingName: GRID_DEFAULT_STRATEGY,
      tree,
      treeDepths: {
        0: rootGroupChildren.length
      },
      dataRowIds: rootGroupChildren
    };
  };
  const flatRowTreeCreationMethod = (params) => {
    if (params.updates.type === "full") {
      return createFlatRowTree(params.updates.rows);
    }
    return updateFlatRowTree({
      previousTree: params.previousTree,
      actions: params.updates.actions
    });
  };
  const useGridRowsPreProcessors = (apiRef2) => {
    useGridRegisterStrategyProcessor(apiRef2, GRID_DEFAULT_STRATEGY, "rowTreeCreation", flatRowTreeCreationMethod);
  };
  const getSelectionModelPropValue = (selectionModelProp, prevSelectionModel) => {
    if (selectionModelProp == null) {
      return selectionModelProp;
    }
    if (Array.isArray(selectionModelProp)) {
      return selectionModelProp;
    }
    if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {
      return prevSelectionModel;
    }
    return [selectionModelProp];
  };
  const rowSelectionStateInitializer = (state, props) => {
    var _getSelectionModelPro;
    return _extends({}, state, {
      rowSelection: props.rowSelection ? (_getSelectionModelPro = getSelectionModelPropValue(props.rowSelectionModel)) != null ? _getSelectionModelPro : [] : []
    });
  };
  const useGridRowSelection = (apiRef2, props) => {
    const logger = useGridLogger(apiRef2, "useGridSelection");
    const runIfRowSelectionIsEnabled = (callback) => (...args) => {
      if (props.rowSelection) {
        callback(...args);
      }
    };
    const propRowSelectionModel = React__namespace.useMemo(() => {
      return getSelectionModelPropValue(props.rowSelectionModel, gridRowSelectionStateSelector(apiRef2.current.state));
    }, [apiRef2, props.rowSelectionModel]);
    const lastRowToggled = React__namespace.useRef(null);
    apiRef2.current.registerControlState({
      stateId: "rowSelection",
      propModel: propRowSelectionModel,
      propOnChange: props.onRowSelectionModelChange,
      stateSelector: gridRowSelectionStateSelector,
      changeEvent: "rowSelectionChange"
    });
    const {
      checkboxSelection,
      disableMultipleRowSelection,
      disableRowSelectionOnClick,
      isRowSelectable: propIsRowSelectable
    } = props;
    const canHaveMultipleSelection = !disableMultipleRowSelection || checkboxSelection;
    const visibleRows = useGridVisibleRows(apiRef2, props);
    const expandMouseRowRangeSelection = React__namespace.useCallback((id) => {
      var _lastRowToggled$curre;
      let endId = id;
      const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;
      const isSelected = apiRef2.current.isRowSelected(id);
      if (isSelected) {
        const visibleRowIds = gridExpandedSortedRowIdsSelector(apiRef2);
        const startIndex = visibleRowIds.findIndex((rowId) => rowId === startId);
        const endIndex = visibleRowIds.findIndex((rowId) => rowId === endId);
        if (startIndex === endIndex) {
          return;
        }
        if (startIndex > endIndex) {
          endId = visibleRowIds[endIndex + 1];
        } else {
          endId = visibleRowIds[endIndex - 1];
        }
      }
      lastRowToggled.current = id;
      apiRef2.current.selectRowRange({
        startId,
        endId
      }, !isSelected);
    }, [apiRef2]);
    const setRowSelectionModel = React__namespace.useCallback((model) => {
      if (props.signature === GridSignature.DataGrid && !props.checkboxSelection && Array.isArray(model) && model.length > 1) {
        throw new Error(["MUI: `rowSelectionModel` can only contain 1 item in DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock multiple selection."].join("\n"));
      }
      const currentModel = gridRowSelectionStateSelector(apiRef2.current.state);
      if (currentModel !== model) {
        logger.debug(`Setting selection model`);
        apiRef2.current.setState((state) => _extends({}, state, {
          rowSelection: props.rowSelection ? model : []
        }));
        apiRef2.current.forceUpdate();
      }
    }, [apiRef2, logger, props.rowSelection, props.signature, props.checkboxSelection]);
    const isRowSelected = React__namespace.useCallback((id) => gridRowSelectionStateSelector(apiRef2.current.state).includes(id), [apiRef2]);
    const isRowSelectable = React__namespace.useCallback((id) => {
      if (propIsRowSelectable && !propIsRowSelectable(apiRef2.current.getRowParams(id))) {
        return false;
      }
      const rowNode = apiRef2.current.getRowNode(id);
      if ((rowNode == null ? void 0 : rowNode.type) === "footer" || (rowNode == null ? void 0 : rowNode.type) === "pinnedRow") {
        return false;
      }
      return true;
    }, [apiRef2, propIsRowSelectable]);
    const getSelectedRows = React__namespace.useCallback(() => selectedGridRowsSelector(apiRef2), [apiRef2]);
    const selectRow = React__namespace.useCallback((id, isSelected = true, resetSelection = false) => {
      if (!apiRef2.current.isRowSelectable(id)) {
        return;
      }
      lastRowToggled.current = id;
      if (resetSelection) {
        logger.debug(`Setting selection for row ${id}`);
        apiRef2.current.setRowSelectionModel(isSelected ? [id] : []);
      } else {
        logger.debug(`Toggling selection for row ${id}`);
        const selection = gridRowSelectionStateSelector(apiRef2.current.state);
        const newSelection = selection.filter((el) => el !== id);
        if (isSelected) {
          newSelection.push(id);
        }
        const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;
        if (isSelectionValid) {
          apiRef2.current.setRowSelectionModel(newSelection);
        }
      }
    }, [apiRef2, logger, canHaveMultipleSelection]);
    const selectRows = React__namespace.useCallback((ids, isSelected = true, resetSelection = false) => {
      logger.debug(`Setting selection for several rows`);
      const selectableIds = ids.filter((id) => apiRef2.current.isRowSelectable(id));
      let newSelection;
      if (resetSelection) {
        newSelection = isSelected ? selectableIds : [];
      } else {
        const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef2));
        selectableIds.forEach((id) => {
          if (isSelected) {
            selectionLookup[id] = id;
          } else {
            delete selectionLookup[id];
          }
        });
        newSelection = Object.values(selectionLookup);
      }
      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;
      if (isSelectionValid) {
        apiRef2.current.setRowSelectionModel(newSelection);
      }
    }, [apiRef2, logger, canHaveMultipleSelection]);
    const selectRowRange = React__namespace.useCallback(({
      startId,
      endId
    }, isSelected = true, resetSelection = false) => {
      if (!apiRef2.current.getRow(startId) || !apiRef2.current.getRow(endId)) {
        return;
      }
      logger.debug(`Expanding selection from row ${startId} to row ${endId}`);
      const allPagesRowIds = gridExpandedSortedRowIdsSelector(apiRef2);
      const startIndex = allPagesRowIds.indexOf(startId);
      const endIndex = allPagesRowIds.indexOf(endId);
      const [start2, end2] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];
      const rowsBetweenStartAndEnd = allPagesRowIds.slice(start2, end2 + 1);
      apiRef2.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);
    }, [apiRef2, logger]);
    const selectionPublicApi = {
      selectRow,
      setRowSelectionModel,
      getSelectedRows,
      isRowSelected,
      isRowSelectable
    };
    const selectionPrivateApi = {
      selectRows,
      selectRowRange
    };
    useGridApiMethod(apiRef2, selectionPublicApi, "public");
    useGridApiMethod(apiRef2, selectionPrivateApi, props.signature === GridSignature.DataGrid ? "private" : "public");
    const removeOutdatedSelection = React__namespace.useCallback(() => {
      if (props.keepNonExistentRowsSelected) {
        return;
      }
      const currentSelection = gridRowSelectionStateSelector(apiRef2.current.state);
      const rowsLookup = gridRowsLookupSelector(apiRef2);
      const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef2));
      let hasChanged = false;
      currentSelection.forEach((id) => {
        if (!rowsLookup[id]) {
          delete selectionLookup[id];
          hasChanged = true;
        }
      });
      if (hasChanged) {
        apiRef2.current.setRowSelectionModel(Object.values(selectionLookup));
      }
    }, [apiRef2, props.keepNonExistentRowsSelected]);
    const handleSingleRowSelection = React__namespace.useCallback((id, event) => {
      const hasCtrlKey = event.metaKey || event.ctrlKey;
      const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent$1(event);
      const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;
      const isSelected = apiRef2.current.isRowSelected(id);
      if (resetSelection) {
        apiRef2.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);
      } else {
        apiRef2.current.selectRow(id, !isSelected, false);
      }
    }, [apiRef2, canHaveMultipleSelection, checkboxSelection]);
    const handleRowClick = React__namespace.useCallback((params, event) => {
      var _closest;
      if (disableRowSelectionOnClick) {
        return;
      }
      const field = (_closest = event.target.closest(`.${gridClasses.cell}`)) == null ? void 0 : _closest.getAttribute("data-field");
      if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
        return;
      }
      if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
        return;
      }
      if (field) {
        const column2 = apiRef2.current.getColumn(field);
        if ((column2 == null ? void 0 : column2.type) === GRID_ACTIONS_COLUMN_TYPE) {
          return;
        }
      }
      const rowNode = apiRef2.current.getRowNode(params.id);
      if (rowNode.type === "pinnedRow") {
        return;
      }
      if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {
        expandMouseRowRangeSelection(params.id);
      } else {
        handleSingleRowSelection(params.id, event);
      }
    }, [disableRowSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef2, expandMouseRowRangeSelection, handleSingleRowSelection]);
    const preventSelectionOnShift = React__namespace.useCallback((params, event) => {
      if (canHaveMultipleSelection && event.shiftKey) {
        var _window$getSelection;
        (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();
      }
    }, [canHaveMultipleSelection]);
    const handleRowSelectionCheckboxChange = React__namespace.useCallback((params, event) => {
      if (event.nativeEvent.shiftKey) {
        expandMouseRowRangeSelection(params.id);
      } else {
        apiRef2.current.selectRow(params.id, params.value);
      }
    }, [apiRef2, expandMouseRowRangeSelection]);
    const handleHeaderSelectionCheckboxChange = React__namespace.useCallback((params) => {
      const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;
      const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef2) : gridExpandedSortedRowIdsSelector(apiRef2);
      apiRef2.current.selectRows(rowsToBeSelected, params.value);
    }, [apiRef2, props.checkboxSelectionVisibleOnly, props.pagination]);
    const handleCellKeyDown = React__namespace.useCallback((params, event) => {
      if (apiRef2.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {
        return;
      }
      if (!event.currentTarget.contains(event.target)) {
        return;
      }
      if (isNavigationKey(event.key) && event.shiftKey) {
        const focusCell = gridFocusCellSelector(apiRef2);
        if (focusCell && focusCell.id !== params.id) {
          event.preventDefault();
          const isNextRowSelected = apiRef2.current.isRowSelected(focusCell.id);
          if (!canHaveMultipleSelection) {
            apiRef2.current.selectRow(focusCell.id, !isNextRowSelected, true);
            return;
          }
          const newRowIndex = apiRef2.current.getRowIndexRelativeToVisibleRows(focusCell.id);
          const previousRowIndex = apiRef2.current.getRowIndexRelativeToVisibleRows(params.id);
          let start2;
          let end2;
          if (newRowIndex > previousRowIndex) {
            if (isNextRowSelected) {
              start2 = previousRowIndex;
              end2 = newRowIndex - 1;
            } else {
              start2 = previousRowIndex;
              end2 = newRowIndex;
            }
          } else {
            if (isNextRowSelected) {
              start2 = newRowIndex + 1;
              end2 = previousRowIndex;
            } else {
              start2 = newRowIndex;
              end2 = previousRowIndex;
            }
          }
          const rowsBetweenStartAndEnd = visibleRows.rows.slice(start2, end2 + 1).map((row) => row.id);
          apiRef2.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);
          return;
        }
      }
      if (event.key === " " && event.shiftKey) {
        event.preventDefault();
        handleSingleRowSelection(params.id, event);
        return;
      }
      if (event.key === "a" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        selectRows(apiRef2.current.getAllRowIds(), true);
      }
    }, [apiRef2, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);
    useGridApiEventHandler(apiRef2, "sortedRowsSet", runIfRowSelectionIsEnabled(removeOutdatedSelection));
    useGridApiEventHandler(apiRef2, "rowClick", runIfRowSelectionIsEnabled(handleRowClick));
    useGridApiEventHandler(apiRef2, "rowSelectionCheckboxChange", runIfRowSelectionIsEnabled(handleRowSelectionCheckboxChange));
    useGridApiEventHandler(apiRef2, "headerSelectionCheckboxChange", handleHeaderSelectionCheckboxChange);
    useGridApiEventHandler(apiRef2, "cellMouseDown", runIfRowSelectionIsEnabled(preventSelectionOnShift));
    useGridApiEventHandler(apiRef2, "cellKeyDown", runIfRowSelectionIsEnabled(handleCellKeyDown));
    React__namespace.useEffect(() => {
      if (propRowSelectionModel !== void 0) {
        apiRef2.current.setRowSelectionModel(propRowSelectionModel);
      }
    }, [apiRef2, propRowSelectionModel, props.rowSelection]);
    React__namespace.useEffect(() => {
      if (!props.rowSelection) {
        apiRef2.current.setRowSelectionModel([]);
      }
    }, [apiRef2, props.rowSelection]);
    const isStateControlled = propRowSelectionModel != null;
    React__namespace.useEffect(() => {
      if (isStateControlled || !props.rowSelection) {
        return;
      }
      const currentSelection = gridRowSelectionStateSelector(apiRef2.current.state);
      if (isRowSelectable) {
        const newSelection = currentSelection.filter((id) => isRowSelectable(id));
        if (newSelection.length < currentSelection.length) {
          apiRef2.current.setRowSelectionModel(newSelection);
        }
      }
    }, [apiRef2, isRowSelectable, isStateControlled, props.rowSelection]);
    React__namespace.useEffect(() => {
      if (!props.rowSelection || isStateControlled) {
        return;
      }
      const currentSelection = gridRowSelectionStateSelector(apiRef2.current.state);
      if (!canHaveMultipleSelection && currentSelection.length > 1) {
        apiRef2.current.setRowSelectionModel([]);
      }
    }, [apiRef2, canHaveMultipleSelection, checkboxSelection, isStateControlled, props.rowSelection]);
  };
  const GRID_DEFAULT_LOCALE_TEXT = {
    // Root
    noRowsLabel: "No rows",
    noResultsOverlayLabel: "No results found.",
    // Density selector toolbar button text
    toolbarDensity: "Density",
    toolbarDensityLabel: "Density",
    toolbarDensityCompact: "Compact",
    toolbarDensityStandard: "Standard",
    toolbarDensityComfortable: "Comfortable",
    // Columns selector toolbar button text
    toolbarColumns: "Columns",
    toolbarColumnsLabel: "Select columns",
    // Filters toolbar button text
    toolbarFilters: "Filters",
    toolbarFiltersLabel: "Show filters",
    toolbarFiltersTooltipHide: "Hide filters",
    toolbarFiltersTooltipShow: "Show filters",
    toolbarFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
    // Quick filter toolbar field
    toolbarQuickFilterPlaceholder: "Search…",
    toolbarQuickFilterLabel: "Search",
    toolbarQuickFilterDeleteIconLabel: "Clear",
    // Export selector toolbar button text
    toolbarExport: "Export",
    toolbarExportLabel: "Export",
    toolbarExportCSV: "Download as CSV",
    toolbarExportPrint: "Print",
    toolbarExportExcel: "Download as Excel",
    // Columns panel text
    columnsPanelTextFieldLabel: "Find column",
    columnsPanelTextFieldPlaceholder: "Column title",
    columnsPanelDragIconLabel: "Reorder column",
    columnsPanelShowAllButton: "Show all",
    columnsPanelHideAllButton: "Hide all",
    // Filter panel text
    filterPanelAddFilter: "Add filter",
    filterPanelRemoveAll: "Remove all",
    filterPanelDeleteIconLabel: "Delete",
    filterPanelLogicOperator: "Logic operator",
    filterPanelOperator: "Operator",
    filterPanelOperatorAnd: "And",
    filterPanelOperatorOr: "Or",
    filterPanelColumns: "Columns",
    filterPanelInputLabel: "Value",
    filterPanelInputPlaceholder: "Filter value",
    // Filter operators text
    filterOperatorContains: "contains",
    filterOperatorEquals: "equals",
    filterOperatorStartsWith: "starts with",
    filterOperatorEndsWith: "ends with",
    filterOperatorIs: "is",
    filterOperatorNot: "is not",
    filterOperatorAfter: "is after",
    filterOperatorOnOrAfter: "is on or after",
    filterOperatorBefore: "is before",
    filterOperatorOnOrBefore: "is on or before",
    filterOperatorIsEmpty: "is empty",
    filterOperatorIsNotEmpty: "is not empty",
    filterOperatorIsAnyOf: "is any of",
    "filterOperator=": "=",
    "filterOperator!=": "!=",
    "filterOperator>": ">",
    "filterOperator>=": ">=",
    "filterOperator<": "<",
    "filterOperator<=": "<=",
    // Header filter operators text
    headerFilterOperatorContains: "Contains",
    headerFilterOperatorEquals: "Equals",
    headerFilterOperatorStartsWith: "Starts with",
    headerFilterOperatorEndsWith: "Ends with",
    headerFilterOperatorIs: "Is",
    headerFilterOperatorNot: "Is not",
    headerFilterOperatorAfter: "Is after",
    headerFilterOperatorOnOrAfter: "Is on or after",
    headerFilterOperatorBefore: "Is before",
    headerFilterOperatorOnOrBefore: "Is on or before",
    headerFilterOperatorIsEmpty: "Is empty",
    headerFilterOperatorIsNotEmpty: "Is not empty",
    headerFilterOperatorIsAnyOf: "Is any of",
    "headerFilterOperator=": "Equals",
    "headerFilterOperator!=": "Not equals",
    "headerFilterOperator>": "Greater than",
    "headerFilterOperator>=": "Greater than or equal to",
    "headerFilterOperator<": "Less than",
    "headerFilterOperator<=": "Less than or equal to",
    // Filter values text
    filterValueAny: "any",
    filterValueTrue: "true",
    filterValueFalse: "false",
    // Column menu text
    columnMenuLabel: "Menu",
    columnMenuShowColumns: "Show columns",
    columnMenuManageColumns: "Manage columns",
    columnMenuFilter: "Filter",
    columnMenuHideColumn: "Hide column",
    columnMenuUnsort: "Unsort",
    columnMenuSortAsc: "Sort by ASC",
    columnMenuSortDesc: "Sort by DESC",
    // Column header text
    columnHeaderFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
    columnHeaderFiltersLabel: "Show filters",
    columnHeaderSortIconLabel: "Sort",
    // Rows selected footer text
    footerRowSelected: (count) => count !== 1 ? `${count.toLocaleString()} rows selected` : `${count.toLocaleString()} row selected`,
    // Total row amount footer text
    footerTotalRows: "Total Rows:",
    // Total visible row amount footer text
    footerTotalVisibleRows: (visibleCount, totalCount) => `${visibleCount.toLocaleString()} of ${totalCount.toLocaleString()}`,
    // Checkbox selection text
    checkboxSelectionHeaderName: "Checkbox selection",
    checkboxSelectionSelectAllRows: "Select all rows",
    checkboxSelectionUnselectAllRows: "Unselect all rows",
    checkboxSelectionSelectRow: "Select row",
    checkboxSelectionUnselectRow: "Unselect row",
    // Boolean cell text
    booleanCellTrueLabel: "yes",
    booleanCellFalseLabel: "no",
    // Actions cell more text
    actionsCellMore: "more",
    // Column pinning text
    pinToLeft: "Pin to left",
    pinToRight: "Pin to right",
    unpin: "Unpin",
    // Tree Data
    treeDataGroupingHeaderName: "Group",
    treeDataExpand: "see children",
    treeDataCollapse: "hide children",
    // Grouping columns
    groupingColumnHeaderName: "Group",
    groupColumn: (name) => `Group by ${name}`,
    unGroupColumn: (name) => `Stop grouping by ${name}`,
    // Master/detail
    detailPanelToggle: "Detail panel toggle",
    expandDetailPanel: "Expand",
    collapseDetailPanel: "Collapse",
    // Used core components translation keys
    MuiTablePagination: {},
    // Row reordering text
    rowReorderingHeaderName: "Row reordering",
    // Aggregation
    aggregationMenuItemHeader: "Aggregation",
    aggregationFunctionLabelSum: "sum",
    aggregationFunctionLabelAvg: "avg",
    aggregationFunctionLabelMin: "min",
    aggregationFunctionLabelMax: "max",
    aggregationFunctionLabelSize: "size"
  };
  const useUtilityClasses$a = (ownerState) => {
    const {
      classes
    } = ownerState;
    return React__namespace.useMemo(() => {
      const slots = {
        cellCheckbox: ["cellCheckbox"],
        columnHeaderCheckbox: ["columnHeaderCheckbox"]
      };
      return composeClasses(slots, getDataGridUtilityClass, classes);
    }, [classes]);
  };
  const useGridRowSelectionPreProcessors = (apiRef2, props) => {
    const ownerState = {
      classes: props.classes
    };
    const classes = useUtilityClasses$a(ownerState);
    const updateSelectionColumn = React__namespace.useCallback((columnsState) => {
      const selectionColumn = _extends({}, GRID_CHECKBOX_SELECTION_COL_DEF, {
        cellClassName: classes.cellCheckbox,
        headerClassName: classes.columnHeaderCheckbox,
        headerName: apiRef2.current.getLocaleText("checkboxSelectionHeaderName")
      });
      const shouldHaveSelectionColumn = props.checkboxSelection;
      const haveSelectionColumn = columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] != null;
      if (shouldHaveSelectionColumn && !haveSelectionColumn) {
        columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] = selectionColumn;
        columnsState.orderedFields = [GRID_CHECKBOX_SELECTION_FIELD, ...columnsState.orderedFields];
      } else if (!shouldHaveSelectionColumn && haveSelectionColumn) {
        delete columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD];
        columnsState.orderedFields = columnsState.orderedFields.filter((field) => field !== GRID_CHECKBOX_SELECTION_FIELD);
      } else if (shouldHaveSelectionColumn && haveSelectionColumn) {
        columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] = _extends({}, selectionColumn, columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD]);
      }
      return columnsState;
    }, [apiRef2, classes, props.checkboxSelection]);
    useGridRegisterPipeProcessor(apiRef2, "hydrateColumns", updateSelectionColumn);
  };
  const sortingStateInitializer = (state, props) => {
    var _ref, _props$sortModel, _props$initialState;
    const sortModel = (_ref = (_props$sortModel = props.sortModel) != null ? _props$sortModel : (_props$initialState = props.initialState) == null || (_props$initialState = _props$initialState.sorting) == null ? void 0 : _props$initialState.sortModel) != null ? _ref : [];
    return _extends({}, state, {
      sorting: {
        sortModel: sanitizeSortModel(sortModel, props.disableMultipleColumnsSorting),
        sortedRows: []
      }
    });
  };
  const useGridSorting = (apiRef2, props) => {
    var _props$initialState3;
    const logger = useGridLogger(apiRef2, "useGridSorting");
    apiRef2.current.registerControlState({
      stateId: "sortModel",
      propModel: props.sortModel,
      propOnChange: props.onSortModelChange,
      stateSelector: gridSortModelSelector,
      changeEvent: "sortModelChange"
    });
    const upsertSortModel = React__namespace.useCallback((field, sortItem) => {
      const sortModel = gridSortModelSelector(apiRef2);
      const existingIdx = sortModel.findIndex((c2) => c2.field === field);
      let newSortModel = [...sortModel];
      if (existingIdx > -1) {
        if (!sortItem) {
          newSortModel.splice(existingIdx, 1);
        } else {
          newSortModel.splice(existingIdx, 1, sortItem);
        }
      } else {
        newSortModel = [...sortModel, sortItem];
      }
      return newSortModel;
    }, [apiRef2]);
    const createSortItem = React__namespace.useCallback((col, directionOverride) => {
      var _col$sortingOrder2;
      const sortModel = gridSortModelSelector(apiRef2);
      const existing = sortModel.find((c2) => c2.field === col.field);
      if (existing) {
        var _col$sortingOrder;
        const nextSort = directionOverride === void 0 ? getNextGridSortDirection((_col$sortingOrder = col.sortingOrder) != null ? _col$sortingOrder : props.sortingOrder, existing.sort) : directionOverride;
        return nextSort == null ? void 0 : _extends({}, existing, {
          sort: nextSort
        });
      }
      return {
        field: col.field,
        sort: directionOverride === void 0 ? getNextGridSortDirection((_col$sortingOrder2 = col.sortingOrder) != null ? _col$sortingOrder2 : props.sortingOrder) : directionOverride
      };
    }, [apiRef2, props.sortingOrder]);
    const addColumnMenuItem = React__namespace.useCallback((columnMenuItems, colDef) => {
      if (colDef == null || colDef.sortable === false) {
        return columnMenuItems;
      }
      const sortingOrder = colDef.sortingOrder || props.sortingOrder;
      if (sortingOrder.some((item) => !!item)) {
        return [...columnMenuItems, "columnMenuSortItem"];
      }
      return columnMenuItems;
    }, [props.sortingOrder]);
    const applySorting = React__namespace.useCallback(() => {
      apiRef2.current.setState((state) => {
        if (props.sortingMode === "server") {
          logger.debug("Skipping sorting rows as sortingMode = server");
          return _extends({}, state, {
            sorting: _extends({}, state.sorting, {
              sortedRows: getTreeNodeDescendants(gridRowTreeSelector(apiRef2), GRID_ROOT_GROUP_ID, false)
            })
          });
        }
        const sortModel = gridSortModelSelector(state, apiRef2.current.instanceId);
        const sortRowList = buildAggregatedSortingApplier(sortModel, apiRef2);
        const sortedRows = apiRef2.current.applyStrategyProcessor("sorting", {
          sortRowList
        });
        return _extends({}, state, {
          sorting: _extends({}, state.sorting, {
            sortedRows
          })
        });
      });
      apiRef2.current.publishEvent("sortedRowsSet");
      apiRef2.current.forceUpdate();
    }, [apiRef2, logger, props.sortingMode]);
    const setSortModel = React__namespace.useCallback((model) => {
      const currentModel = gridSortModelSelector(apiRef2);
      if (currentModel !== model) {
        logger.debug(`Setting sort model`);
        apiRef2.current.setState(mergeStateWithSortModel(model, props.disableMultipleColumnsSorting));
        apiRef2.current.forceUpdate();
        apiRef2.current.applySorting();
      }
    }, [apiRef2, logger, props.disableMultipleColumnsSorting]);
    const sortColumn = React__namespace.useCallback((column2, direction, allowMultipleSorting) => {
      if (!column2.sortable) {
        return;
      }
      const sortItem = createSortItem(column2, direction);
      let sortModel;
      if (!allowMultipleSorting || props.disableMultipleColumnsSorting) {
        sortModel = !sortItem ? [] : [sortItem];
      } else {
        sortModel = upsertSortModel(column2.field, sortItem);
      }
      apiRef2.current.setSortModel(sortModel);
    }, [apiRef2, upsertSortModel, createSortItem, props.disableMultipleColumnsSorting]);
    const getSortModel = React__namespace.useCallback(() => gridSortModelSelector(apiRef2), [apiRef2]);
    const getSortedRows = React__namespace.useCallback(() => {
      const sortedRows = gridSortedRowEntriesSelector(apiRef2);
      return sortedRows.map((row) => row.model);
    }, [apiRef2]);
    const getSortedRowIds = React__namespace.useCallback(() => gridSortedRowIdsSelector(apiRef2), [apiRef2]);
    const getRowIdFromRowIndex = React__namespace.useCallback((index) => apiRef2.current.getSortedRowIds()[index], [apiRef2]);
    const sortApi = {
      getSortModel,
      getSortedRows,
      getSortedRowIds,
      getRowIdFromRowIndex,
      setSortModel,
      sortColumn,
      applySorting
    };
    useGridApiMethod(apiRef2, sortApi, "public");
    const stateExportPreProcessing = React__namespace.useCallback((prevState, context) => {
      var _props$initialState2;
      const sortModelToExport = gridSortModelSelector(apiRef2);
      const shouldExportSortModel = (
        // Always export if the `exportOnlyDirtyModels` property is not activated
        !context.exportOnlyDirtyModels || // Always export if the model is controlled
        props.sortModel != null || // Always export if the model has been initialized
        ((_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.sorting) == null ? void 0 : _props$initialState2.sortModel) != null || // Export if the model is not empty
        sortModelToExport.length > 0
      );
      if (!shouldExportSortModel) {
        return prevState;
      }
      return _extends({}, prevState, {
        sorting: {
          sortModel: sortModelToExport
        }
      });
    }, [apiRef2, props.sortModel, (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.sorting) == null ? void 0 : _props$initialState3.sortModel]);
    const stateRestorePreProcessing = React__namespace.useCallback((params, context) => {
      var _context$stateToResto;
      const sortModel = (_context$stateToResto = context.stateToRestore.sorting) == null ? void 0 : _context$stateToResto.sortModel;
      if (sortModel == null) {
        return params;
      }
      apiRef2.current.setState(mergeStateWithSortModel(sortModel, props.disableMultipleColumnsSorting));
      return _extends({}, params, {
        callbacks: [...params.callbacks, apiRef2.current.applySorting]
      });
    }, [apiRef2, props.disableMultipleColumnsSorting]);
    const flatSortingMethod = React__namespace.useCallback((params) => {
      const rowTree = gridRowTreeSelector(apiRef2);
      const rootGroupNode = rowTree[GRID_ROOT_GROUP_ID];
      const sortedChildren = params.sortRowList ? params.sortRowList(rootGroupNode.children.map((childId) => rowTree[childId])) : [...rootGroupNode.children];
      if (rootGroupNode.footerId != null) {
        sortedChildren.push(rootGroupNode.footerId);
      }
      return sortedChildren;
    }, [apiRef2]);
    useGridRegisterPipeProcessor(apiRef2, "exportState", stateExportPreProcessing);
    useGridRegisterPipeProcessor(apiRef2, "restoreState", stateRestorePreProcessing);
    useGridRegisterStrategyProcessor(apiRef2, GRID_DEFAULT_STRATEGY, "sorting", flatSortingMethod);
    const handleColumnHeaderClick = React__namespace.useCallback(({
      colDef
    }, event) => {
      const allowMultipleSorting = event.shiftKey || event.metaKey || event.ctrlKey;
      sortColumn(colDef, void 0, allowMultipleSorting);
    }, [sortColumn]);
    const handleColumnHeaderKeyDown = React__namespace.useCallback(({
      colDef
    }, event) => {
      if (isEnterKey(event.key) && !event.ctrlKey && !event.metaKey) {
        sortColumn(colDef, void 0, event.shiftKey);
      }
    }, [sortColumn]);
    const handleColumnsChange = React__namespace.useCallback(() => {
      const sortModel = gridSortModelSelector(apiRef2);
      const latestColumns = gridColumnLookupSelector(apiRef2);
      if (sortModel.length > 0) {
        const newModel = sortModel.filter((sortItem) => latestColumns[sortItem.field]);
        if (newModel.length < sortModel.length) {
          apiRef2.current.setSortModel(newModel);
        }
      }
    }, [apiRef2]);
    const handleStrategyProcessorChange = React__namespace.useCallback((methodName) => {
      if (methodName === "sorting") {
        apiRef2.current.applySorting();
      }
    }, [apiRef2]);
    useGridRegisterPipeProcessor(apiRef2, "columnMenu", addColumnMenuItem);
    useGridApiEventHandler(apiRef2, "columnHeaderClick", handleColumnHeaderClick);
    useGridApiEventHandler(apiRef2, "columnHeaderKeyDown", handleColumnHeaderKeyDown);
    useGridApiEventHandler(apiRef2, "rowsSet", apiRef2.current.applySorting);
    useGridApiEventHandler(apiRef2, "columnsChange", handleColumnsChange);
    useGridApiEventHandler(apiRef2, "activeStrategyProcessorChange", handleStrategyProcessorChange);
    useFirstRender(() => {
      apiRef2.current.applySorting();
    });
    useEnhancedEffect$1(() => {
      if (props.sortModel !== void 0) {
        apiRef2.current.setSortModel(props.sortModel);
      }
    }, [apiRef2, props.sortModel]);
  };
  function scrollIntoView(dimensions) {
    const {
      clientHeight,
      scrollTop,
      offsetHeight,
      offsetTop
    } = dimensions;
    const elementBottom = offsetTop + offsetHeight;
    if (offsetHeight > clientHeight) {
      return offsetTop;
    }
    if (elementBottom - clientHeight > scrollTop) {
      return elementBottom - clientHeight;
    }
    if (offsetTop < scrollTop) {
      return offsetTop;
    }
    return void 0;
  }
  const useGridScroll = (apiRef2, props) => {
    const theme = useTheme();
    const logger = useGridLogger(apiRef2, "useGridScroll");
    const colRef = apiRef2.current.columnHeadersElementRef;
    const virtualScrollerRef = apiRef2.current.virtualScrollerRef;
    const visibleSortedRows = useGridSelector(apiRef2, gridExpandedSortedRowEntriesSelector);
    const scrollToIndexes = React__namespace.useCallback((params) => {
      const totalRowCount = gridRowCountSelector(apiRef2);
      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef2);
      const scrollToHeader = params.rowIndex == null;
      if (!scrollToHeader && totalRowCount === 0 || visibleColumns.length === 0) {
        return false;
      }
      logger.debug(`Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `);
      let scrollCoordinates = {};
      if (params.colIndex != null) {
        const columnPositions = gridColumnPositionsSelector(apiRef2);
        let cellWidth;
        if (typeof params.rowIndex !== "undefined") {
          var _visibleSortedRows$pa;
          const rowId = (_visibleSortedRows$pa = visibleSortedRows[params.rowIndex]) == null ? void 0 : _visibleSortedRows$pa.id;
          const cellColSpanInfo = apiRef2.current.unstable_getCellColSpanInfo(rowId, params.colIndex);
          if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {
            cellWidth = cellColSpanInfo.cellProps.width;
          }
        }
        if (typeof cellWidth === "undefined") {
          cellWidth = visibleColumns[params.colIndex].computedWidth;
        }
        scrollCoordinates.left = scrollIntoView({
          clientHeight: virtualScrollerRef.current.clientWidth,
          scrollTop: Math.abs(virtualScrollerRef.current.scrollLeft),
          offsetHeight: cellWidth,
          offsetTop: columnPositions[params.colIndex]
        });
      }
      if (params.rowIndex != null) {
        var _querySelector, _querySelector2;
        const rowsMeta = gridRowsMetaSelector(apiRef2.current.state);
        const page = gridPageSelector(apiRef2);
        const pageSize2 = gridPageSizeSelector(apiRef2);
        const elementIndex = !props.pagination ? params.rowIndex : params.rowIndex - page * pageSize2;
        const targetOffsetHeight = rowsMeta.positions[elementIndex + 1] ? rowsMeta.positions[elementIndex + 1] - rowsMeta.positions[elementIndex] : rowsMeta.currentPageTotalHeight - rowsMeta.positions[elementIndex];
        const topPinnedRowsHeight = ((_querySelector = virtualScrollerRef.current.querySelector(`.${gridClasses["pinnedRows--top"]}`)) == null ? void 0 : _querySelector.clientHeight) || 0;
        const bottomPinnedRowsHeight = ((_querySelector2 = virtualScrollerRef.current.querySelector(`.${gridClasses["pinnedRows--bottom"]}`)) == null ? void 0 : _querySelector2.clientHeight) || 0;
        scrollCoordinates.top = scrollIntoView({
          clientHeight: virtualScrollerRef.current.clientHeight - topPinnedRowsHeight - bottomPinnedRowsHeight,
          scrollTop: virtualScrollerRef.current.scrollTop,
          offsetHeight: targetOffsetHeight,
          offsetTop: rowsMeta.positions[elementIndex]
        });
      }
      scrollCoordinates = apiRef2.current.unstable_applyPipeProcessors("scrollToIndexes", scrollCoordinates, params);
      if (typeof scrollCoordinates.left !== void 0 || typeof scrollCoordinates.top !== void 0) {
        apiRef2.current.scroll(scrollCoordinates);
        return true;
      }
      return false;
    }, [logger, apiRef2, virtualScrollerRef, props.pagination, visibleSortedRows]);
    const scroll = React__namespace.useCallback((params) => {
      if (virtualScrollerRef.current && params.left != null && colRef.current) {
        const direction = theme.direction === "rtl" ? -1 : 1;
        colRef.current.scrollLeft = params.left;
        virtualScrollerRef.current.scrollLeft = direction * params.left;
        logger.debug(`Scrolling left: ${params.left}`);
      }
      if (virtualScrollerRef.current && params.top != null) {
        virtualScrollerRef.current.scrollTop = params.top;
        logger.debug(`Scrolling top: ${params.top}`);
      }
      logger.debug(`Scrolling, updating container, and viewport`);
    }, [virtualScrollerRef, theme.direction, colRef, logger]);
    const getScrollPosition = React__namespace.useCallback(() => {
      if (!(virtualScrollerRef != null && virtualScrollerRef.current)) {
        return {
          top: 0,
          left: 0
        };
      }
      return {
        top: virtualScrollerRef.current.scrollTop,
        left: virtualScrollerRef.current.scrollLeft
      };
    }, [virtualScrollerRef]);
    const scrollApi = {
      scroll,
      scrollToIndexes,
      getScrollPosition
    };
    useGridApiMethod(apiRef2, scrollApi, "public");
  };
  function useGridEvents(apiRef2, props) {
    useGridApiOptionHandler(apiRef2, "columnHeaderClick", props.onColumnHeaderClick);
    useGridApiOptionHandler(apiRef2, "columnHeaderDoubleClick", props.onColumnHeaderDoubleClick);
    useGridApiOptionHandler(apiRef2, "columnHeaderOver", props.onColumnHeaderOver);
    useGridApiOptionHandler(apiRef2, "columnHeaderOut", props.onColumnHeaderOut);
    useGridApiOptionHandler(apiRef2, "columnHeaderEnter", props.onColumnHeaderEnter);
    useGridApiOptionHandler(apiRef2, "columnHeaderLeave", props.onColumnHeaderLeave);
    useGridApiOptionHandler(apiRef2, "cellClick", props.onCellClick);
    useGridApiOptionHandler(apiRef2, "cellDoubleClick", props.onCellDoubleClick);
    useGridApiOptionHandler(apiRef2, "cellKeyDown", props.onCellKeyDown);
    useGridApiOptionHandler(apiRef2, "preferencePanelClose", props.onPreferencePanelClose);
    useGridApiOptionHandler(apiRef2, "preferencePanelOpen", props.onPreferencePanelOpen);
    useGridApiOptionHandler(apiRef2, "menuOpen", props.onMenuOpen);
    useGridApiOptionHandler(apiRef2, "menuClose", props.onMenuClose);
    useGridApiOptionHandler(apiRef2, "rowDoubleClick", props.onRowDoubleClick);
    useGridApiOptionHandler(apiRef2, "rowClick", props.onRowClick);
    useGridApiOptionHandler(apiRef2, "stateChange", props.onStateChange);
  }
  const hasScroll = ({
    content,
    container,
    scrollBarSize
  }) => {
    const hasScrollXIfNoYScrollBar = content.width > container.width;
    const hasScrollYIfNoXScrollBar = content.height > container.height;
    let hasScrollX = false;
    let hasScrollY = false;
    if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {
      hasScrollX = hasScrollXIfNoYScrollBar;
      hasScrollY = content.height + (hasScrollX ? scrollBarSize : 0) > container.height;
      if (hasScrollY) {
        hasScrollX = content.width + scrollBarSize > container.width;
      }
    }
    return {
      hasScrollX,
      hasScrollY
    };
  };
  function useGridDimensions(apiRef2, props) {
    const logger = useGridLogger(apiRef2, "useResizeContainer");
    const errorShown = React__namespace.useRef(false);
    const rootDimensionsRef = React__namespace.useRef(null);
    const fullDimensionsRef = React__namespace.useRef(null);
    const rowsMeta = useGridSelector(apiRef2, gridRowsMetaSelector);
    const densityFactor = useGridSelector(apiRef2, gridDensityFactorSelector);
    const rowHeight = Math.floor(props.rowHeight * densityFactor);
    const totalHeaderHeight = getTotalHeaderHeight(apiRef2, props.columnHeaderHeight);
    const updateGridDimensionsRef = React__namespace.useCallback(() => {
      var _apiRef$current$rootE;
      const rootElement = (_apiRef$current$rootE = apiRef2.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;
      const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef2);
      const pinnedRowsHeight = calculatePinnedRowsHeight(apiRef2);
      if (!rootDimensionsRef.current) {
        return;
      }
      let scrollBarSize;
      if (props.scrollbarSize != null) {
        scrollBarSize = props.scrollbarSize;
      } else if (!columnsTotalWidth || !rootElement) {
        scrollBarSize = 0;
      } else {
        const doc = ownerDocument(rootElement);
        const scrollDiv = doc.createElement("div");
        scrollDiv.style.width = "99px";
        scrollDiv.style.height = "99px";
        scrollDiv.style.position = "absolute";
        scrollDiv.style.overflow = "scroll";
        scrollDiv.className = "scrollDiv";
        rootElement.appendChild(scrollDiv);
        scrollBarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        rootElement.removeChild(scrollDiv);
      }
      let viewportOuterSize;
      let hasScrollX;
      let hasScrollY;
      if (props.autoHeight) {
        hasScrollY = false;
        hasScrollX = Math.round(columnsTotalWidth) > Math.round(rootDimensionsRef.current.width);
        viewportOuterSize = {
          width: rootDimensionsRef.current.width,
          height: rowsMeta.currentPageTotalHeight + (hasScrollX ? scrollBarSize : 0)
        };
      } else {
        viewportOuterSize = {
          width: rootDimensionsRef.current.width,
          height: Math.max(rootDimensionsRef.current.height - totalHeaderHeight, 0)
        };
        const scrollInformation = hasScroll({
          content: {
            width: Math.round(columnsTotalWidth),
            height: rowsMeta.currentPageTotalHeight
          },
          container: {
            width: Math.round(viewportOuterSize.width),
            height: viewportOuterSize.height - pinnedRowsHeight.top - pinnedRowsHeight.bottom
          },
          scrollBarSize
        });
        hasScrollY = scrollInformation.hasScrollY;
        hasScrollX = scrollInformation.hasScrollX;
      }
      const viewportInnerSize = {
        width: viewportOuterSize.width - (hasScrollY ? scrollBarSize : 0),
        height: viewportOuterSize.height - (hasScrollX ? scrollBarSize : 0)
      };
      const newFullDimensions = {
        viewportOuterSize,
        viewportInnerSize,
        hasScrollX,
        hasScrollY,
        scrollBarSize
      };
      const prevDimensions = fullDimensionsRef.current;
      fullDimensionsRef.current = newFullDimensions;
      if (newFullDimensions.viewportInnerSize.width !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.width) || newFullDimensions.viewportInnerSize.height !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.height)) {
        apiRef2.current.publishEvent("viewportInnerSizeChange", newFullDimensions.viewportInnerSize);
      }
    }, [apiRef2, props.scrollbarSize, props.autoHeight, rowsMeta.currentPageTotalHeight, totalHeaderHeight]);
    const [savedSize, setSavedSize] = React__namespace.useState();
    const debouncedSetSavedSize = React__namespace.useMemo(() => debounce$1(setSavedSize, 60), []);
    const previousSize = React__namespace.useRef();
    useEnhancedEffect$1(() => {
      if (savedSize) {
        updateGridDimensionsRef();
        apiRef2.current.publishEvent("debouncedResize", rootDimensionsRef.current);
      }
    }, [apiRef2, savedSize, updateGridDimensionsRef]);
    const resize = React__namespace.useCallback(() => {
      apiRef2.current.computeSizeAndPublishResizeEvent();
    }, [apiRef2]);
    const getRootDimensions = React__namespace.useCallback(() => fullDimensionsRef.current, []);
    const getViewportPageSize = React__namespace.useCallback(() => {
      const dimensions = apiRef2.current.getRootDimensions();
      if (!dimensions) {
        return 0;
      }
      const currentPage = getVisibleRows(apiRef2, {
        pagination: props.pagination,
        paginationMode: props.paginationMode
      });
      if (props.getRowHeight) {
        const renderContext = apiRef2.current.getRenderContext();
        const viewportPageSize = renderContext.lastRowIndex - renderContext.firstRowIndex;
        return Math.min(viewportPageSize - 1, currentPage.rows.length);
      }
      const maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / rowHeight);
      return Math.min(maximumPageSizeWithoutScrollBar, currentPage.rows.length);
    }, [apiRef2, props.pagination, props.paginationMode, props.getRowHeight, rowHeight]);
    const computeSizeAndPublishResizeEvent = React__namespace.useCallback(() => {
      var _apiRef$current$mainE, _previousSize$current, _previousSize$current2;
      const mainEl = (_apiRef$current$mainE = apiRef2.current.mainElementRef) == null ? void 0 : _apiRef$current$mainE.current;
      if (!mainEl) {
        return;
      }
      const win = ownerWindow(mainEl);
      const computedStyle = win.getComputedStyle(mainEl);
      const height2 = parseFloat(computedStyle.height) || 0;
      const width2 = parseFloat(computedStyle.width) || 0;
      const hasHeightChanged = height2 !== ((_previousSize$current = previousSize.current) == null ? void 0 : _previousSize$current.height);
      const hasWidthChanged = width2 !== ((_previousSize$current2 = previousSize.current) == null ? void 0 : _previousSize$current2.width);
      if (!previousSize.current || hasHeightChanged || hasWidthChanged) {
        const size = {
          width: width2,
          height: height2
        };
        apiRef2.current.publishEvent("resize", size);
        previousSize.current = size;
      }
    }, [apiRef2]);
    const dimensionsApi = {
      resize,
      getRootDimensions
    };
    const dimensionsPrivateApi = {
      getViewportPageSize,
      updateGridDimensionsRef,
      computeSizeAndPublishResizeEvent
    };
    useGridApiMethod(apiRef2, dimensionsApi, "public");
    useGridApiMethod(apiRef2, dimensionsPrivateApi, "private");
    const isFirstSizing = React__namespace.useRef(true);
    const handleResize = React__namespace.useCallback((size) => {
      rootDimensionsRef.current = size;
      const isJSDOM = /jsdom/.test(window.navigator.userAgent);
      if (size.height === 0 && !errorShown.current && !props.autoHeight && !isJSDOM) {
        logger.error(["The parent DOM element of the data grid has an empty height.", "Please make sure that this element has an intrinsic height.", "The grid displays with a height of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join("\n"));
        errorShown.current = true;
      }
      if (size.width === 0 && !errorShown.current && !isJSDOM) {
        logger.error(["The parent DOM element of the data grid has an empty width.", "Please make sure that this element has an intrinsic width.", "The grid displays with a width of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join("\n"));
        errorShown.current = true;
      }
      if (isFirstSizing.current) {
        setSavedSize(size);
        isFirstSizing.current = false;
        return;
      }
      debouncedSetSavedSize(size);
    }, [props.autoHeight, debouncedSetSavedSize, logger]);
    useEnhancedEffect$1(() => updateGridDimensionsRef(), [updateGridDimensionsRef]);
    useGridApiOptionHandler(apiRef2, "sortedRowsSet", updateGridDimensionsRef);
    useGridApiOptionHandler(apiRef2, "paginationModelChange", updateGridDimensionsRef);
    useGridApiOptionHandler(apiRef2, "columnsChange", updateGridDimensionsRef);
    useGridApiEventHandler(apiRef2, "resize", handleResize);
    useGridApiOptionHandler(apiRef2, "debouncedResize", props.onResize);
  }
  const _excluded$d = ["style"], _excluded2 = ["style"];
  function binarySearch(offset2, positions, sliceStart = 0, sliceEnd = positions.length) {
    if (positions.length <= 0) {
      return -1;
    }
    if (sliceStart >= sliceEnd) {
      return sliceStart;
    }
    const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);
    const itemOffset = positions[pivot];
    return offset2 <= itemOffset ? binarySearch(offset2, positions, sliceStart, pivot) : binarySearch(offset2, positions, pivot + 1, sliceEnd);
  }
  function exponentialSearch(offset2, positions, index) {
    let interval = 1;
    while (index < positions.length && Math.abs(positions[index]) < offset2) {
      index += interval;
      interval *= 2;
    }
    return binarySearch(offset2, positions, Math.floor(index / 2), Math.min(index, positions.length));
  }
  const getRenderableIndexes = ({
    firstIndex,
    lastIndex,
    buffer,
    minFirstIndex,
    maxLastIndex
  }) => {
    return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];
  };
  const areRenderContextsEqual = (context1, context2) => {
    if (context1 === context2) {
      return true;
    }
    return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;
  };
  const MEMOIZE_OPTIONS = {
    maxSize: 3
  };
  const useGridVirtualScroller = (props) => {
    var _currentPage$range3, _currentPage$range4;
    const apiRef2 = useGridPrivateApiContext();
    const rootProps = useGridRootProps();
    const visibleColumns = useGridSelector(apiRef2, gridVisibleColumnDefinitionsSelector);
    const {
      ref,
      disableVirtualization,
      onRenderZonePositioning,
      renderZoneMinColumnIndex = 0,
      renderZoneMaxColumnIndex = visibleColumns.length,
      getRowProps
    } = props;
    const theme = useTheme();
    const columnPositions = useGridSelector(apiRef2, gridColumnPositionsSelector);
    const columnsTotalWidth = useGridSelector(apiRef2, gridColumnsTotalWidthSelector);
    const cellFocus = useGridSelector(apiRef2, gridFocusCellSelector);
    const cellTabIndex = useGridSelector(apiRef2, gridTabIndexCellSelector);
    const rowsMeta = useGridSelector(apiRef2, gridRowsMetaSelector);
    const selectedRowsLookup = useGridSelector(apiRef2, selectedIdsLookupSelector);
    const currentPage = useGridVisibleRows(apiRef2, rootProps);
    const renderZoneRef = React__namespace.useRef(null);
    const rootRef = React__namespace.useRef(null);
    const handleRef = useForkRef(ref, rootRef);
    const [renderContext, setRenderContext] = React__namespace.useState(null);
    const prevRenderContext = React__namespace.useRef(renderContext);
    const scrollPosition = React__namespace.useRef({
      top: 0,
      left: 0
    });
    const [containerDimensions, setContainerDimensions] = React__namespace.useState({
      width: null,
      height: null
    });
    const prevTotalWidth = React__namespace.useRef(columnsTotalWidth);
    const rowStyleCache = React__namespace.useRef(/* @__PURE__ */ Object.create(null));
    const prevGetRowProps = React__namespace.useRef();
    const prevRootRowStyle = React__namespace.useRef();
    const getRenderedColumnsRef = React__namespace.useRef(defaultMemoize((columns, firstColumnToRender, lastColumnToRender, minFirstColumn, maxLastColumn, indexOfColumnWithFocusedCell2) => {
      let focusedCellColumnIndexNotInRange;
      const renderedColumns = columns.slice(firstColumnToRender, lastColumnToRender);
      if (indexOfColumnWithFocusedCell2 > -1) {
        if (firstColumnToRender > indexOfColumnWithFocusedCell2 && indexOfColumnWithFocusedCell2 >= minFirstColumn) {
          focusedCellColumnIndexNotInRange = indexOfColumnWithFocusedCell2;
        } else if (lastColumnToRender < indexOfColumnWithFocusedCell2 && indexOfColumnWithFocusedCell2 < maxLastColumn) {
          focusedCellColumnIndexNotInRange = indexOfColumnWithFocusedCell2;
        }
      }
      return {
        focusedCellColumnIndexNotInRange,
        renderedColumns
      };
    }, MEMOIZE_OPTIONS));
    const indexOfColumnWithFocusedCell = React__namespace.useMemo(() => {
      if (cellFocus !== null) {
        return visibleColumns.findIndex((column2) => column2.field === cellFocus.field);
      }
      return -1;
    }, [cellFocus, visibleColumns]);
    const getNearestIndexToRender = React__namespace.useCallback((offset2) => {
      var _currentPage$range, _currentPage$range2;
      const lastMeasuredIndexRelativeToAllRows = apiRef2.current.getLastMeasuredRowIndex();
      let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;
      if ((_currentPage$range = currentPage.range) != null && _currentPage$range.lastRowIndex && !allRowsMeasured) {
        allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= currentPage.range.lastRowIndex;
      }
      const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.firstRowIndex) || 0), 0, rowsMeta.positions.length);
      if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset2) {
        return binarySearch(offset2, rowsMeta.positions);
      }
      return exponentialSearch(offset2, rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage);
    }, [apiRef2, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);
    const computeRenderContext = React__namespace.useCallback(() => {
      if (disableVirtualization) {
        return {
          firstRowIndex: 0,
          lastRowIndex: currentPage.rows.length,
          firstColumnIndex: 0,
          lastColumnIndex: visibleColumns.length
        };
      }
      const {
        top: top2,
        left: left2
      } = scrollPosition.current;
      const firstRowIndex = Math.min(getNearestIndexToRender(top2), rowsMeta.positions.length - 1);
      const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top2 + containerDimensions.height);
      let hasRowWithAutoHeight = false;
      let firstColumnIndex = 0;
      let lastColumnIndex = columnPositions.length;
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: firstRowIndex,
        lastIndex: lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rootProps.rowBuffer
      });
      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {
        const row = currentPage.rows[i];
        hasRowWithAutoHeight = apiRef2.current.rowHasAutoHeight(row.id);
      }
      if (!hasRowWithAutoHeight) {
        firstColumnIndex = binarySearch(Math.abs(left2), columnPositions);
        lastColumnIndex = binarySearch(Math.abs(left2) + containerDimensions.width, columnPositions);
      }
      return {
        firstRowIndex,
        lastRowIndex,
        firstColumnIndex,
        lastColumnIndex
      };
    }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef2, containerDimensions]);
    useEnhancedEffect$1(() => {
      if (disableVirtualization) {
        renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;
      } else {
        rootRef.current.scrollLeft = 0;
        rootRef.current.scrollTop = 0;
      }
    }, [disableVirtualization]);
    useEnhancedEffect$1(() => {
      setContainerDimensions({
        width: rootRef.current.clientWidth,
        height: rootRef.current.clientHeight
      });
    }, [rowsMeta.currentPageTotalHeight]);
    const handleResize = React__namespace.useCallback(() => {
      if (rootRef.current) {
        setContainerDimensions({
          width: rootRef.current.clientWidth,
          height: rootRef.current.clientHeight
        });
      }
    }, []);
    useGridApiEventHandler(apiRef2, "debouncedResize", handleResize);
    const updateRenderZonePosition = React__namespace.useCallback((nextRenderContext) => {
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstRowIndex,
        lastIndex: nextRenderContext.lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rootProps.rowBuffer
      });
      const [initialFirstColumnToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstColumnIndex,
        lastIndex: nextRenderContext.lastColumnIndex,
        minFirstIndex: renderZoneMinColumnIndex,
        maxLastIndex: renderZoneMaxColumnIndex,
        buffer: rootProps.columnBuffer
      });
      const firstColumnToRender = getFirstNonSpannedColumnToRender({
        firstColumnToRender: initialFirstColumnToRender,
        apiRef: apiRef2,
        firstRowToRender,
        lastRowToRender,
        visibleRows: currentPage.rows
      });
      const direction = theme.direction === "ltr" ? 1 : -1;
      const top2 = gridRowsMetaSelector(apiRef2.current.state).positions[firstRowToRender];
      const left2 = direction * gridColumnPositionsSelector(apiRef2)[firstColumnToRender];
      renderZoneRef.current.style.transform = `translate3d(${left2}px, ${top2}px, 0px)`;
      if (typeof onRenderZonePositioning === "function") {
        onRenderZonePositioning({
          top: top2,
          left: left2
        });
      }
    }, [apiRef2, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer, theme.direction]);
    const updateRenderContext = React__namespace.useCallback((nextRenderContext) => {
      if (prevRenderContext.current && areRenderContextsEqual(nextRenderContext, prevRenderContext.current)) {
        updateRenderZonePosition(nextRenderContext);
        return;
      }
      setRenderContext(nextRenderContext);
      updateRenderZonePosition(nextRenderContext);
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstRowIndex,
        lastIndex: nextRenderContext.lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rootProps.rowBuffer
      });
      apiRef2.current.publishEvent("renderedRowsIntervalChange", {
        firstRowToRender,
        lastRowToRender
      });
      prevRenderContext.current = nextRenderContext;
    }, [apiRef2, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer, updateRenderZonePosition]);
    useEnhancedEffect$1(() => {
      if (containerDimensions.width == null) {
        return;
      }
      const initialRenderContext = computeRenderContext();
      updateRenderContext(initialRenderContext);
      const {
        top: top2,
        left: left2
      } = scrollPosition.current;
      const params = {
        top: top2,
        left: left2,
        renderContext: initialRenderContext
      };
      apiRef2.current.publishEvent("scrollPositionChange", params);
    }, [apiRef2, computeRenderContext, containerDimensions.width, updateRenderContext]);
    const handleScroll = useEventCallback((event) => {
      const {
        scrollTop,
        scrollLeft
      } = event.currentTarget;
      scrollPosition.current.top = scrollTop;
      scrollPosition.current.left = scrollLeft;
      if (!prevRenderContext.current || scrollTop < 0) {
        return;
      }
      if (theme.direction === "ltr") {
        if (scrollLeft < 0) {
          return;
        }
      }
      if (theme.direction === "rtl") {
        if (scrollLeft > 0) {
          return;
        }
      }
      const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();
      const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);
      const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);
      const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);
      const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);
      const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth;
      apiRef2.current.publishEvent("scrollPositionChange", {
        top: scrollTop,
        left: scrollLeft,
        renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current
      }, event);
      if (shouldSetState) {
        ReactDOM__default__namespace.flushSync(() => {
          updateRenderContext(nextRenderContext);
        });
        prevTotalWidth.current = columnsTotalWidth;
      }
    });
    const handleWheel = useEventCallback((event) => {
      apiRef2.current.publishEvent("virtualScrollerWheel", {}, event);
    });
    const handleTouchMove = useEventCallback((event) => {
      apiRef2.current.publishEvent("virtualScrollerTouchMove", {}, event);
    });
    const indexOfRowWithFocusedCell = React__namespace.useMemo(() => {
      if (cellFocus !== null) {
        return currentPage.rows.findIndex((row) => row.id === cellFocus.id);
      }
      return -1;
    }, [cellFocus, currentPage.rows]);
    const getRows = (params = {
      renderContext
    }) => {
      var _rootProps$slotProps;
      const {
        onRowRender,
        renderContext: nextRenderContext,
        minFirstColumn = renderZoneMinColumnIndex,
        maxLastColumn = renderZoneMaxColumnIndex,
        availableSpace = containerDimensions.width,
        rowIndexOffset = 0,
        position: position2 = "center"
      } = params;
      if (!nextRenderContext || availableSpace == null) {
        return null;
      }
      const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;
      const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstRowIndex,
        lastIndex: nextRenderContext.lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rowBuffer
      });
      const renderedRows = [];
      if (params.rows) {
        params.rows.forEach((row) => {
          renderedRows.push(row);
          apiRef2.current.calculateColSpan({
            rowId: row.id,
            minFirstColumn,
            maxLastColumn,
            columns: visibleColumns
          });
        });
      } else {
        if (!currentPage.range) {
          return null;
        }
        for (let i = firstRowToRender; i < lastRowToRender; i += 1) {
          const row = currentPage.rows[i];
          renderedRows.push(row);
          apiRef2.current.calculateColSpan({
            rowId: row.id,
            minFirstColumn,
            maxLastColumn,
            columns: visibleColumns
          });
        }
      }
      let isRowWithFocusedCellNotInRange = false;
      if (indexOfRowWithFocusedCell > -1) {
        const rowWithFocusedCell = currentPage.rows[indexOfRowWithFocusedCell];
        if (firstRowToRender > indexOfRowWithFocusedCell || lastRowToRender < indexOfRowWithFocusedCell) {
          isRowWithFocusedCellNotInRange = true;
          if (indexOfRowWithFocusedCell > firstRowToRender) {
            renderedRows.push(rowWithFocusedCell);
          } else {
            renderedRows.unshift(rowWithFocusedCell);
          }
          apiRef2.current.calculateColSpan({
            rowId: rowWithFocusedCell.id,
            minFirstColumn,
            maxLastColumn,
            columns: visibleColumns
          });
        }
      }
      const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstColumnIndex,
        lastIndex: nextRenderContext.lastColumnIndex,
        minFirstIndex: minFirstColumn,
        maxLastIndex: maxLastColumn,
        buffer: columnBuffer
      });
      const firstColumnToRender = getFirstNonSpannedColumnToRender({
        firstColumnToRender: initialFirstColumnToRender,
        apiRef: apiRef2,
        firstRowToRender,
        lastRowToRender,
        visibleRows: currentPage.rows
      });
      let isColumnWihFocusedCellNotInRange = false;
      if (firstColumnToRender > indexOfColumnWithFocusedCell || lastColumnToRender < indexOfColumnWithFocusedCell) {
        isColumnWihFocusedCellNotInRange = true;
      }
      const {
        focusedCellColumnIndexNotInRange,
        renderedColumns
      } = getRenderedColumnsRef.current(visibleColumns, firstColumnToRender, lastColumnToRender, minFirstColumn, maxLastColumn, isColumnWihFocusedCellNotInRange ? indexOfColumnWithFocusedCell : -1);
      const _ref = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.row) || {}, {
        style: rootRowStyle
      } = _ref, rootRowProps = _objectWithoutPropertiesLoose(_ref, _excluded$d);
      const invalidatesCachedRowStyle = prevGetRowProps.current !== getRowProps || prevRootRowStyle.current !== rootRowStyle;
      if (invalidatesCachedRowStyle) {
        rowStyleCache.current = /* @__PURE__ */ Object.create(null);
      }
      const rows = [];
      for (let i = 0; i < renderedRows.length; i += 1) {
        var _currentPage$range5;
        const {
          id,
          model
        } = renderedRows[i];
        const isRowNotVisible = isRowWithFocusedCellNotInRange && cellFocus.id === id;
        const lastVisibleRowIndex = isRowWithFocusedCellNotInRange ? firstRowToRender + i === currentPage.rows.length : firstRowToRender + i === currentPage.rows.length - 1;
        const baseRowHeight = !apiRef2.current.rowHasAutoHeight(id) ? apiRef2.current.unstable_getRowHeight(id) : "auto";
        let isSelected;
        if (selectedRowsLookup[id] == null) {
          isSelected = false;
        } else {
          isSelected = apiRef2.current.isRowSelectable(id);
        }
        if (onRowRender) {
          onRowRender(id);
        }
        const focusedCell = cellFocus !== null && cellFocus.id === id ? cellFocus.field : null;
        const columnWithFocusedCellNotInRange = focusedCellColumnIndexNotInRange !== void 0 && visibleColumns[focusedCellColumnIndexNotInRange];
        const renderedColumnsWithFocusedCell = columnWithFocusedCellNotInRange && focusedCell ? [columnWithFocusedCellNotInRange, ...renderedColumns] : renderedColumns;
        let tabbableCell = null;
        if (cellTabIndex !== null && cellTabIndex.id === id) {
          const cellParams = apiRef2.current.getCellParams(id, cellTabIndex.field);
          tabbableCell = cellParams.cellMode === "view" ? cellTabIndex.field : null;
        }
        const _ref2 = typeof getRowProps === "function" && getRowProps(id, model) || {}, {
          style: rowStyle
        } = _ref2, rowProps = _objectWithoutPropertiesLoose(_ref2, _excluded2);
        if (!rowStyleCache.current[id]) {
          const style2 = _extends({}, rowStyle, rootRowStyle);
          rowStyleCache.current[id] = style2;
        }
        rows.push(/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.row, _extends({
          row: model,
          rowId: id,
          focusedCellColumnIndexNotInRange,
          isNotVisible: isRowNotVisible,
          rowHeight: baseRowHeight,
          focusedCell,
          tabbableCell,
          renderedColumns: renderedColumnsWithFocusedCell,
          visibleColumns,
          firstColumnToRender,
          lastColumnToRender,
          selected: isSelected,
          index: rowIndexOffset + ((currentPage == null || (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i,
          containerWidth: availableSpace,
          isLastVisible: lastVisibleRowIndex,
          position: position2
        }, rowProps, rootRowProps, {
          style: rowStyleCache.current[id]
        }), id));
      }
      prevGetRowProps.current = getRowProps;
      prevRootRowStyle.current = rootRowStyle;
      return rows;
    };
    const needsHorizontalScrollbar = containerDimensions.width && columnsTotalWidth >= containerDimensions.width;
    const contentSize = React__namespace.useMemo(() => {
      const height2 = Math.max(rowsMeta.currentPageTotalHeight, 1);
      let shouldExtendContent = false;
      if (rootRef != null && rootRef.current && height2 <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {
        shouldExtendContent = true;
      }
      const size = {
        width: needsHorizontalScrollbar ? columnsTotalWidth : "auto",
        height: height2,
        minHeight: shouldExtendContent ? "100%" : "auto"
      };
      if (rootProps.autoHeight && currentPage.rows.length === 0) {
        size.height = getMinimalContentHeight(apiRef2, rootProps.rowHeight);
      }
      return size;
    }, [apiRef2, rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, needsHorizontalScrollbar, rootProps.autoHeight, rootProps.rowHeight, currentPage.rows.length]);
    React__namespace.useEffect(() => {
      apiRef2.current.publishEvent("virtualScrollerContentSizeChange");
    }, [apiRef2, contentSize]);
    const rootStyle = React__namespace.useMemo(() => {
      const style2 = {};
      if (!needsHorizontalScrollbar) {
        style2.overflowX = "hidden";
      }
      if (rootProps.autoHeight) {
        style2.overflowY = "hidden";
      }
      return style2;
    }, [needsHorizontalScrollbar, rootProps.autoHeight]);
    const getRenderContext = React__namespace.useCallback(() => {
      return prevRenderContext.current;
    }, []);
    apiRef2.current.register("private", {
      getRenderContext
    });
    return {
      renderContext,
      updateRenderZonePosition,
      getRows,
      getRootProps: (inputProps = {}) => _extends({
        ref: handleRef,
        onScroll: handleScroll,
        onWheel: handleWheel,
        onTouchMove: handleTouchMove
      }, inputProps, {
        style: inputProps.style ? _extends({}, inputProps.style, rootStyle) : rootStyle,
        role: "presentation"
      }),
      getContentProps: ({
        style: style2
      } = {}) => ({
        style: style2 ? _extends({}, style2, contentSize) : contentSize,
        role: "presentation"
      }),
      getRenderZoneProps: () => ({
        ref: renderZoneRef,
        role: "rowgroup"
      })
    };
  };
  const useUtilityClasses$9 = (ownerState) => {
    const {
      classes,
      headerAlign,
      isDragging,
      showColumnBorder,
      groupId
    } = ownerState;
    const slots = {
      root: ["columnHeader", headerAlign === "left" && "columnHeader--alignLeft", headerAlign === "center" && "columnHeader--alignCenter", headerAlign === "right" && "columnHeader--alignRight", isDragging && "columnHeader--moving", showColumnBorder && "columnHeader--showColumnBorder", showColumnBorder && "columnHeader--withRightBorder", "withBorderColor", groupId === null ? "columnHeader--emptyGroup" : "columnHeader--filledGroup"],
      draggableContainer: ["columnHeaderDraggableContainer"],
      titleContainer: ["columnHeaderTitleContainer", "withBorderColor"],
      titleContainerContent: ["columnHeaderTitleContainerContent"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  function GridColumnGroupHeader(props) {
    var _columnGroupsLookup$g;
    const {
      groupId,
      width: width2,
      depth,
      maxDepth,
      fields,
      height: height2,
      colIndex,
      hasFocus,
      tabIndex,
      isLastColumn
    } = props;
    const rootProps = useGridRootProps();
    const headerCellRef = React__namespace.useRef(null);
    const apiRef2 = useGridApiContext();
    const columnGroupsLookup = useGridSelector(apiRef2, gridColumnGroupsLookupSelector);
    const group = groupId ? columnGroupsLookup[groupId] : {};
    const {
      headerName = groupId != null ? groupId : "",
      description = "",
      headerAlign = void 0
    } = group;
    let headerComponent;
    const render = groupId && ((_columnGroupsLookup$g = columnGroupsLookup[groupId]) == null ? void 0 : _columnGroupsLookup$g.renderHeaderGroup);
    const renderParams = React__namespace.useMemo(() => ({
      groupId,
      headerName,
      description,
      depth,
      maxDepth,
      fields,
      colIndex,
      isLastColumn
    }), [groupId, headerName, description, depth, maxDepth, fields, colIndex, isLastColumn]);
    if (groupId && render) {
      headerComponent = render(renderParams);
    }
    const showColumnBorder = rootProps.showColumnVerticalBorder;
    const ownerState = _extends({}, props, {
      classes: rootProps.classes,
      showColumnBorder,
      headerAlign,
      depth,
      isDragging: false
    });
    const label = headerName != null ? headerName : groupId;
    const id = useId();
    const elementId = groupId === null ? `empty-group-cell-${id}` : groupId;
    const classes = useUtilityClasses$9(ownerState);
    React__namespace.useLayoutEffect(() => {
      if (hasFocus) {
        const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
        const elementToFocus = focusableElement || headerCellRef.current;
        elementToFocus == null ? void 0 : elementToFocus.focus();
      }
    }, [apiRef2, hasFocus]);
    const publish = React__namespace.useCallback(
      (eventName) => (event) => {
        if (!event.currentTarget.contains(event.target)) {
          return;
        }
        apiRef2.current.publishEvent(eventName, renderParams, event);
      },
      // For now this is stupid, because renderParams change all the time.
      // Need to move it's computation in the api, such that for a given depth+columnField, I can get the group parameters
      [apiRef2, renderParams]
    );
    const mouseEventsHandlers = React__namespace.useMemo(() => ({
      onKeyDown: publish("columnGroupHeaderKeyDown"),
      onFocus: publish("columnGroupHeaderFocus"),
      onBlur: publish("columnGroupHeaderBlur")
    }), [publish]);
    const headerClassName = typeof group.headerClassName === "function" ? group.headerClassName(renderParams) : group.headerClassName;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnHeaderItem, _extends({
      ref: headerCellRef,
      classes,
      columnMenuOpen: false,
      colIndex,
      height: height2,
      isResizing: false,
      sortDirection: null,
      hasFocus: false,
      tabIndex,
      isDraggable: false,
      headerComponent,
      headerClassName,
      description,
      elementId,
      width: width2,
      columnMenuIconButton: null,
      columnTitleIconButtons: null,
      resizable: false,
      label,
      "aria-colspan": fields.length,
      "data-fields": `|-${fields.join("-|-")}-|`
    }, mouseEventsHandlers));
  }
  const GridColumnHeaderRow = styled$3("div", {
    name: "MuiDataGrid",
    slot: "ColumnHeaderRow",
    overridesResolver: (props, styles2) => styles2.columnHeaderRow
  })(() => ({
    display: "flex"
  }));
  function isUIEvent(event) {
    return !!event.target;
  }
  const useGridColumnHeaders = (props) => {
    const {
      innerRef: innerRefProp,
      minColumnIndex = 0,
      visibleColumns,
      sortColumnLookup,
      filterColumnLookup,
      columnPositions,
      columnHeaderTabIndexState,
      columnGroupHeaderTabIndexState,
      columnHeaderFocus,
      columnGroupHeaderFocus,
      densityFactor,
      headerGroupingMaxDepth,
      columnMenuState,
      columnVisibility,
      columnGroupsHeaderStructure,
      hasOtherElementInTabSequence
    } = props;
    const theme = useTheme$1();
    const [dragCol, setDragCol] = React__namespace.useState("");
    const [resizeCol, setResizeCol] = React__namespace.useState("");
    const apiRef2 = useGridPrivateApiContext();
    const rootProps = useGridRootProps();
    const innerRef = React__namespace.useRef(null);
    const handleInnerRef = useForkRef(innerRefProp, innerRef);
    const [renderContext, setRenderContextRaw] = React__namespace.useState(null);
    const prevRenderContext = React__namespace.useRef(renderContext);
    const prevScrollLeft = React__namespace.useRef(0);
    const currentPage = useGridVisibleRows(apiRef2, rootProps);
    const totalHeaderHeight = getTotalHeaderHeight(apiRef2, rootProps.columnHeaderHeight);
    const headerHeight = Math.floor(rootProps.columnHeaderHeight * densityFactor);
    const setRenderContext = React__namespace.useCallback((nextRenderContext) => {
      if (renderContext && nextRenderContext && areRenderContextsEqual(renderContext, nextRenderContext)) {
        return;
      }
      setRenderContextRaw(nextRenderContext);
    }, [renderContext]);
    React__namespace.useEffect(() => {
      apiRef2.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
    }, [apiRef2]);
    const getFirstColumnIndexToRenderRef = React__namespace.useRef(defaultMemoize(getFirstColumnIndexToRender, {
      equalityCheck: (a, b2) => ["firstColumnIndex", "minColumnIndex", "columnBuffer"].every((key) => a[key] === b2[key])
    }));
    const updateInnerPosition = React__namespace.useCallback((nextRenderContext) => {
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstRowIndex,
        lastIndex: nextRenderContext.lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rootProps.rowBuffer
      });
      const firstColumnToRender = getFirstColumnIndexToRenderRef.current({
        firstColumnIndex: nextRenderContext.firstColumnIndex,
        minColumnIndex,
        columnBuffer: rootProps.columnBuffer,
        firstRowToRender,
        lastRowToRender,
        apiRef: apiRef2,
        visibleRows: currentPage.rows
      });
      const direction = theme.direction === "ltr" ? 1 : -1;
      const offset2 = firstColumnToRender > 0 ? prevScrollLeft.current - direction * columnPositions[firstColumnToRender] : prevScrollLeft.current;
      innerRef.current.style.transform = `translate3d(${-offset2}px, 0px, 0px)`;
    }, [columnPositions, minColumnIndex, rootProps.columnBuffer, apiRef2, currentPage.rows, rootProps.rowBuffer, theme.direction]);
    React__namespace.useLayoutEffect(() => {
      if (renderContext) {
        updateInnerPosition(renderContext);
      }
    }, [renderContext, updateInnerPosition]);
    const handleScroll = React__namespace.useCallback(({
      left: left2,
      renderContext: nextRenderContext = null
    }, event) => {
      var _prevRenderContext$cu, _prevRenderContext$cu2;
      if (!innerRef.current) {
        return;
      }
      if (prevScrollLeft.current === left2 && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {
        return;
      }
      prevScrollLeft.current = left2;
      let canUpdateInnerPosition = false;
      if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {
        if (isUIEvent(event)) {
          ReactDOM__default__namespace.flushSync(() => {
            setRenderContext(nextRenderContext);
          });
          canUpdateInnerPosition = true;
        } else {
          setRenderContext(nextRenderContext);
        }
        prevRenderContext.current = nextRenderContext;
      } else {
        canUpdateInnerPosition = true;
      }
      if (nextRenderContext && canUpdateInnerPosition) {
        updateInnerPosition(nextRenderContext);
      }
    }, [updateInnerPosition, setRenderContext]);
    const handleColumnResizeStart = React__namespace.useCallback((params) => setResizeCol(params.field), []);
    const handleColumnResizeStop = React__namespace.useCallback(() => setResizeCol(""), []);
    const handleColumnReorderStart = React__namespace.useCallback((params) => setDragCol(params.field), []);
    const handleColumnReorderStop = React__namespace.useCallback(() => setDragCol(""), []);
    useGridApiEventHandler(apiRef2, "columnResizeStart", handleColumnResizeStart);
    useGridApiEventHandler(apiRef2, "columnResizeStop", handleColumnResizeStop);
    useGridApiEventHandler(apiRef2, "columnHeaderDragStart", handleColumnReorderStart);
    useGridApiEventHandler(apiRef2, "columnHeaderDragEnd", handleColumnReorderStop);
    useGridApiEventHandler(apiRef2, "scrollPositionChange", handleScroll);
    const getColumnsToRender = (params) => {
      const {
        renderContext: nextRenderContext = renderContext,
        minFirstColumn = minColumnIndex,
        maxLastColumn = visibleColumns.length
      } = params || {};
      if (!nextRenderContext) {
        return null;
      }
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: nextRenderContext.firstRowIndex,
        lastIndex: nextRenderContext.lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rootProps.rowBuffer
      });
      const firstColumnToRender = getFirstColumnIndexToRenderRef.current({
        firstColumnIndex: nextRenderContext.firstColumnIndex,
        minColumnIndex: minFirstColumn,
        columnBuffer: rootProps.columnBuffer,
        apiRef: apiRef2,
        firstRowToRender,
        lastRowToRender,
        visibleRows: currentPage.rows
      });
      const lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);
      const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);
      return {
        renderedColumns,
        firstColumnToRender,
        lastColumnToRender,
        minFirstColumn,
        maxLastColumn
      };
    };
    const getColumnHeaders = (params, other = {}) => {
      const columnsToRender = getColumnsToRender(params);
      if (columnsToRender == null) {
        return null;
      }
      const {
        renderedColumns,
        firstColumnToRender
      } = columnsToRender;
      const columns = [];
      for (let i = 0; i < renderedColumns.length; i += 1) {
        const colDef = renderedColumns[i];
        const columnIndex = firstColumnToRender + i;
        const isFirstColumn = columnIndex === 0;
        const tabIndex = columnHeaderTabIndexState !== null && columnHeaderTabIndexState.field === colDef.field || isFirstColumn && !hasOtherElementInTabSequence ? 0 : -1;
        const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === colDef.field;
        const open = columnMenuState.open && columnMenuState.field === colDef.field;
        columns.push(/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderItem, _extends({}, sortColumnLookup[colDef.field], {
          columnMenuOpen: open,
          filterItemsCounter: filterColumnLookup[colDef.field] && filterColumnLookup[colDef.field].length,
          headerHeight,
          isDragging: colDef.field === dragCol,
          colDef,
          colIndex: columnIndex,
          isResizing: resizeCol === colDef.field,
          hasFocus,
          tabIndex
        }, other), colDef.field));
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderRow, {
        role: "row",
        "aria-rowindex": headerGroupingMaxDepth + 1,
        ownerState: rootProps,
        children: columns
      });
    };
    const getColumnGroupHeaders = (params) => {
      if (headerGroupingMaxDepth === 0) {
        return null;
      }
      const columnsToRender = getColumnsToRender(params);
      if (columnsToRender == null || columnsToRender.renderedColumns.length === 0) {
        return null;
      }
      const {
        firstColumnToRender,
        lastColumnToRender
      } = columnsToRender;
      const columns = [];
      const headerToRender = [];
      for (let depth = 0; depth < headerGroupingMaxDepth; depth += 1) {
        var _apiRef$current$unsta, _apiRef$current$unsta2;
        const rowStructure = columnGroupsHeaderStructure[depth];
        const firstColumnFieldToRender = visibleColumns[firstColumnToRender].field;
        const firstGroupToRender = (_apiRef$current$unsta = apiRef2.current.unstable_getColumnGroupPath(firstColumnFieldToRender)[depth]) != null ? _apiRef$current$unsta : null;
        const firstGroupIndex = rowStructure.findIndex(({
          groupId,
          columnFields
        }) => groupId === firstGroupToRender && columnFields.includes(firstColumnFieldToRender));
        const lastColumnFieldToRender = visibleColumns[lastColumnToRender - 1].field;
        const lastGroupToRender = (_apiRef$current$unsta2 = apiRef2.current.unstable_getColumnGroupPath(lastColumnFieldToRender)[depth]) != null ? _apiRef$current$unsta2 : null;
        const lastGroupIndex = rowStructure.findIndex(({
          groupId,
          columnFields
        }) => groupId === lastGroupToRender && columnFields.includes(lastColumnFieldToRender));
        const visibleColumnGroupHeader = rowStructure.slice(firstGroupIndex, lastGroupIndex + 1).map((groupStructure) => {
          return _extends({}, groupStructure, {
            columnFields: groupStructure.columnFields.filter((field) => columnVisibility[field] !== false)
          });
        }).filter((groupStructure) => groupStructure.columnFields.length > 0);
        const firstVisibleColumnIndex = visibleColumnGroupHeader[0].columnFields.indexOf(firstColumnFieldToRender);
        const hiddenGroupColumns = visibleColumnGroupHeader[0].columnFields.slice(0, firstVisibleColumnIndex);
        const leftOverflow = hiddenGroupColumns.reduce((acc, field) => {
          var _column$computedWidth;
          const column2 = apiRef2.current.getColumn(field);
          return acc + ((_column$computedWidth = column2.computedWidth) != null ? _column$computedWidth : 0);
        }, 0);
        let columnIndex = firstColumnToRender;
        const elements = visibleColumnGroupHeader.map(({
          groupId,
          columnFields
        }) => {
          const hasFocus = columnGroupHeaderFocus !== null && columnGroupHeaderFocus.depth === depth && columnFields.includes(columnGroupHeaderFocus.field);
          const tabIndex = columnGroupHeaderTabIndexState !== null && columnGroupHeaderTabIndexState.depth === depth && columnFields.includes(columnGroupHeaderTabIndexState.field) ? 0 : -1;
          const headerInfo = {
            groupId,
            width: columnFields.reduce((acc, field) => acc + apiRef2.current.getColumn(field).computedWidth, 0),
            fields: columnFields,
            colIndex: columnIndex,
            hasFocus,
            tabIndex
          };
          columnIndex += columnFields.length;
          return headerInfo;
        });
        headerToRender.push({
          leftOverflow,
          elements
        });
      }
      headerToRender.forEach((depthInfo, depthIndex) => {
        columns.push(/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderRow, {
          style: {
            height: `${headerHeight}px`,
            transform: `translateX(-${depthInfo.leftOverflow}px)`
          },
          role: "row",
          "aria-rowindex": depthIndex + 1,
          ownerState: rootProps,
          children: depthInfo.elements.map(({
            groupId,
            width: width2,
            fields,
            colIndex,
            hasFocus,
            tabIndex
          }, groupIndex) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnGroupHeader, {
              groupId,
              width: width2,
              fields,
              colIndex,
              depth: depthIndex,
              isLastColumn: colIndex === visibleColumns.length - fields.length,
              maxDepth: headerToRender.length,
              height: headerHeight,
              hasFocus,
              tabIndex
            }, groupIndex);
          })
        }, depthIndex));
      });
      return columns;
    };
    const rootStyle = {
      minHeight: totalHeaderHeight,
      maxHeight: totalHeaderHeight,
      lineHeight: `${headerHeight}px`
    };
    return {
      renderContext,
      getColumnHeaders,
      getColumnsToRender,
      getColumnGroupHeaders,
      isDragging: !!dragCol,
      getRootProps: (other = {}) => _extends({
        style: rootStyle
      }, other),
      getInnerProps: () => ({
        ref: handleInnerRef,
        role: "rowgroup"
      }),
      headerHeight
    };
  };
  const _excluded$c = ["className"];
  const useUtilityClasses$8 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["columnHeaders", "withBorderColor"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridColumnHeadersRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "ColumnHeaders",
    overridesResolver: (props, styles2) => styles2.columnHeaders
  })({
    position: "relative",
    overflow: "hidden",
    display: "flex",
    alignItems: "center",
    boxSizing: "border-box",
    borderBottom: "1px solid",
    borderTopLeftRadius: "var(--unstable_DataGrid-radius)",
    borderTopRightRadius: "var(--unstable_DataGrid-radius)"
  });
  const GridBaseColumnHeaders = /* @__PURE__ */ React__namespace.forwardRef(function GridColumnHeaders2(props, ref) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$8(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeadersRoot, _extends({
      ref,
      className: clsx(className, classes.root),
      ownerState: rootProps
    }, other, {
      role: "presentation"
    }));
  });
  const _excluded$b = ["isDragging", "className"];
  const useUtilityClasses$7 = (ownerState) => {
    const {
      isDragging,
      hasScrollX,
      classes
    } = ownerState;
    const slots = {
      root: ["columnHeadersInner", isDragging && "columnHeaderDropZone", hasScrollX && "columnHeadersInner--scrollable"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const GridColumnHeadersInnerRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "columnHeadersInner",
    overridesResolver: (props, styles2) => [{
      [`&.${gridClasses.columnHeaderDropZone}`]: styles2.columnHeaderDropZone
    }, styles2.columnHeadersInner]
  })(() => ({
    display: "flex",
    alignItems: "flex-start",
    flexDirection: "column",
    [`&.${gridClasses.columnHeaderDropZone} .${gridClasses.columnHeaderDraggableContainer}`]: {
      cursor: "move"
    },
    [`&.${gridClasses["columnHeadersInner--scrollable"]} .${gridClasses.columnHeader}:last-child`]: {
      borderRight: "none"
    }
  }));
  const GridColumnHeadersInner = /* @__PURE__ */ React__namespace.forwardRef(function GridColumnHeadersInner2(props, ref) {
    var _apiRef$current$getRo, _apiRef$current$getRo2;
    const {
      isDragging,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
    const apiRef2 = useGridApiContext();
    const rootProps = useGridRootProps();
    const ownerState = _extends({}, rootProps, {
      isDragging,
      hasScrollX: (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef2.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.hasScrollX) != null ? _apiRef$current$getRo : false
    });
    const classes = useUtilityClasses$7(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeadersInnerRoot, _extends({
      ref,
      className: clsx(className, classes.root),
      ownerState
    }, other));
  });
  const _excluded$a = ["innerRef", "className", "visibleColumns", "sortColumnLookup", "filterColumnLookup", "columnPositions", "columnHeaderTabIndexState", "columnGroupHeaderTabIndexState", "columnHeaderFocus", "columnGroupHeaderFocus", "densityFactor", "headerGroupingMaxDepth", "columnMenuState", "columnVisibility", "columnGroupsHeaderStructure", "hasOtherElementInTabSequence"];
  const GridColumnHeaders = /* @__PURE__ */ React__namespace.forwardRef(function GridColumnsHeaders(props, ref) {
    const {
      innerRef,
      visibleColumns,
      sortColumnLookup,
      filterColumnLookup,
      columnPositions,
      columnHeaderTabIndexState,
      columnGroupHeaderTabIndexState,
      columnHeaderFocus,
      columnGroupHeaderFocus,
      densityFactor,
      headerGroupingMaxDepth,
      columnMenuState,
      columnVisibility,
      columnGroupsHeaderStructure,
      hasOtherElementInTabSequence
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
    const {
      isDragging,
      getRootProps,
      getInnerProps,
      getColumnHeaders,
      getColumnGroupHeaders
    } = useGridColumnHeaders({
      innerRef,
      visibleColumns,
      sortColumnLookup,
      filterColumnLookup,
      columnPositions,
      columnHeaderTabIndexState,
      columnGroupHeaderTabIndexState,
      columnHeaderFocus,
      columnGroupHeaderFocus,
      densityFactor,
      headerGroupingMaxDepth,
      columnMenuState,
      columnVisibility,
      columnGroupsHeaderStructure,
      hasOtherElementInTabSequence
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridBaseColumnHeaders, _extends({
      ref
    }, getRootProps(other), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnHeadersInner, _extends({
        isDragging
      }, getInnerProps(), {
        children: [getColumnGroupHeaders(), getColumnHeaders()]
      }))
    }));
  });
  const MemoizedGridColumnHeaders = fastMemo(GridColumnHeaders);
  const GridNoResultsOverlay = /* @__PURE__ */ React__namespace.forwardRef(function GridNoResultsOverlay2(props, ref) {
    const apiRef2 = useGridApiContext();
    const noResultsOverlayLabel = apiRef2.current.getLocaleText("noResultsOverlayLabel");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends({
      ref
    }, props, {
      children: noResultsOverlayLabel
    }));
  });
  const CheckBoxOutlineBlankIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
  }), "CheckBoxOutlineBlank");
  const CheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
  }), "CheckBox");
  const IndeterminateCheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
  }), "IndeterminateCheckBox");
  function getCheckboxUtilityClass(slot) {
    return generateUtilityClass("MuiCheckbox", slot);
  }
  const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
  const checkboxClasses$1 = checkboxClasses;
  const _excluded$9 = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"];
  const useUtilityClasses$6 = (ownerState) => {
    const {
      classes,
      indeterminate,
      color: color2,
      size
    } = ownerState;
    const slots = {
      root: ["root", indeterminate && "indeterminate", `color${capitalize(color2)}`, `size${capitalize(size)}`]
    };
    const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const CheckboxRoot = styled$1(SwitchBase$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.indeterminate && styles2.indeterminate, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    color: (theme.vars || theme).palette.text.secondary
  }, !ownerState.disableRipple && {
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${ownerState.color === "default" ? theme.vars.palette.action.activeChannel : theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === "default" ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }
  }, ownerState.color !== "default" && {
    [`&.${checkboxClasses$1.checked}, &.${checkboxClasses$1.indeterminate}`]: {
      color: (theme.vars || theme).palette[ownerState.color].main
    },
    [`&.${checkboxClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    }
  }));
  const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
  const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
  const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
  const Checkbox = /* @__PURE__ */ React__namespace.forwardRef(function Checkbox2(inProps, ref) {
    var _icon$props$fontSize, _indeterminateIcon$pr;
    const props = useThemeProps({
      props: inProps,
      name: "MuiCheckbox"
    });
    const {
      checkedIcon = defaultCheckedIcon,
      color: color2 = "primary",
      icon: iconProp = defaultIcon,
      indeterminate = false,
      indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
      inputProps,
      size = "medium",
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
    const icon = indeterminate ? indeterminateIconProp : iconProp;
    const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
    const ownerState = _extends({}, props, {
      color: color2,
      indeterminate,
      size
    });
    const classes = useUtilityClasses$6(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxRoot, _extends({
      type: "checkbox",
      inputProps: _extends({
        "data-indeterminate": indeterminate
      }, inputProps),
      icon: /* @__PURE__ */ React__namespace.cloneElement(icon, {
        fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size
      }),
      checkedIcon: /* @__PURE__ */ React__namespace.cloneElement(indeterminateIcon, {
        fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size
      }),
      ownerState,
      ref,
      className: clsx(classes.root, className)
    }, other, {
      classes
    }));
  });
  const MUICheckbox = Checkbox;
  function getButtonUtilityClass(slot) {
    return generateUtilityClass("MuiButton", slot);
  }
  const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
  const buttonClasses$1 = buttonClasses;
  const ButtonGroupContext = /* @__PURE__ */ React__namespace.createContext({});
  const ButtonGroupContext$1 = ButtonGroupContext;
  const _excluded$8 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
  const useUtilityClasses$5 = (ownerState) => {
    const {
      color: color2,
      disableElevation,
      fullWidth,
      size,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
      label: ["label"],
      startIcon: ["startIcon", `iconSize${capitalize(size)}`],
      endIcon: ["endIcon", `iconSize${capitalize(size)}`]
    };
    const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
    return _extends({}, classes, composedClasses);
  };
  const commonIconStyles = (ownerState) => _extends({}, ownerState.size === "small" && {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }, ownerState.size === "medium" && {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }, ownerState.size === "large" && {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  });
  const ButtonRoot = styled$1(ButtonBase$1, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$palette$getCon, _theme$palette;
    const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
    const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
    return _extends({}, theme.typography.button, {
      minWidth: 64,
      padding: "6px 16px",
      borderRadius: (theme.vars || theme).shape.borderRadius,
      transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: theme.transitions.duration.short
      }),
      "&:hover": _extends({
        textDecoration: "none",
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
        border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, ownerState.variant === "contained" && {
        backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
        boxShadow: (theme.vars || theme).shadows[4],
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          boxShadow: (theme.vars || theme).shadows[2],
          backgroundColor: (theme.vars || theme).palette.grey[300]
        }
      }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].main
        }
      }),
      "&:active": _extends({}, ownerState.variant === "contained" && {
        boxShadow: (theme.vars || theme).shadows[8]
      }),
      [`&.${buttonClasses$1.focusVisible}`]: _extends({}, ownerState.variant === "contained" && {
        boxShadow: (theme.vars || theme).shadows[6]
      }),
      [`&.${buttonClasses$1.disabled}`]: _extends({
        color: (theme.vars || theme).palette.action.disabled
      }, ownerState.variant === "outlined" && {
        border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
      }, ownerState.variant === "contained" && {
        color: (theme.vars || theme).palette.action.disabled,
        boxShadow: (theme.vars || theme).shadows[0],
        backgroundColor: (theme.vars || theme).palette.action.disabledBackground
      })
    }, ownerState.variant === "text" && {
      padding: "6px 8px"
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].main
    }, ownerState.variant === "outlined" && {
      padding: "5px 15px",
      border: "1px solid currentColor"
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].main,
      border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
    }, ownerState.variant === "contained" && {
      color: theme.vars ? (
        // this is safe because grey does not change between default light/dark mode
        theme.vars.palette.text.primary
      ) : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
      backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
      boxShadow: (theme.vars || theme).shadows[2]
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].contrastText,
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main
    }, ownerState.color === "inherit" && {
      color: "inherit",
      borderColor: "currentColor"
    }, ownerState.size === "small" && ownerState.variant === "text" && {
      padding: "4px 5px",
      fontSize: theme.typography.pxToRem(13)
    }, ownerState.size === "large" && ownerState.variant === "text" && {
      padding: "8px 11px",
      fontSize: theme.typography.pxToRem(15)
    }, ownerState.size === "small" && ownerState.variant === "outlined" && {
      padding: "3px 9px",
      fontSize: theme.typography.pxToRem(13)
    }, ownerState.size === "large" && ownerState.variant === "outlined" && {
      padding: "7px 21px",
      fontSize: theme.typography.pxToRem(15)
    }, ownerState.size === "small" && ownerState.variant === "contained" && {
      padding: "4px 10px",
      fontSize: theme.typography.pxToRem(13)
    }, ownerState.size === "large" && ownerState.variant === "contained" && {
      padding: "8px 22px",
      fontSize: theme.typography.pxToRem(15)
    }, ownerState.fullWidth && {
      width: "100%"
    });
  }, ({
    ownerState
  }) => ownerState.disableElevation && {
    boxShadow: "none",
    "&:hover": {
      boxShadow: "none"
    },
    [`&.${buttonClasses$1.focusVisible}`]: {
      boxShadow: "none"
    },
    "&:active": {
      boxShadow: "none"
    },
    [`&.${buttonClasses$1.disabled}`]: {
      boxShadow: "none"
    }
  });
  const ButtonStartIcon = styled$1("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
    }
  })(({
    ownerState
  }) => _extends({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4
  }, ownerState.size === "small" && {
    marginLeft: -2
  }, commonIconStyles(ownerState)));
  const ButtonEndIcon = styled$1("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
    }
  })(({
    ownerState
  }) => _extends({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8
  }, ownerState.size === "small" && {
    marginRight: -2
  }, commonIconStyles(ownerState)));
  const Button = /* @__PURE__ */ React__namespace.forwardRef(function Button2(inProps, ref) {
    const contextProps = React__namespace.useContext(ButtonGroupContext$1);
    const resolvedProps = resolveProps(contextProps, inProps);
    const props = useThemeProps({
      props: resolvedProps,
      name: "MuiButton"
    });
    const {
      children,
      color: color2 = "primary",
      component = "button",
      className,
      disabled = false,
      disableElevation = false,
      disableFocusRipple = false,
      endIcon: endIconProp,
      focusVisibleClassName,
      fullWidth = false,
      size = "medium",
      startIcon: startIconProp,
      type,
      variant = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
    const ownerState = _extends({}, props, {
      color: color2,
      component,
      disabled,
      disableElevation,
      disableFocusRipple,
      fullWidth,
      size,
      type,
      variant
    });
    const classes = useUtilityClasses$5(ownerState);
    const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
      className: classes.startIcon,
      ownerState,
      children: startIconProp
    });
    const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
      className: classes.endIcon,
      ownerState,
      children: endIconProp
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends({
      ownerState,
      className: clsx(contextProps.className, classes.root, className),
      component,
      disabled,
      focusRipple: !disableFocusRipple,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ref,
      type
    }, other, {
      classes,
      children: [startIcon, children, endIcon]
    }));
  });
  const MUIButton = Button;
  function getInputAdornmentUtilityClass(slot) {
    return generateUtilityClass("MuiInputAdornment", slot);
  }
  const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
  const inputAdornmentClasses$1 = inputAdornmentClasses;
  var _span;
  const _excluded$7 = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
  const overridesResolver = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
  };
  const useUtilityClasses$4 = (ownerState) => {
    const {
      classes,
      disablePointerEvents,
      hiddenLabel,
      position: position2,
      size,
      variant
    } = ownerState;
    const slots = {
      root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize(size)}`]
    };
    return composeClasses(slots, getInputAdornmentUtilityClass, classes);
  };
  const InputAdornmentRoot = styled$1("div", {
    name: "MuiInputAdornment",
    slot: "Root",
    overridesResolver
  })(({
    theme,
    ownerState
  }) => _extends({
    display: "flex",
    height: "0.01em",
    // Fix IE11 flexbox alignment. To remove at some point.
    maxHeight: "2em",
    alignItems: "center",
    whiteSpace: "nowrap",
    color: (theme.vars || theme).palette.action.active
  }, ownerState.variant === "filled" && {
    // Styles applied to the root element if `variant="filled"`.
    [`&.${inputAdornmentClasses$1.positionStart}&:not(.${inputAdornmentClasses$1.hiddenLabel})`]: {
      marginTop: 16
    }
  }, ownerState.position === "start" && {
    // Styles applied to the root element if `position="start"`.
    marginRight: 8
  }, ownerState.position === "end" && {
    // Styles applied to the root element if `position="end"`.
    marginLeft: 8
  }, ownerState.disablePointerEvents === true && {
    // Styles applied to the root element if `disablePointerEvents={true}`.
    pointerEvents: "none"
  }));
  const InputAdornment = /* @__PURE__ */ React__namespace.forwardRef(function InputAdornment2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiInputAdornment"
    });
    const {
      children,
      className,
      component = "div",
      disablePointerEvents = false,
      disableTypography = false,
      position: position2,
      variant: variantProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
    const muiFormControl = useFormControl() || {};
    let variant = variantProp;
    if (variantProp && muiFormControl.variant)
      ;
    if (muiFormControl && !variant) {
      variant = muiFormControl.variant;
    }
    const ownerState = _extends({}, props, {
      hiddenLabel: muiFormControl.hiddenLabel,
      size: muiFormControl.size,
      disablePointerEvents,
      position: position2,
      variant
    });
    const classes = useUtilityClasses$4(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
      value: null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, _extends({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
          color: "text.secondary",
          children
        }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
          children: [position2 === "start" ? (
            /* notranslate needed while Google Translate will not fix zero-width space issue */
            _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: "​"
            }))
          ) : null, children]
        })
      }))
    });
  });
  const MUIInputAdornment = InputAdornment;
  function getTooltipUtilityClass(slot) {
    return generateUtilityClass("MuiTooltip", slot);
  }
  const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
  const tooltipClasses$1 = tooltipClasses;
  const _excluded$6 = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
  function round(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  const useUtilityClasses$3 = (ownerState) => {
    const {
      classes,
      disableInteractive,
      arrow: arrow2,
      touch,
      placement
    } = ownerState;
    const slots = {
      popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
      tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
      arrow: ["arrow"]
    };
    return composeClasses(slots, getTooltipUtilityClass, classes);
  };
  const TooltipPopper = styled$1(MUIPopper, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
    }
  })(({
    theme,
    ownerState,
    open
  }) => _extends({
    zIndex: (theme.vars || theme).zIndex.tooltip,
    pointerEvents: "none"
  }, !ownerState.disableInteractive && {
    pointerEvents: "auto"
  }, !open && {
    pointerEvents: "none"
  }, ownerState.arrow && {
    [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
      top: 0,
      marginTop: "-0.71em",
      "&::before": {
        transformOrigin: "0 100%"
      }
    },
    [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
      bottom: 0,
      marginBottom: "-0.71em",
      "&::before": {
        transformOrigin: "100% 0"
      }
    },
    [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]: _extends({}, !ownerState.isRtl ? {
      left: 0,
      marginLeft: "-0.71em"
    } : {
      right: 0,
      marginRight: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "100% 100%"
      }
    }),
    [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]: _extends({}, !ownerState.isRtl ? {
      right: 0,
      marginRight: "-0.71em"
    } : {
      left: 0,
      marginLeft: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "0 0"
      }
    })
  }));
  const TooltipTooltip = styled$1("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends({
    backgroundColor: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.92),
    borderRadius: (theme.vars || theme).shape.borderRadius,
    color: (theme.vars || theme).palette.common.white,
    fontFamily: theme.typography.fontFamily,
    padding: "4px 8px",
    fontSize: theme.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: "break-word",
    fontWeight: theme.typography.fontWeightMedium
  }, ownerState.arrow && {
    position: "relative",
    margin: 0
  }, ownerState.touch && {
    padding: "8px 16px",
    fontSize: theme.typography.pxToRem(14),
    lineHeight: `${round(16 / 14)}em`,
    fontWeight: theme.typography.fontWeightRegular
  }, {
    [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]: _extends({
      transformOrigin: "right center"
    }, !ownerState.isRtl ? _extends({
      marginRight: "14px"
    }, ownerState.touch && {
      marginRight: "24px"
    }) : _extends({
      marginLeft: "14px"
    }, ownerState.touch && {
      marginLeft: "24px"
    })),
    [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]: _extends({
      transformOrigin: "left center"
    }, !ownerState.isRtl ? _extends({
      marginLeft: "14px"
    }, ownerState.touch && {
      marginLeft: "24px"
    }) : _extends({
      marginRight: "14px"
    }, ownerState.touch && {
      marginRight: "24px"
    })),
    [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]: _extends({
      transformOrigin: "center bottom",
      marginBottom: "14px"
    }, ownerState.touch && {
      marginBottom: "24px"
    }),
    [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]: _extends({
      transformOrigin: "center top",
      marginTop: "14px"
    }, ownerState.touch && {
      marginTop: "24px"
    })
  }));
  const TooltipArrow = styled$1("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (props, styles2) => styles2.arrow
  })(({
    theme
  }) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.9),
    "&::before": {
      content: '""',
      margin: "auto",
      display: "block",
      width: "100%",
      height: "100%",
      backgroundColor: "currentColor",
      transform: "rotate(45deg)"
    }
  }));
  let hystersisOpen = false;
  let hystersisTimer = null;
  let cursorPosition = {
    x: 0,
    y: 0
  };
  function composeEventHandler(handler, eventHandler) {
    return (event) => {
      if (eventHandler) {
        eventHandler(event);
      }
      handler(event);
    };
  }
  const Tooltip = /* @__PURE__ */ React__namespace.forwardRef(function Tooltip2(inProps, ref) {
    var _ref, _slots$popper, _ref2, _ref3, _slots$transition, _ref4, _slots$tooltip, _ref5, _slots$arrow, _slotProps$popper, _ref6, _slotProps$popper2, _slotProps$transition, _slotProps$tooltip, _ref7, _slotProps$tooltip2, _slotProps$arrow, _ref8, _slotProps$arrow2;
    const props = useThemeProps({
      props: inProps,
      name: "MuiTooltip"
    });
    const {
      arrow: arrow2 = false,
      children: childrenProp,
      components = {},
      componentsProps = {},
      describeChild = false,
      disableFocusListener = false,
      disableHoverListener = false,
      disableInteractive: disableInteractiveProp = false,
      disableTouchListener = false,
      enterDelay = 100,
      enterNextDelay = 0,
      enterTouchDelay = 700,
      followCursor = false,
      id: idProp,
      leaveDelay = 0,
      leaveTouchDelay = 1500,
      onClose,
      onOpen,
      open: openProp,
      placement = "bottom",
      PopperComponent: PopperComponentProp,
      PopperProps = {},
      slotProps = {},
      slots = {},
      title,
      TransitionComponent: TransitionComponentProp = Grow$1,
      TransitionProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
    const children = /* @__PURE__ */ React__namespace.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      children: childrenProp
    });
    const theme = useTheme();
    const isRtl = theme.direction === "rtl";
    const [childNode, setChildNode] = React__namespace.useState();
    const [arrowRef, setArrowRef] = React__namespace.useState(null);
    const ignoreNonTouchEvents = React__namespace.useRef(false);
    const disableInteractive = disableInteractiveProp || followCursor;
    const closeTimer = React__namespace.useRef();
    const enterTimer = React__namespace.useRef();
    const leaveTimer = React__namespace.useRef();
    const touchTimer = React__namespace.useRef();
    const [openState, setOpenState] = useControlled({
      controlled: openProp,
      default: false,
      name: "Tooltip",
      state: "open"
    });
    let open = openState;
    const id = useId(idProp);
    const prevUserSelect = React__namespace.useRef();
    const stopTouchInteraction = React__namespace.useCallback(() => {
      if (prevUserSelect.current !== void 0) {
        document.body.style.WebkitUserSelect = prevUserSelect.current;
        prevUserSelect.current = void 0;
      }
      clearTimeout(touchTimer.current);
    }, []);
    React__namespace.useEffect(() => {
      return () => {
        clearTimeout(closeTimer.current);
        clearTimeout(enterTimer.current);
        clearTimeout(leaveTimer.current);
        stopTouchInteraction();
      };
    }, [stopTouchInteraction]);
    const handleOpen = (event) => {
      clearTimeout(hystersisTimer);
      hystersisOpen = true;
      setOpenState(true);
      if (onOpen && !open) {
        onOpen(event);
      }
    };
    const handleClose = useEventCallback(
      /**
       * @param {React.SyntheticEvent | Event} event
       */
      (event) => {
        clearTimeout(hystersisTimer);
        hystersisTimer = setTimeout(() => {
          hystersisOpen = false;
        }, 800 + leaveDelay);
        setOpenState(false);
        if (onClose && open) {
          onClose(event);
        }
        clearTimeout(closeTimer.current);
        closeTimer.current = setTimeout(() => {
          ignoreNonTouchEvents.current = false;
        }, theme.transitions.duration.shortest);
      }
    );
    const handleEnter = (event) => {
      if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
        return;
      }
      if (childNode) {
        childNode.removeAttribute("title");
      }
      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);
      if (enterDelay || hystersisOpen && enterNextDelay) {
        enterTimer.current = setTimeout(() => {
          handleOpen(event);
        }, hystersisOpen ? enterNextDelay : enterDelay);
      } else {
        handleOpen(event);
      }
    };
    const handleLeave = (event) => {
      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);
      leaveTimer.current = setTimeout(() => {
        handleClose(event);
      }, leaveDelay);
    };
    const {
      isFocusVisibleRef,
      onBlur: handleBlurVisible,
      onFocus: handleFocusVisible,
      ref: focusVisibleRef
    } = useIsFocusVisible();
    const [, setChildIsFocusVisible] = React__namespace.useState(false);
    const handleBlur = (event) => {
      handleBlurVisible(event);
      if (isFocusVisibleRef.current === false) {
        setChildIsFocusVisible(false);
        handleLeave(event);
      }
    };
    const handleFocus = (event) => {
      if (!childNode) {
        setChildNode(event.currentTarget);
      }
      handleFocusVisible(event);
      if (isFocusVisibleRef.current === true) {
        setChildIsFocusVisible(true);
        handleEnter(event);
      }
    };
    const detectTouchStart = (event) => {
      ignoreNonTouchEvents.current = true;
      const childrenProps2 = children.props;
      if (childrenProps2.onTouchStart) {
        childrenProps2.onTouchStart(event);
      }
    };
    const handleMouseOver = handleEnter;
    const handleMouseLeave = handleLeave;
    const handleTouchStart = (event) => {
      detectTouchStart(event);
      clearTimeout(leaveTimer.current);
      clearTimeout(closeTimer.current);
      stopTouchInteraction();
      prevUserSelect.current = document.body.style.WebkitUserSelect;
      document.body.style.WebkitUserSelect = "none";
      touchTimer.current = setTimeout(() => {
        document.body.style.WebkitUserSelect = prevUserSelect.current;
        handleEnter(event);
      }, enterTouchDelay);
    };
    const handleTouchEnd = (event) => {
      if (children.props.onTouchEnd) {
        children.props.onTouchEnd(event);
      }
      stopTouchInteraction();
      clearTimeout(leaveTimer.current);
      leaveTimer.current = setTimeout(() => {
        handleClose(event);
      }, leaveTouchDelay);
    };
    React__namespace.useEffect(() => {
      if (!open) {
        return void 0;
      }
      function handleKeyDown2(nativeEvent) {
        if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
          handleClose(nativeEvent);
        }
      }
      document.addEventListener("keydown", handleKeyDown2);
      return () => {
        document.removeEventListener("keydown", handleKeyDown2);
      };
    }, [handleClose, open]);
    const handleRef = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);
    if (!title && title !== 0) {
      open = false;
    }
    const popperRef = React__namespace.useRef();
    const handleMouseMove = (event) => {
      const childrenProps2 = children.props;
      if (childrenProps2.onMouseMove) {
        childrenProps2.onMouseMove(event);
      }
      cursorPosition = {
        x: event.clientX,
        y: event.clientY
      };
      if (popperRef.current) {
        popperRef.current.update();
      }
    };
    const nameOrDescProps = {};
    const titleIsString = typeof title === "string";
    if (describeChild) {
      nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
      nameOrDescProps["aria-describedby"] = open ? id : null;
    } else {
      nameOrDescProps["aria-label"] = titleIsString ? title : null;
      nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id : null;
    }
    const childrenProps = _extends({}, nameOrDescProps, other, children.props, {
      className: clsx(other.className, children.props.className),
      onTouchStart: detectTouchStart,
      ref: handleRef
    }, followCursor ? {
      onMouseMove: handleMouseMove
    } : {});
    const interactiveWrapperListeners = {};
    if (!disableTouchListener) {
      childrenProps.onTouchStart = handleTouchStart;
      childrenProps.onTouchEnd = handleTouchEnd;
    }
    if (!disableHoverListener) {
      childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
      childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
      if (!disableInteractive) {
        interactiveWrapperListeners.onMouseOver = handleMouseOver;
        interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
      }
    }
    if (!disableFocusListener) {
      childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
      childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
      if (!disableInteractive) {
        interactiveWrapperListeners.onFocus = handleFocus;
        interactiveWrapperListeners.onBlur = handleBlur;
      }
    }
    const popperOptions = React__namespace.useMemo(() => {
      var _PopperProps$popperOp;
      let tooltipModifiers = [{
        name: "arrow",
        enabled: Boolean(arrowRef),
        options: {
          element: arrowRef,
          padding: 4
        }
      }];
      if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
        tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
      }
      return _extends({}, PopperProps.popperOptions, {
        modifiers: tooltipModifiers
      });
    }, [arrowRef, PopperProps]);
    const ownerState = _extends({}, props, {
      isRtl,
      arrow: arrow2,
      disableInteractive,
      placement,
      PopperComponentProp,
      touch: ignoreNonTouchEvents.current
    });
    const classes = useUtilityClasses$3(ownerState);
    const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
    const TransitionComponent = (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow$1;
    const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
    const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
    const popperProps = appendOwnerState(PopperComponent, _extends({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
      className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className)
    }), ownerState);
    const transitionProps = appendOwnerState(TransitionComponent, _extends({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition), ownerState);
    const tooltipProps = appendOwnerState(TooltipComponent, _extends({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
      className: clsx(classes.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className)
    }), ownerState);
    const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
      className: clsx(classes.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className)
    }), ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React__namespace.Fragment, {
      children: [/* @__PURE__ */ React__namespace.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperComponent, _extends({
        as: PopperComponentProp != null ? PopperComponentProp : MUIPopper,
        placement,
        anchorEl: followCursor ? {
          getBoundingClientRect: () => ({
            top: cursorPosition.y,
            left: cursorPosition.x,
            right: cursorPosition.x,
            bottom: cursorPosition.y,
            width: 0,
            height: 0
          })
        } : childNode,
        popperRef,
        open: childNode ? open : false,
        id,
        transition: true
      }, interactiveWrapperListeners, popperProps, {
        popperOptions,
        children: ({
          TransitionProps: TransitionPropsInner
        }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
          timeout: theme.transitions.duration.shorter
        }, TransitionPropsInner, transitionProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipComponent, _extends({}, tooltipProps, {
            children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowComponent, _extends({}, tooltipArrowProps, {
              ref: setArrowRef
            })) : null]
          }))
        }))
      }))]
    });
  });
  const MUITooltip = Tooltip;
  const _excluded$5 = ["sortingOrder"];
  const GridColumnUnsortedIcon = /* @__PURE__ */ React__namespace.memo(function GridColumnHeaderSortIcon2(props) {
    const {
      sortingOrder
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
    const rootProps = useGridRootProps();
    const [nextSortDirection] = sortingOrder;
    const Icon = nextSortDirection === "asc" ? rootProps.slots.columnSortedAscendingIcon : rootProps.slots.columnSortedDescendingIcon;
    return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends({}, other)) : null;
  });
  const _excluded$4 = ["native"];
  function MUISelectOption(_ref) {
    let {
      native
    } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$4);
    if (native) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("option", _extends({}, props));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MUIMenuItem, _extends({}, props));
  }
  const iconSlots = {
    BooleanCellTrueIcon: GridCheckIcon,
    BooleanCellFalseIcon: GridCloseIcon,
    ColumnMenuIcon: GridTripleDotsVerticalIcon,
    OpenFilterButtonIcon: GridFilterListIcon,
    FilterPanelDeleteIcon: GridCloseIcon,
    ColumnFilteredIcon: GridFilterAltIcon,
    ColumnSelectorIcon: GridColumnIcon,
    ColumnUnsortedIcon: GridColumnUnsortedIcon,
    ColumnSortedAscendingIcon: GridArrowUpwardIcon,
    ColumnSortedDescendingIcon: GridArrowDownwardIcon,
    ColumnResizeIcon: GridSeparatorIcon,
    DensityCompactIcon: GridViewHeadlineIcon,
    DensityStandardIcon: GridTableRowsIcon,
    DensityComfortableIcon: GridViewStreamIcon,
    ExportIcon: GridSaveAltIcon,
    MoreActionsIcon: GridMoreVertIcon,
    TreeDataCollapseIcon: GridExpandMoreIcon,
    TreeDataExpandIcon: GridKeyboardArrowRight,
    GroupingCriteriaCollapseIcon: GridExpandMoreIcon,
    GroupingCriteriaExpandIcon: GridKeyboardArrowRight,
    DetailPanelExpandIcon: GridAddIcon,
    DetailPanelCollapseIcon: GridRemoveIcon,
    RowReorderIcon: GridDragIcon,
    QuickFilterIcon: GridSearchIcon,
    QuickFilterClearIcon: GridCloseIcon,
    ColumnMenuHideIcon: GridVisibilityOffIcon,
    ColumnMenuSortAscendingIcon: GridArrowUpwardIcon,
    ColumnMenuSortDescendingIcon: GridArrowDownwardIcon,
    ColumnMenuFilterIcon: GridFilterAltIcon,
    ColumnMenuManageColumnsIcon: GridViewColumnIcon,
    ColumnMenuClearIcon: GridClearIcon,
    LoadIcon: GridLoadIcon,
    FilterPanelAddIcon: GridAddIcon,
    FilterPanelRemoveAllIcon: GridDeleteForeverIcon,
    ColumnReorderIcon: GridDragIcon
  };
  const materialSlots = _extends({}, iconSlots, {
    BaseCheckbox: MUICheckbox,
    BaseTextField: MUITextField,
    BaseFormControl: MUIFormControl,
    BaseSelect: MUISelect,
    BaseSwitch: MUISwitch,
    BaseButton: MUIButton,
    BaseIconButton: MUIIconButton,
    BaseInputAdornment: MUIInputAdornment,
    BaseTooltip: MUITooltip,
    BasePopper: MUIPopper,
    BaseInputLabel: MUIInputLabel,
    BaseSelectOption: MUISelectOption,
    BaseChip: MUIChip
  });
  const materialSlots$1 = materialSlots;
  const DATA_GRID_DEFAULT_SLOTS_COMPONENTS = _extends({}, materialSlots$1, {
    Cell: MemoizedGridCellV7,
    SkeletonCell: GridSkeletonCell,
    ColumnHeaderFilterIconButton: GridColumnHeaderFilterIconButton,
    ColumnMenu: GridColumnMenu,
    ColumnHeaders: MemoizedGridColumnHeaders,
    Footer: GridFooter,
    Toolbar: null,
    PreferencesPanel: GridPreferencesPanel,
    LoadingOverlay: GridLoadingOverlay,
    NoResultsOverlay: GridNoResultsOverlay,
    NoRowsOverlay: GridNoRowsOverlay,
    Pagination: GridPagination,
    FilterPanel: GridFilterPanel,
    ColumnsPanel: GridColumnsPanel,
    Panel: GridPanel,
    Row: MemoizedGridRow
  });
  const uncapitalizeObjectKeys = (capitalizedObject) => {
    if (capitalizedObject === void 0) {
      return void 0;
    }
    return Object.keys(capitalizedObject).reduce((acc, key) => _extends({}, acc, {
      [`${key.charAt(0).toLowerCase()}${key.slice(1)}`]: capitalizedObject[key]
    }), {});
  };
  function computeSlots({
    defaultSlots: defaultSlots2,
    slots,
    components
  }) {
    const overrides = slots != null ? slots : components ? uncapitalizeObjectKeys(components) : null;
    if (!overrides || Object.keys(overrides).length === 0) {
      return defaultSlots2;
    }
    return _extends({}, defaultSlots2, overrides);
  }
  const _excluded$3 = ["components", "componentsProps"];
  function groupForwardedProps(props) {
    var _props$forwardedProps;
    const keys = Object.keys(props);
    if (!keys.some((key) => key.startsWith("aria-") || key.startsWith("data-"))) {
      return props;
    }
    const newProps = {};
    const forwardedProps = (_props$forwardedProps = props.forwardedProps) != null ? _props$forwardedProps : {};
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (key.startsWith("aria-") || key.startsWith("data-")) {
        forwardedProps[key] = props[key];
      } else {
        newProps[key] = props[key];
      }
    }
    newProps.forwardedProps = forwardedProps;
    return newProps;
  }
  function useProps(allProps) {
    return React__namespace.useMemo(() => {
      const {
        components,
        componentsProps
      } = allProps, themedProps = _objectWithoutPropertiesLoose(allProps, _excluded$3);
      return [components, componentsProps, groupForwardedProps(themedProps)];
    }, [allProps]);
  }
  const DATA_GRID_FORCED_PROPS = {
    disableMultipleColumnsFiltering: true,
    disableMultipleColumnsSorting: true,
    disableMultipleRowSelection: true,
    throttleRowsMs: void 0,
    hideFooterRowCount: false,
    pagination: true,
    checkboxSelectionVisibleOnly: false,
    disableColumnReorder: true,
    disableColumnResize: true,
    keepColumnPositionIfDraggedOutside: false,
    signature: "DataGrid"
  };
  const DATA_GRID_PROPS_DEFAULT_VALUES = {
    autoHeight: false,
    autoPageSize: false,
    checkboxSelection: false,
    checkboxSelectionVisibleOnly: false,
    columnBuffer: 3,
    rowBuffer: 3,
    columnThreshold: 3,
    rowThreshold: 3,
    rowSelection: true,
    density: "standard",
    disableColumnFilter: false,
    disableColumnMenu: false,
    disableColumnSelector: false,
    disableDensitySelector: false,
    disableEval: false,
    disableMultipleColumnsFiltering: false,
    disableMultipleRowSelection: false,
    disableMultipleColumnsSorting: false,
    disableRowSelectionOnClick: false,
    disableVirtualization: false,
    editMode: GridEditModes.Cell,
    filterMode: "client",
    filterDebounceMs: 150,
    columnHeaderHeight: 56,
    hideFooter: false,
    hideFooterPagination: false,
    hideFooterRowCount: false,
    hideFooterSelectedRowCount: false,
    logger: console,
    logLevel: "error",
    pagination: false,
    paginationMode: "client",
    rowHeight: 52,
    pageSizeOptions: [25, 50, 100],
    rowSpacingType: "margin",
    showCellVerticalBorder: false,
    showColumnVerticalBorder: false,
    sortingOrder: ["asc", "desc", null],
    sortingMode: "client",
    throttleRowsMs: 0,
    disableColumnReorder: false,
    disableColumnResize: false,
    keepNonExistentRowsSelected: false,
    keepColumnPositionIfDraggedOutside: false,
    unstable_ignoreValueFormatterDuringExport: false,
    clipboardCopyCellDelimiter: "	"
  };
  const defaultSlots = uncapitalizeObjectKeys(DATA_GRID_DEFAULT_SLOTS_COMPONENTS);
  const useDataGridProps = (inProps) => {
    const [components, componentsProps, themedProps] = useProps(useThemeProps({
      props: inProps,
      name: "MuiDataGrid"
    }));
    const localeText = React__namespace.useMemo(() => _extends({}, GRID_DEFAULT_LOCALE_TEXT, themedProps.localeText), [themedProps.localeText]);
    const slots = React__namespace.useMemo(() => computeSlots({
      defaultSlots,
      slots: themedProps.slots,
      components
    }), [components, themedProps.slots]);
    return React__namespace.useMemo(() => {
      var _themedProps$slotProp;
      return _extends({}, DATA_GRID_PROPS_DEFAULT_VALUES, themedProps, {
        localeText,
        slots,
        slotProps: (_themedProps$slotProp = themedProps.slotProps) != null ? _themedProps$slotProp : componentsProps
      }, DATA_GRID_FORCED_PROPS);
    }, [themedProps, localeText, slots, componentsProps]);
  };
  const rowsMetaStateInitializer = (state) => _extends({}, state, {
    rowsMeta: {
      currentPageTotalHeight: 0,
      positions: []
    }
  });
  const getValidRowHeight = (rowHeightProp, defaultRowHeight, warningMessage) => {
    if (typeof rowHeightProp === "number" && rowHeightProp > 0) {
      return rowHeightProp;
    }
    return defaultRowHeight;
  };
  const useGridRowsMeta = (apiRef2, props) => {
    const {
      getRowHeight: getRowHeightProp,
      getRowSpacing,
      getEstimatedRowHeight
    } = props;
    const rowsHeightLookup = React__namespace.useRef(/* @__PURE__ */ Object.create(null));
    const lastMeasuredRowIndex = React__namespace.useRef(-1);
    const hasRowWithAutoHeight = React__namespace.useRef(false);
    const densityFactor = useGridSelector(apiRef2, gridDensityFactorSelector);
    const filterModel2 = useGridSelector(apiRef2, gridFilterModelSelector);
    const paginationState = useGridSelector(apiRef2, gridPaginationSelector);
    const sortModel = useGridSelector(apiRef2, gridSortModelSelector);
    const currentPage = useGridVisibleRows(apiRef2, props);
    const pinnedRows = useGridSelector(apiRef2, gridPinnedRowsSelector);
    const validRowHeight = getValidRowHeight(props.rowHeight, DATA_GRID_PROPS_DEFAULT_VALUES.rowHeight);
    const rowHeight = Math.floor(validRowHeight * densityFactor);
    const hydrateRowsMeta = React__namespace.useCallback(() => {
      var _pinnedRows$top, _pinnedRows$bottom;
      hasRowWithAutoHeight.current = false;
      const calculateRowProcessedSizes = (row) => {
        if (!rowsHeightLookup.current[row.id]) {
          rowsHeightLookup.current[row.id] = {
            sizes: {
              baseCenter: rowHeight
            },
            isResized: false,
            autoHeight: false,
            needsFirstMeasurement: true
            // Assume all rows will need to be measured by default
          };
        }
        const {
          isResized,
          needsFirstMeasurement,
          sizes
        } = rowsHeightLookup.current[row.id];
        let baseRowHeight = typeof rowHeight === "number" && rowHeight > 0 ? rowHeight : 52;
        const existingBaseRowHeight = sizes.baseCenter;
        if (isResized) {
          baseRowHeight = existingBaseRowHeight;
        } else if (getRowHeightProp) {
          const rowHeightFromUser = getRowHeightProp(_extends({}, row, {
            densityFactor
          }));
          if (rowHeightFromUser === "auto") {
            if (needsFirstMeasurement) {
              const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {
                densityFactor
              })) : rowHeight;
              baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeight;
            } else {
              baseRowHeight = existingBaseRowHeight;
            }
            hasRowWithAutoHeight.current = true;
            rowsHeightLookup.current[row.id].autoHeight = true;
          } else {
            baseRowHeight = getValidRowHeight(rowHeightFromUser, rowHeight);
            rowsHeightLookup.current[row.id].needsFirstMeasurement = false;
            rowsHeightLookup.current[row.id].autoHeight = false;
          }
        } else {
          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;
        }
        const initialHeights = {};
        for (const key in sizes) {
          if (/^base[A-Z]/.test(key)) {
            initialHeights[key] = sizes[key];
          }
        }
        initialHeights.baseCenter = baseRowHeight;
        if (getRowSpacing) {
          var _spacing$top, _spacing$bottom;
          const indexRelativeToCurrentPage = apiRef2.current.getRowIndexRelativeToVisibleRows(row.id);
          const spacing = getRowSpacing(_extends({}, row, {
            isFirstVisible: indexRelativeToCurrentPage === 0,
            isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,
            indexRelativeToCurrentPage
          }));
          initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;
          initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;
        }
        const processedSizes = apiRef2.current.unstable_applyPipeProcessors("rowHeight", initialHeights, row);
        rowsHeightLookup.current[row.id].sizes = processedSizes;
        return processedSizes;
      };
      const positions = [];
      const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {
        positions.push(acc);
        let maximumBaseSize = 0;
        let otherSizes = 0;
        const processedSizes = calculateRowProcessedSizes(row);
        for (const key in processedSizes) {
          const value = processedSizes[key];
          if (/^base[A-Z]/.test(key)) {
            maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;
          } else {
            otherSizes += value;
          }
        }
        return acc + maximumBaseSize + otherSizes;
      }, 0);
      pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach((row) => {
        calculateRowProcessedSizes(row);
      });
      pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach((row) => {
        calculateRowProcessedSizes(row);
      });
      apiRef2.current.setState((state) => {
        return _extends({}, state, {
          rowsMeta: {
            currentPageTotalHeight,
            positions
          }
        });
      });
      if (!hasRowWithAutoHeight.current) {
        lastMeasuredRowIndex.current = Infinity;
      }
      apiRef2.current.forceUpdate();
    }, [apiRef2, currentPage.rows, rowHeight, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows, densityFactor]);
    const getRowHeight = React__namespace.useCallback((rowId) => {
      const height2 = rowsHeightLookup.current[rowId];
      return height2 ? height2.sizes.baseCenter : rowHeight;
    }, [rowHeight]);
    const getRowInternalSizes = (rowId) => {
      var _rowsHeightLookup$cur;
      return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;
    };
    const setRowHeight = React__namespace.useCallback((id, height2) => {
      rowsHeightLookup.current[id].sizes.baseCenter = height2;
      rowsHeightLookup.current[id].isResized = true;
      rowsHeightLookup.current[id].needsFirstMeasurement = false;
      hydrateRowsMeta();
    }, [hydrateRowsMeta]);
    const debouncedHydrateRowsMeta = React__namespace.useMemo(() => debounce$1(hydrateRowsMeta), [hydrateRowsMeta]);
    const storeMeasuredRowHeight = React__namespace.useCallback((id, height2, position2) => {
      if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {
        return;
      }
      const needsHydration = rowsHeightLookup.current[id].sizes[`base${capitalize(position2)}`] !== height2;
      rowsHeightLookup.current[id].needsFirstMeasurement = false;
      rowsHeightLookup.current[id].sizes[`base${capitalize(position2)}`] = height2;
      if (needsHydration) {
        debouncedHydrateRowsMeta();
      }
    }, [debouncedHydrateRowsMeta]);
    const rowHasAutoHeight = React__namespace.useCallback((id) => {
      var _rowsHeightLookup$cur2;
      return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;
    }, []);
    const getLastMeasuredRowIndex = React__namespace.useCallback(() => {
      return lastMeasuredRowIndex.current;
    }, []);
    const setLastMeasuredRowIndex = React__namespace.useCallback((index) => {
      if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {
        lastMeasuredRowIndex.current = index;
      }
    }, []);
    const resetRowHeights = React__namespace.useCallback(() => {
      rowsHeightLookup.current = {};
      hydrateRowsMeta();
    }, [hydrateRowsMeta]);
    React__namespace.useEffect(() => {
      hydrateRowsMeta();
    }, [rowHeight, filterModel2, paginationState, sortModel, hydrateRowsMeta]);
    useGridRegisterPipeApplier(apiRef2, "rowHeight", hydrateRowsMeta);
    const rowsMetaApi = {
      unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,
      unstable_getRowHeight: getRowHeight,
      unstable_getRowInternalSizes: getRowInternalSizes,
      unstable_setRowHeight: setRowHeight,
      unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,
      resetRowHeights
    };
    const rowsMetaPrivateApi = {
      getLastMeasuredRowIndex,
      rowHasAutoHeight
    };
    useGridApiMethod(apiRef2, rowsMetaApi, "public");
    useGridApiMethod(apiRef2, rowsMetaPrivateApi, "private");
  };
  const useGridStatePersistence = (apiRef2) => {
    const exportState = React__namespace.useCallback((params = {}) => {
      const stateToExport = apiRef2.current.unstable_applyPipeProcessors("exportState", {}, params);
      return stateToExport;
    }, [apiRef2]);
    const restoreState = React__namespace.useCallback((stateToRestore) => {
      const response = apiRef2.current.unstable_applyPipeProcessors("restoreState", {
        callbacks: []
      }, {
        stateToRestore
      });
      response.callbacks.forEach((callback) => {
        callback();
      });
      apiRef2.current.forceUpdate();
    }, [apiRef2]);
    const statePersistenceApi = {
      exportState,
      restoreState
    };
    useGridApiMethod(apiRef2, statePersistenceApi, "public");
  };
  const useGridColumnSpanning = (apiRef2) => {
    const lookup = React__namespace.useRef({});
    const setCellColSpanInfo = React__namespace.useCallback((rowId, columnIndex, cellColSpanInfo) => {
      const sizes = lookup.current;
      if (!sizes[rowId]) {
        sizes[rowId] = {};
      }
      sizes[rowId][columnIndex] = cellColSpanInfo;
    }, []);
    const getCellColSpanInfo = React__namespace.useCallback((rowId, columnIndex) => {
      var _lookup$current$rowId;
      return (_lookup$current$rowId = lookup.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];
    }, []);
    const calculateCellColSpan = React__namespace.useCallback((params) => {
      const {
        columnIndex,
        rowId,
        minFirstColumnIndex,
        maxLastColumnIndex,
        columns
      } = params;
      const columnsLength = columns.length;
      const column2 = columns[columnIndex];
      const colSpan = typeof column2.colSpan === "function" ? column2.colSpan(apiRef2.current.getCellParams(rowId, column2.field)) : column2.colSpan;
      if (!colSpan || colSpan === 1) {
        setCellColSpanInfo(rowId, columnIndex, {
          spannedByColSpan: false,
          cellProps: {
            colSpan: 1,
            width: column2.computedWidth
          }
        });
        return {
          colSpan: 1
        };
      }
      let width2 = column2.computedWidth;
      for (let j = 1; j < colSpan; j += 1) {
        const nextColumnIndex = columnIndex + j;
        if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {
          const nextColumn = columns[nextColumnIndex];
          width2 += nextColumn.computedWidth;
          setCellColSpanInfo(rowId, columnIndex + j, {
            spannedByColSpan: true,
            rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),
            leftVisibleCellIndex: columnIndex
          });
        }
        setCellColSpanInfo(rowId, columnIndex, {
          spannedByColSpan: false,
          cellProps: {
            colSpan,
            width: width2
          }
        });
      }
      return {
        colSpan
      };
    }, [apiRef2, setCellColSpanInfo]);
    const calculateColSpan = React__namespace.useCallback(({
      rowId,
      minFirstColumn,
      maxLastColumn,
      columns
    }) => {
      for (let i = minFirstColumn; i < maxLastColumn; i += 1) {
        const cellProps = calculateCellColSpan({
          columnIndex: i,
          rowId,
          minFirstColumnIndex: minFirstColumn,
          maxLastColumnIndex: maxLastColumn,
          columns
        });
        if (cellProps.colSpan > 1) {
          i += cellProps.colSpan - 1;
        }
      }
    }, [calculateCellColSpan]);
    const columnSpanningPublicApi = {
      unstable_getCellColSpanInfo: getCellColSpanInfo
    };
    const columnSpanningPrivateApi = {
      calculateColSpan
    };
    useGridApiMethod(apiRef2, columnSpanningPublicApi, "public");
    useGridApiMethod(apiRef2, columnSpanningPrivateApi, "private");
    const handleColumnReorderChange = React__namespace.useCallback(() => {
      lookup.current = {};
    }, []);
    useGridApiEventHandler(apiRef2, "columnOrderChange", handleColumnReorderChange);
  };
  const recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {
    if (isLeaf(columnGroupNode)) {
      if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== void 0) {
        throw new Error([`MUI: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(" > ")}`, `- ${parents.join(" > ")}`].join("\n"));
      }
      unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;
      return;
    }
    const {
      groupId,
      children
    } = columnGroupNode;
    children.forEach((child) => {
      recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);
    });
  };
  const unwrapGroupingColumnModel = (columnGroupingModel) => {
    if (!columnGroupingModel) {
      return {};
    }
    const unwrappedSubTree = {};
    columnGroupingModel.forEach((columnGroupNode) => {
      recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);
    });
    return unwrappedSubTree;
  };
  const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel) => {
    const getParents = (field) => {
      var _unwrappedGroupingMod;
      return (_unwrappedGroupingMod = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod : [];
    };
    const groupingHeaderStructure = [];
    const maxDepth = Math.max(...orderedColumns.map((field) => getParents(field).length));
    const haveSameParents = (field1, field2, depth) => isDeepEqual(getParents(field1).slice(0, depth + 1), getParents(field2).slice(0, depth + 1));
    for (let depth = 0; depth < maxDepth; depth += 1) {
      const depthStructure = orderedColumns.reduce((structure, newField) => {
        var _getParents$depth;
        const groupId = (_getParents$depth = getParents(newField)[depth]) != null ? _getParents$depth : null;
        if (structure.length === 0) {
          return [{
            columnFields: [newField],
            groupId
          }];
        }
        const lastGroup = structure[structure.length - 1];
        const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];
        const prevGroupId = lastGroup.groupId;
        if (prevGroupId !== groupId || !haveSameParents(prevField, newField, depth)) {
          return [...structure, {
            columnFields: [newField],
            groupId
          }];
        }
        return [...structure.slice(0, structure.length - 1), {
          columnFields: [...lastGroup.columnFields, newField],
          groupId
        }];
      }, []);
      groupingHeaderStructure.push(depthStructure);
    }
    return groupingHeaderStructure;
  };
  const _excluded$2 = ["groupId", "children"];
  const createGroupLookup = (columnGroupingModel) => {
    let groupLookup = {};
    columnGroupingModel.forEach((node2) => {
      if (isLeaf(node2)) {
        return;
      }
      const {
        groupId,
        children
      } = node2, other = _objectWithoutPropertiesLoose(node2, _excluded$2);
      if (!groupId) {
        throw new Error("MUI: An element of the columnGroupingModel does not have either `field` or `groupId`.");
      }
      if (!children) {
        console.warn(`MUI: group groupId=${groupId} has no children.`);
      }
      const groupParam = _extends({}, other, {
        groupId
      });
      const subTreeLookup = createGroupLookup(children);
      if (subTreeLookup[groupId] !== void 0 || groupLookup[groupId] !== void 0) {
        throw new Error(`MUI: The groupId ${groupId} is used multiple times in the columnGroupingModel.`);
      }
      groupLookup = _extends({}, groupLookup, subTreeLookup, {
        [groupId]: groupParam
      });
    });
    return _extends({}, groupLookup);
  };
  const columnGroupsStateInitializer = (state, props, apiRef2) => {
    var _props$experimentalFe, _props$columnGrouping, _props$columnGrouping2;
    if (!((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.columnGrouping)) {
      return state;
    }
    const columnFields = gridColumnFieldsSelector(apiRef2);
    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef2);
    const groupLookup = createGroupLookup((_props$columnGrouping = props.columnGroupingModel) != null ? _props$columnGrouping : []);
    const unwrappedGroupingModel = unwrapGroupingColumnModel((_props$columnGrouping2 = props.columnGroupingModel) != null ? _props$columnGrouping2 : []);
    const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(columnFields, unwrappedGroupingModel);
    const maxDepth = visibleColumnFields.length === 0 ? 0 : Math.max(...visibleColumnFields.map((field) => {
      var _unwrappedGroupingMod, _unwrappedGroupingMod2;
      return (_unwrappedGroupingMod = (_unwrappedGroupingMod2 = unwrappedGroupingModel[field]) == null ? void 0 : _unwrappedGroupingMod2.length) != null ? _unwrappedGroupingMod : 0;
    }));
    return _extends({}, state, {
      columnGrouping: {
        lookup: groupLookup,
        unwrappedGroupingModel,
        headerStructure: columnGroupsHeaderStructure,
        maxDepth
      }
    });
  };
  const useGridColumnGrouping = (apiRef2, props) => {
    var _props$experimentalFe3;
    const getColumnGroupPath = React__namespace.useCallback((field) => {
      var _unwrappedGroupingMod3;
      const unwrappedGroupingModel = gridColumnGroupsUnwrappedModelSelector(apiRef2);
      return (_unwrappedGroupingMod3 = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod3 : [];
    }, [apiRef2]);
    const getAllGroupDetails = React__namespace.useCallback(() => {
      const columnGroupLookup = gridColumnGroupsLookupSelector(apiRef2);
      return columnGroupLookup;
    }, [apiRef2]);
    const columnGroupingApi = {
      unstable_getColumnGroupPath: getColumnGroupPath,
      unstable_getAllGroupDetails: getAllGroupDetails
    };
    useGridApiMethod(apiRef2, columnGroupingApi, "public");
    const handleColumnIndexChange = React__namespace.useCallback(() => {
      var _props$columnGrouping3;
      const unwrappedGroupingModel = unwrapGroupingColumnModel((_props$columnGrouping3 = props.columnGroupingModel) != null ? _props$columnGrouping3 : []);
      apiRef2.current.setState((state) => {
        var _state$columns$ordere, _state$columns;
        const orderedFields = (_state$columns$ordere = (_state$columns = state.columns) == null ? void 0 : _state$columns.orderedFields) != null ? _state$columns$ordere : [];
        const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(orderedFields, unwrappedGroupingModel);
        return _extends({}, state, {
          columnGrouping: _extends({}, state.columnGrouping, {
            headerStructure: columnGroupsHeaderStructure
          })
        });
      });
    }, [apiRef2, props.columnGroupingModel]);
    const updateColumnGroupingState = React__namespace.useCallback((columnGroupingModel) => {
      var _props$experimentalFe2;
      if (!((_props$experimentalFe2 = props.experimentalFeatures) != null && _props$experimentalFe2.columnGrouping)) {
        return;
      }
      const columnFields = gridColumnFieldsSelector(apiRef2);
      const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef2);
      const groupLookup = createGroupLookup(columnGroupingModel != null ? columnGroupingModel : []);
      const unwrappedGroupingModel = unwrapGroupingColumnModel(columnGroupingModel != null ? columnGroupingModel : []);
      const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(columnFields, unwrappedGroupingModel);
      const maxDepth = visibleColumnFields.length === 0 ? 0 : Math.max(...visibleColumnFields.map((field) => {
        var _unwrappedGroupingMod4, _unwrappedGroupingMod5;
        return (_unwrappedGroupingMod4 = (_unwrappedGroupingMod5 = unwrappedGroupingModel[field]) == null ? void 0 : _unwrappedGroupingMod5.length) != null ? _unwrappedGroupingMod4 : 0;
      }));
      apiRef2.current.setState((state) => {
        return _extends({}, state, {
          columnGrouping: {
            lookup: groupLookup,
            unwrappedGroupingModel,
            headerStructure: columnGroupsHeaderStructure,
            maxDepth
          }
        });
      });
    }, [apiRef2, (_props$experimentalFe3 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe3.columnGrouping]);
    useGridApiEventHandler(apiRef2, "columnIndexChange", handleColumnIndexChange);
    useGridApiEventHandler(apiRef2, "columnsChange", () => {
      updateColumnGroupingState(props.columnGroupingModel);
    });
    useGridApiEventHandler(apiRef2, "columnVisibilityModelChange", () => {
      updateColumnGroupingState(props.columnGroupingModel);
    });
    React__namespace.useEffect(() => {
      updateColumnGroupingState(props.columnGroupingModel);
    }, [updateColumnGroupingState, props.columnGroupingModel]);
  };
  const useDataGridComponent = (inputApiRef, props) => {
    const privateApiRef = useGridInitialization(inputApiRef, props);
    useGridRowSelectionPreProcessors(privateApiRef, props);
    useGridRowsPreProcessors(privateApiRef);
    useGridInitializeState(rowSelectionStateInitializer, privateApiRef, props);
    useGridInitializeState(columnsStateInitializer, privateApiRef, props);
    useGridInitializeState(rowsStateInitializer, privateApiRef, props);
    useGridInitializeState(editingStateInitializer, privateApiRef, props);
    useGridInitializeState(focusStateInitializer, privateApiRef, props);
    useGridInitializeState(sortingStateInitializer, privateApiRef, props);
    useGridInitializeState(preferencePanelStateInitializer, privateApiRef, props);
    useGridInitializeState(filterStateInitializer, privateApiRef, props);
    useGridInitializeState(densityStateInitializer, privateApiRef, props);
    useGridInitializeState(paginationStateInitializer, privateApiRef, props);
    useGridInitializeState(rowsMetaStateInitializer, privateApiRef, props);
    useGridInitializeState(columnMenuStateInitializer, privateApiRef, props);
    useGridInitializeState(columnGroupsStateInitializer, privateApiRef, props);
    useGridKeyboardNavigation(privateApiRef, props);
    useGridRowSelection(privateApiRef, props);
    useGridColumns(privateApiRef, props);
    useGridRows(privateApiRef, props);
    useGridParamsApi(privateApiRef, props);
    useGridColumnSpanning(privateApiRef);
    useGridColumnGrouping(privateApiRef, props);
    useGridEditing(privateApiRef, props);
    useGridFocus(privateApiRef, props);
    useGridPreferencesPanel(privateApiRef, props);
    useGridFilter(privateApiRef, props);
    useGridSorting(privateApiRef, props);
    useGridDensity(privateApiRef, props);
    useGridPagination(privateApiRef, props);
    useGridRowsMeta(privateApiRef, props);
    useGridScroll(privateApiRef, props);
    useGridColumnMenu(privateApiRef);
    useGridCsvExport(privateApiRef, props);
    useGridPrintExport(privateApiRef, props);
    useGridClipboard(privateApiRef, props);
    useGridDimensions(privateApiRef, props);
    useGridEvents(privateApiRef, props);
    useGridStatePersistence(privateApiRef);
    return privateApiRef;
  };
  const useUtilityClasses$2 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["virtualScroller"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const VirtualScrollerRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "VirtualScroller",
    overridesResolver: (props, styles2) => styles2.virtualScroller
  })({
    overflow: "auto",
    height: "100%",
    // See https://github.com/mui/mui-x/issues/4360
    position: "relative",
    "@media print": {
      overflow: "hidden"
    }
  });
  const GridVirtualScroller = /* @__PURE__ */ React__namespace.forwardRef(function GridVirtualScroller2(props, ref) {
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses$2(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerRoot, _extends({
      ref
    }, props, {
      className: clsx(classes.root, props.className),
      ownerState: rootProps
    }));
  });
  const useUtilityClasses$1 = (props, overflowedContent) => {
    const {
      classes
    } = props;
    const slots = {
      root: ["virtualScrollerContent", overflowedContent && "virtualScrollerContent--overflowed"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const VirtualScrollerContentRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "VirtualScrollerContent",
    overridesResolver: (props, styles2) => styles2.virtualScrollerContent
  })({});
  const GridVirtualScrollerContent = /* @__PURE__ */ React__namespace.forwardRef(function GridVirtualScrollerContent2(props, ref) {
    var _props$style;
    const rootProps = useGridRootProps();
    const overflowedContent = !rootProps.autoHeight && ((_props$style = props.style) == null ? void 0 : _props$style.minHeight) === "auto";
    const classes = useUtilityClasses$1(rootProps, overflowedContent);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerContentRoot, _extends({
      ref
    }, props, {
      ownerState: rootProps,
      className: clsx(classes.root, props.className)
    }));
  });
  const _excluded$1 = ["className"];
  const useUtilityClasses = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["virtualScrollerRenderZone"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  };
  const VirtualScrollerRenderZoneRoot = styled$3("div", {
    name: "MuiDataGrid",
    slot: "VirtualScrollerRenderZone",
    overridesResolver: (props, styles2) => styles2.virtualScrollerRenderZone
  })({
    position: "absolute",
    display: "flex",
    // Prevents margin collapsing when using `getRowSpacing`
    flexDirection: "column"
  });
  const GridVirtualScrollerRenderZone = /* @__PURE__ */ React__namespace.forwardRef(function GridVirtualScrollerRenderZone2(props, ref) {
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
    const rootProps = useGridRootProps();
    const classes = useUtilityClasses(rootProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerRenderZoneRoot, _extends({
      ref,
      className: clsx(classes.root, className),
      ownerState: rootProps
    }, other));
  });
  const _excluded = ["className", "disableVirtualization"];
  const DataGridVirtualScroller = /* @__PURE__ */ React__namespace.forwardRef(function DataGridVirtualScroller2(props, ref) {
    const {
      className,
      disableVirtualization
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
    const {
      getRootProps,
      getContentProps,
      getRenderZoneProps,
      getRows
    } = useGridVirtualScroller({
      ref,
      disableVirtualization
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridVirtualScroller, _extends({
      className
    }, getRootProps(other), {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlays, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollerContent, _extends({}, getContentProps(), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollerRenderZone, _extends({}, getRenderZoneProps(), {
          children: getRows()
        }))
      }))]
    }));
  });
  const DataGridRaw = /* @__PURE__ */ React__namespace.forwardRef(function DataGrid2(inProps, ref) {
    const props = useDataGridProps(inProps);
    const privateApiRef = useDataGridComponent(props.apiRef, props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContextProvider, {
      privateApiRef,
      props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRoot, _extends({
        className: props.className,
        style: props.style,
        sx: props.sx,
        ref
      }, props.forwardedProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridHeader, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridBody, {
          VirtualScrollerComponent: DataGridVirtualScroller
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooterPlaceholder, {})]
      }))
    });
  });
  const DataGrid = /* @__PURE__ */ React__namespace.memo(DataGridRaw);
  DATA_GRID_PROPS_DEFAULT_VALUES.filterDebounceMs;
  DATA_GRID_PROPS_DEFAULT_VALUES.filterDebounceMs;
  DataGridRaw.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * The ref object that allows grid manipulation. Can be instantiated with `useGridApiRef()`.
     */
    apiRef: PropTypes.shape({
      current: PropTypes.object.isRequired
    }),
    /**
     * The label of the grid.
     */
    "aria-label": PropTypes.string,
    /**
     * The id of the element containing a label for the grid.
     */
    "aria-labelledby": PropTypes.string,
    /**
     * If `true`, the grid height is dynamic and follow the number of rows in the grid.
     * @default false
     */
    autoHeight: PropTypes.bool,
    /**
     * If `true`, the pageSize is calculated according to the container size and the max number of rows to avoid rendering a vertical scroll bar.
     * @default false
     */
    autoPageSize: PropTypes.bool,
    /**
     * Controls the modes of the cells.
     */
    cellModesModel: PropTypes.object,
    /**
     * If `true`, the grid get a first column with a checkbox that allows to select rows.
     * @default false
     */
    checkboxSelection: PropTypes.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: PropTypes.object,
    /**
     * The character used to separate cell values when copying to the clipboard.
     * @default '\t'
     */
    clipboardCopyCellDelimiter: PropTypes.string,
    /**
     * Number of extra columns to be rendered before/after the visible slice.
     * @default 3
     */
    columnBuffer: PropTypes.number,
    columnGroupingModel: PropTypes.arrayOf(PropTypes.object),
    /**
     * Sets the height in pixel of the column headers in the grid.
     * @default 56
     */
    columnHeaderHeight: PropTypes.number,
    /**
     * Set of columns of type [[GridColDef[]]].
     */
    columns: chainPropTypes(PropTypes.array.isRequired),
    /**
     * Number of rows from the `columnBuffer` that can be visible before a new slice is rendered.
     * @default 3
     */
    columnThreshold: PropTypes.number,
    /**
     * Set the column visibility model of the grid.
     * If defined, the grid will ignore the `hide` property in [[GridColDef]].
     */
    columnVisibilityModel: PropTypes.object,
    /**
     * Overridable components.
     * @deprecated Use `slots` instead.
     */
    components: PropTypes.object,
    /**
     * Overridable components props dynamically passed to the component at rendering.
     * @deprecated Use the `slotProps` prop instead.
     */
    componentsProps: PropTypes.object,
    /**
     * Set the density of the grid.
     * @default "standard"
     */
    density: PropTypes.oneOf(["comfortable", "compact", "standard"]),
    /**
     * If `true`, column filters are disabled.
     * @default false
     */
    disableColumnFilter: PropTypes.bool,
    /**
     * If `true`, the column menu is disabled.
     * @default false
     */
    disableColumnMenu: PropTypes.bool,
    /**
     * If `true`, hiding/showing columns is disabled.
     * @default false
     */
    disableColumnSelector: PropTypes.bool,
    /**
     * If `true`, the density selector is disabled.
     * @default false
     */
    disableDensitySelector: PropTypes.bool,
    /**
     * If `true`, `eval()` is not used for performance optimization.
     * @default false
     * @ignore - do not document
     */
    disableEval: PropTypes.bool,
    /**
     * If `true`, the selection on click on a row or cell is disabled.
     * @default false
     */
    disableRowSelectionOnClick: PropTypes.bool,
    /**
     * If `true`, the virtualization is disabled.
     * @default false
     */
    disableVirtualization: PropTypes.bool,
    /**
     * Controls whether to use the cell or row editing.
     * @default "cell"
     */
    editMode: PropTypes.oneOf(["cell", "row"]),
    /**
     * Unstable features, breaking changes might be introduced.
     * For each feature, if the flag is not explicitly set to `true`, the feature will be fully disabled and any property / method call will not have any effect.
     */
    experimentalFeatures: PropTypes.shape({
      ariaV7: PropTypes.bool,
      columnGrouping: PropTypes.bool,
      warnIfFocusStateIsNotSynced: PropTypes.bool
    }),
    /**
     * The milliseconds delay to wait after a keystroke before triggering filtering.
     * @default 150
     */
    filterDebounceMs: PropTypes.number,
    /**
     * Filtering can be processed on the server or client-side.
     * Set it to 'server' if you would like to handle filtering on the server-side.
     * @default "client"
     */
    filterMode: PropTypes.oneOf(["client", "server"]),
    /**
     * Set the filter model of the grid.
     */
    filterModel: PropTypes.shape({
      items: PropTypes.arrayOf(PropTypes.shape({
        field: PropTypes.string.isRequired,
        id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
        operator: PropTypes.string.isRequired,
        value: PropTypes.any
      })).isRequired,
      logicOperator: PropTypes.oneOf(["and", "or"]),
      quickFilterExcludeHiddenColumns: PropTypes.bool,
      quickFilterLogicOperator: PropTypes.oneOf(["and", "or"]),
      quickFilterValues: PropTypes.array
    }),
    /**
     * Forwarded props for the grid root element.
     * @ignore - do not document.
     */
    forwardedProps: PropTypes.object,
    /**
     * Function that applies CSS classes dynamically on cells.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @returns {string} The CSS class to apply to the cell.
     */
    getCellClassName: PropTypes.func,
    /**
     * Function that returns the element to render in row detail.
     * @param {GridRowParams} params With all properties from [[GridRowParams]].
     * @returns {React.JSX.Element} The row detail element.
     */
    getDetailPanelContent: PropTypes.func,
    /**
     * Function that returns the estimated height for a row.
     * Only works if dynamic row height is used.
     * Once the row height is measured this value is discarded.
     * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
     * @returns {number | null} The estimated row height value. If `null` or `undefined` then the default row height, based on the density, is applied.
     */
    getEstimatedRowHeight: PropTypes.func,
    /**
     * Function that applies CSS classes dynamically on rows.
     * @param {GridRowClassNameParams} params With all properties from [[GridRowClassNameParams]].
     * @returns {string} The CSS class to apply to the row.
     */
    getRowClassName: PropTypes.func,
    /**
     * Function that sets the row height per row.
     * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
     * @returns {GridRowHeightReturnValue} The row height value. If `null` or `undefined` then the default row height is applied. If "auto" then the row height is calculated based on the content.
     */
    getRowHeight: PropTypes.func,
    /**
     * Return the id of a given [[GridRowModel]].
     */
    getRowId: PropTypes.func,
    /**
     * Function that allows to specify the spacing between rows.
     * @param {GridRowSpacingParams} params With all properties from [[GridRowSpacingParams]].
     * @returns {GridRowSpacing} The row spacing values.
     */
    getRowSpacing: PropTypes.func,
    /**
     * If `true`, the footer component is hidden.
     * @default false
     */
    hideFooter: PropTypes.bool,
    /**
     * If `true`, the pagination component in the footer is hidden.
     * @default false
     */
    hideFooterPagination: PropTypes.bool,
    /**
     * If `true`, the selected row count in the footer is hidden.
     * @default false
     */
    hideFooterSelectedRowCount: PropTypes.bool,
    /**
     * The initial state of the DataGrid.
     * The data in it will be set in the state on initialization but will not be controlled.
     * If one of the data in `initialState` is also being controlled, then the control state wins.
     */
    initialState: PropTypes.object,
    /**
     * Callback fired when a cell is rendered, returns true if the cell is editable.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @returns {boolean} A boolean indicating if the cell is editable.
     */
    isCellEditable: PropTypes.func,
    /**
     * Determines if a row can be selected.
     * @param {GridRowParams} params With all properties from [[GridRowParams]].
     * @returns {boolean} A boolean indicating if the cell is selectable.
     */
    isRowSelectable: PropTypes.func,
    /**
     * If `true`, the selection model will retain selected rows that do not exist.
     * Useful when using server side pagination and row selections need to be retained
     * when changing pages.
     * @default false
     */
    keepNonExistentRowsSelected: PropTypes.bool,
    /**
     * If `true`, a  loading overlay is displayed.
     */
    loading: PropTypes.bool,
    /**
     * Set the locale text of the grid.
     * You can find all the translation keys supported in [the source](https://github.com/mui/mui-x/blob/HEAD/packages/grid/x-data-grid/src/constants/localeTextConstants.ts) in the GitHub repository.
     */
    localeText: PropTypes.object,
    /**
     * Pass a custom logger in the components that implements the [[Logger]] interface.
     * @default console
     */
    logger: PropTypes.shape({
      debug: PropTypes.func.isRequired,
      error: PropTypes.func.isRequired,
      info: PropTypes.func.isRequired,
      warn: PropTypes.func.isRequired
    }),
    /**
     * Allows to pass the logging level or false to turn off logging.
     * @default "error" ("warn" in dev mode)
     */
    logLevel: PropTypes.oneOf(["debug", "error", "info", "warn", false]),
    /**
     * Nonce of the inline styles for [Content Security Policy](https://www.w3.org/TR/2016/REC-CSP2-20161215/#script-src-the-nonce-attribute).
     */
    nonce: PropTypes.string,
    /**
     * Callback fired when any cell is clicked.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onCellClick: PropTypes.func,
    /**
     * Callback fired when a double click event comes from a cell element.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onCellDoubleClick: PropTypes.func,
    /**
     * Callback fired when the cell turns to edit mode.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
     */
    onCellEditStart: PropTypes.func,
    /**
     * Callback fired when the cell turns to view mode.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
     */
    onCellEditStop: PropTypes.func,
    /**
     * Callback fired when a keydown event comes from a cell element.
     * @param {GridCellParams} params With all properties from [[GridCellParams]].
     * @param {MuiEvent<React.KeyboardEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onCellKeyDown: PropTypes.func,
    /**
     * Callback fired when the `cellModesModel` prop changes.
     * @param {GridCellModesModel} cellModesModel Object containing which cells are in "edit" mode.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onCellModesModelChange: PropTypes.func,
    /**
     * Callback called when the data is copied to the clipboard.
     * @param {string} data The data copied to the clipboard.
     */
    onClipboardCopy: PropTypes.func,
    /**
     * Callback fired when a click event comes from a column header element.
     * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnHeaderClick: PropTypes.func,
    /**
     * Callback fired when a double click event comes from a column header element.
     * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnHeaderDoubleClick: PropTypes.func,
    /**
     * Callback fired when a mouse enter event comes from a column header element.
     * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnHeaderEnter: PropTypes.func,
    /**
     * Callback fired when a mouse leave event comes from a column header element.
     * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnHeaderLeave: PropTypes.func,
    /**
     * Callback fired when a mouseout event comes from a column header element.
     * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnHeaderOut: PropTypes.func,
    /**
     * Callback fired when a mouseover event comes from a column header element.
     * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnHeaderOver: PropTypes.func,
    /**
     * Callback fired when a column is reordered.
     * @param {GridColumnOrderChangeParams} params With all properties from [[GridColumnOrderChangeParams]].
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnOrderChange: PropTypes.func,
    /**
     * Callback fired when the column visibility model changes.
     * @param {GridColumnVisibilityModel} model The new model.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onColumnVisibilityModelChange: PropTypes.func,
    /**
     * Callback fired when the Filter model changes before the filters are applied.
     * @param {GridFilterModel} model With all properties from [[GridFilterModel]].
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onFilterModelChange: PropTypes.func,
    /**
     * Callback fired when the menu is closed.
     * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onMenuClose: PropTypes.func,
    /**
     * Callback fired when the menu is opened.
     * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onMenuOpen: PropTypes.func,
    /**
     * Callback fired when the pagination model has changed.
     * @param {GridPaginationModel} model Updated pagination model.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onPaginationModelChange: PropTypes.func,
    /**
     * Callback fired when the preferences panel is closed.
     * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onPreferencePanelClose: PropTypes.func,
    /**
     * Callback fired when the preferences panel is opened.
     * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onPreferencePanelOpen: PropTypes.func,
    /**
     * Callback called when `processRowUpdate` throws an error or rejects.
     * @param {any} error The error thrown.
     */
    onProcessRowUpdateError: PropTypes.func,
    /**
     * Callback fired when the grid is resized.
     * @param {ElementSize} containerSize With all properties from [[ElementSize]].
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onResize: PropTypes.func,
    /**
     * Callback fired when a row is clicked.
     * Not called if the target clicked is an interactive element added by the built-in columns.
     * @param {GridRowParams} params With all properties from [[GridRowParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onRowClick: PropTypes.func,
    /**
     * Callback fired when a double click event comes from a row container element.
     * @param {GridRowParams} params With all properties from [[RowParams]].
     * @param {MuiEvent<React.MouseEvent>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onRowDoubleClick: PropTypes.func,
    /**
     * Callback fired when the row changes are committed.
     * @param {GridRowId} id The row id.
     * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
     */
    onRowEditCommit: PropTypes.func,
    /**
     * Callback fired when the row turns to edit mode.
     * @param {GridRowParams} params With all properties from [[GridRowParams]].
     * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
     */
    onRowEditStart: PropTypes.func,
    /**
     * Callback fired when the row turns to view mode.
     * @param {GridRowParams} params With all properties from [[GridRowParams]].
     * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
     */
    onRowEditStop: PropTypes.func,
    /**
     * Callback fired when the `rowModesModel` prop changes.
     * @param {GridRowModesModel} rowModesModel Object containing which rows are in "edit" mode.
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onRowModesModelChange: PropTypes.func,
    /**
     * Callback fired when the selection state of one or multiple rows changes.
     * @param {GridRowSelectionModel} rowSelectionModel With all the row ids [[GridSelectionModel]].
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onRowSelectionModelChange: PropTypes.func,
    /**
     * Callback fired when the sort model changes before a column is sorted.
     * @param {GridSortModel} model With all properties from [[GridSortModel]].
     * @param {GridCallbackDetails} details Additional details for this callback.
     */
    onSortModelChange: PropTypes.func,
    /**
     * Callback fired when the state of the grid is updated.
     * @param {GridState} state The new state.
     * @param {MuiEvent<{}>} event The event object.
     * @param {GridCallbackDetails} details Additional details for this callback.
     * @ignore - do not document.
     */
    onStateChange: PropTypes.func,
    /**
     * Select the pageSize dynamically using the component UI.
     * @default [25, 50, 100]
     */
    pageSizeOptions: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
      label: PropTypes.string.isRequired,
      value: PropTypes.number.isRequired
    })]).isRequired),
    pagination: (props) => {
      if (props.pagination === false) {
        return new Error(["MUI: `<DataGrid pagination={false} />` is not a valid prop.", "Infinite scrolling is not available in the MIT version.", "", "You need to upgrade to DataGridPro or DataGridPremium component to disable the pagination."].join("\n"));
      }
      return null;
    },
    /**
     * Pagination can be processed on the server or client-side.
     * Set it to 'client' if you would like to handle the pagination on the client-side.
     * Set it to 'server' if you would like to handle the pagination on the server-side.
     * @default "client"
     */
    paginationMode: PropTypes.oneOf(["client", "server"]),
    /**
     * The pagination model of type [[GridPaginationModel]] which refers to current `page` and `pageSize`.
     */
    paginationModel: PropTypes.shape({
      page: PropTypes.number.isRequired,
      pageSize: PropTypes.number.isRequired
    }),
    /**
     * Callback called before updating a row with new values in the row and cell editing.
     * @template R
     * @param {R} newRow Row object with the new values.
     * @param {R} oldRow Row object with the old values.
     * @returns {Promise<R> | R} The final values to update the row.
     */
    processRowUpdate: PropTypes.func,
    /**
     * Number of extra rows to be rendered before/after the visible slice.
     * @default 3
     */
    rowBuffer: PropTypes.number,
    /**
     * Set the total number of rows, if it is different from the length of the value `rows` prop.
     * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
     */
    rowCount: PropTypes.number,
    /**
     * Sets the height in pixel of a row in the grid.
     * @default 52
     */
    rowHeight: PropTypes.number,
    /**
     * Controls the modes of the rows.
     */
    rowModesModel: PropTypes.object,
    /**
     * Set of rows of type [[GridRowsProp]].
     */
    rows: PropTypes.arrayOf(PropTypes.object).isRequired,
    /**
     * If `false`, the row selection mode is disabled.
     * @default true
     */
    rowSelection: PropTypes.bool,
    /**
     * Sets the row selection model of the grid.
     */
    rowSelectionModel: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired), PropTypes.number, PropTypes.string]),
    /**
     * Sets the type of space between rows added by `getRowSpacing`.
     * @default "margin"
     */
    rowSpacingType: PropTypes.oneOf(["border", "margin"]),
    /**
     * Number of rows from the `rowBuffer` that can be visible before a new slice is rendered.
     * @default 3
     */
    rowThreshold: PropTypes.number,
    /**
     * Override the height/width of the grid inner scrollbar.
     */
    scrollbarSize: PropTypes.number,
    /**
     * If `true`, the vertical borders of the cells are displayed.
     * @default false
     */
    showCellVerticalBorder: PropTypes.bool,
    /**
     * If `true`, the right border of the column headers are displayed.
     * @default false
     */
    showColumnVerticalBorder: PropTypes.bool,
    /**
     * Overridable components props dynamically passed to the component at rendering.
     */
    slotProps: PropTypes.object,
    /**
     * Overridable components.
     */
    slots: PropTypes.object,
    /**
     * Sorting can be processed on the server or client-side.
     * Set it to 'client' if you would like to handle sorting on the client-side.
     * Set it to 'server' if you would like to handle sorting on the server-side.
     * @default "client"
     */
    sortingMode: PropTypes.oneOf(["client", "server"]),
    /**
     * The order of the sorting sequence.
     * @default ['asc', 'desc', null]
     */
    sortingOrder: PropTypes.arrayOf(PropTypes.oneOf(["asc", "desc"])),
    /**
     * Set the sort model of the grid.
     */
    sortModel: PropTypes.arrayOf(PropTypes.shape({
      field: PropTypes.string.isRequired,
      sort: PropTypes.oneOf(["asc", "desc"])
    })),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
    /**
     * If `true`, the grid will not use `valueFormatter` when exporting to CSV or copying to clipboard.
     * If an object is provided, you can choose to ignore the `valueFormatter` for CSV export or clipboard export.
     * @default: false
     */
    unstable_ignoreValueFormatterDuringExport: PropTypes.oneOfType([PropTypes.shape({
      clipboardExport: PropTypes.bool,
      csvExport: PropTypes.bool
    }), PropTypes.bool])
  };
  const MyModal = (props) => {
    const [rows, setRow] = React.useState([]);
    const [showRows, setShowRows] = React.useState([]);
    const [filterModel2, setFilterModel] = React.useState({
      items: [],
      quickFilterExcludeHiddenColumns: true,
      quickFilterValues: [""]
    });
    const [columnVisibilityModel, setColumnVisibilityModel] = React.useState({});
    React.useEffect(() => {
      props.data.GetData(setRow);
    }, []);
    React.useEffect(() => {
      setShowRows(rows.filter(
        (row, index, self2) => index === self2.findIndex((r2) => r2.token === row.token)
      ).map((v2, i) => {
        v2.id = i + 1;
        return v2;
      }));
    }, [rows]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal$1,
      {
        open: props.open,
        onClose: () => props.setOpen(false),
        "aria-labelledby": "modal-modal-title",
        "aria-describedby": "modal-modal-description",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: {
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: `90%`,
          bgcolor: "background.paper",
          border: "2px solid #000",
          boxShadow: `24`,
          p: `4`,
          zIndex: `10000`,
          height: `80vh`
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DataGrid,
          {
            columns: props.data.Columns,
            rows: showRows,
            slots: { toolbar: GridToolbar },
            filterModel: filterModel2,
            onFilterModelChange: (newModel) => setFilterModel(newModel),
            slotProps: { toolbar: { showQuickFilter: true } },
            columnVisibilityModel,
            onColumnVisibilityModelChange: (newModel) => setColumnVisibilityModel(newModel)
          }
        ) })
      }
    );
  };
  class Action {
    constructor(name, url, columns, data) {
      __publicField(this, "Name");
      __publicField(this, "Url");
      __publicField(this, "Columns");
      __publicField(this, "Data");
      this.Name = name;
      this.Url = url;
      this.Columns = columns;
      this.Data = data;
    }
    MatchURL() {
      return this.Url.test(window.location.href);
    }
  }
  function bind(fn2, thisArg) {
    return function wrap() {
      return fn2.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn2, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l2 = obj.length; i < l2; i++) {
        fn2.call(null, obj[i], i, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l2 = arguments.length; i < l2; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position2) => {
    str = String(str);
    if (position2 === void 0 || position2 > str.length) {
      position2 = str.length;
    }
    position2 -= searchString.length;
    const lastIndex = str.indexOf(searchString, position2);
    return lastIndex !== -1 && lastIndex === position2;
  };
  const toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i = thing.length;
    if (!isNumber(i))
      return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn2) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn2.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      if (reducer(descriptor, name, obj) !== false) {
        reducedDescriptors[name] = descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length: length2 } = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length2 | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const utils = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };
  function AxiosError(message, code, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config2 && (this.config = config2);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils.toFlatObject(error, axiosError, function filter3(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config2, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils.isPlainObject(thing) || utils.isArray(thing);
  }
  function removeBrackets(key) {
    return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path)
      return key;
    return path.concat(key).map(function each(token2, i) {
      token2 = removeBrackets(token2);
      return !dots && i ? "[" + token2 + "]" : token2;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils.isSpecCompliantForm(formData);
    if (!utils.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils.forEach(value, function each(el, key) {
        const result = !(utils.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
      return charMap[match2];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append2(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn2) {
      utils.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn2(h2);
        }
      });
    }
  }
  const InterceptorManager$1 = InterceptorManager;
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const isStandardBrowserEnv = (() => {
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  })();
  const isStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const platform = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
      return match2[0] === "[]" ? "" : match2[1] || match2[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
      const obj = {};
      utils.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  const DEFAULT_CONTENT_TYPE = {
    "Content-Type": void 0
  };
  function stringifySafely(rawValue, parser, encoder) {
    if (utils.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils.isObject(data);
      if (isObjectPayload && utils.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils.isFormData(data);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional2 = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  const defaults$1 = defaults;
  const ignoreDuplicateOf = utils.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
      i = line2.indexOf(":");
      key = line2.substring(0, i).trim().toLowerCase();
      val = line2.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match2;
    while (match2 = tokensRE.exec(str)) {
      tokens[match2[1]] = match2[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
    if (utils.isFunction(filter3)) {
      return filter3.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils.isString(value))
      return;
    if (utils.isString(filter3)) {
      return value.indexOf(filter3) !== -1;
    }
    if (utils.isRegExp(filter3)) {
      return filter3.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
      return char2.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils.forEach(this, (value, header) => {
        const key = utils.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils.freezeMethods(AxiosHeaders.prototype);
  utils.freezeMethods(AxiosHeaders);
  const AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config2 = this || defaults$1;
    const context = response || config2;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils.forEach(fns, function transform(fn2) {
      data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config2, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  const cookies = platform.isStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write2(name, value, expires, path, domain, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read2(name) {
          const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write2() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const isURLSameOrigin = platform.isStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv2() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv2() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  function parseProtocol(url) {
    const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match2 && match2[1] || "";
  }
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return (e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    };
  }
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      let requestData = config2.data;
      const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
      const responseType = config2.responseType;
      let onCanceled;
      function done() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils.isFormData(requestData)) {
        if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false);
        } else {
          requestHeaders.setContentType("multipart/form-data;", false);
        }
      }
      let request = new XMLHttpRequest();
      if (config2.auth) {
        const username = config2.auth.username || "";
        const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
      request.timeout = config2.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitionalDefaults;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      if (platform.isStandardBrowserEnv) {
        const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils.isUndefined(config2.withCredentials)) {
        request.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
      }
      if (typeof config2.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(fullPath);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
  };
  utils.forEach(knownAdapters, (fn2, value) => {
    if (fn2) {
      try {
        Object.defineProperty(fn2, "name", { value });
      } catch (e2) {
      }
      Object.defineProperty(fn2, "adapterName", { value });
    }
  });
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
      const { length: length2 } = adapters2;
      let nameOrAdapter;
      let adapter;
      for (let i = 0; i < length2; i++) {
        nameOrAdapter = adapters2[i];
        if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
          break;
        }
      }
      if (!adapter) {
        if (adapter === false) {
          throw new AxiosError(
            `Adapter ${nameOrAdapter} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          );
        }
        throw new Error(
          utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
        );
      }
      if (!utils.isFunction(adapter)) {
        throw new TypeError("adapter is not a function");
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders$1.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge.call({ caseless }, target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b2, caseless) {
      if (!utils.isUndefined(b2)) {
        return getMergedValue(a, b2, caseless);
      } else if (!utils.isUndefined(a)) {
        return getMergedValue(void 0, a, caseless);
      }
    }
    function valueFromConfig2(a, b2) {
      if (!utils.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a, b2) {
      if (!utils.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
    };
    utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  const VERSION = "1.4.0";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional: transitional2, paramsSerializer, headers } = config2;
      if (transitional2 !== void 0) {
        validator.assertOptions(transitional2, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders;
      contextHeaders = headers && utils.merge(
        headers.common,
        headers[config2.method]
      );
      contextHeaders && utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  }
  utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
    Axios.prototype[method] = function(url, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        url,
        data: (config2 || {}).data
      }));
    };
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  const Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token2 = this;
      this.promise.then((cancel) => {
        if (!token2._listeners)
          return;
        let i = token2._listeners.length;
        while (i-- > 0) {
          token2._listeners[i](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token2.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token2.reason) {
          return;
        }
        token2.reason = new CanceledError(message, config2, request);
        resolvePromise(token2.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token2 = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token: token2,
        cancel
      };
    }
  }
  const CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  const HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const axios$1 = axios;
  class ChdGrade extends Action {
    constructor() {
      super(
        "等級補完",
        /^https:\/\/chdact2\.web\.sdo\.com\/project\/ChdGrade\/.*/,
        [
          { field: "id", headerName: "ID", type: "number", width: 80 },
          { field: "dateTime", headerName: "购买日期", type: "date", width: 200 },
          { field: "orderId", headerName: "订单编号", width: 400 },
          { field: "packageName", headerName: "礼包代码", width: 150 },
          { field: "name", headerName: "道具名称", width: 150 },
          { field: "token", headerName: "道具编码", width: 400 }
        ],
        []
      );
    }
    GetData(set) {
      const instance = axios$1.create({
        baseURL: "https://chdact2.web.sdo.com",
        timeout: 1e3,
        method: "get",
        responseType: "text",
        responseEncoding: "utf-8"
      });
      this.GetDataByPage(instance, set, 1);
    }
    async GetDataByPage(instance, set, page) {
      instance.get("/project/ChdGrade/order.asp", {
        params: {
          page
        }
      }).then((response) => {
        console.log(` --- 獲取第 ${page} 頁資料 --- `);
        const parser = new DOMParser();
        const doc = parser.parseFromString(response.data, "text/html");
        const trs = doc.querySelectorAll("tr");
        for (let index = 1; index < trs.length; index++) {
          let tr = trs[index];
          let tds = tr.querySelectorAll(`td`);
          if (tds[3].querySelectorAll("br").length > 0) {
            let names = tds[3].innerHTML.split("<br>").filter((k2) => k2 != "");
            let tokens = tds[4].innerHTML.split("<br>").filter((k2) => k2 != "");
            for (let index2 = 0; index2 < names.length; index2++) {
              let item = {
                dateTime: new Date(tds[0].innerHTML.replace("<br>", " ")),
                orderId: tds[1].innerHTML,
                packageName: tds[2].innerHTML,
                name: names[index2],
                token: tokens[index2]
              };
              set((pre) => {
                return [...pre, item];
              });
            }
          }
        }
        if (trs.length == 11) {
          this.GetDataByPage(instance, set, page + 1);
        }
      });
    }
  }
  class KWY extends Action {
    constructor() {
      super(
        "卡哇伊",
        /^https:\/\/chdact2\.web\.sdo\.com\/project\/kwl_.*/,
        [
          { field: "id", headerName: "ID", type: "number", width: 80 },
          { field: "name", headerName: "道具名称", width: 400 },
          { field: "token", headerName: "道具编码", width: 400 }
        ],
        []
      );
    }
    GetData(set) {
      const instance = axios$1.create({
        baseURL: "https://chdact2.web.sdo.com",
        timeout: 1e3,
        method: "get",
        responseType: "text",
        responseEncoding: "utf-8"
      });
      this.GetDataByPage(instance, set, 1);
    }
    async GetDataByPage(instance, set, page) {
      instance.get("/project/kwl_090604/orderlist.asp", {
        params: {
          page,
          id: 2
        }
      }).then((response) => {
        console.log(` --- 獲取第 ${page} 頁資料 --- `);
        const parser = new DOMParser();
        const doc = parser.parseFromString(response.data, "text/html");
        const trs = doc.querySelectorAll("tr");
        for (let index = 1; index < trs.length; index++) {
          let tr = trs[index];
          let row = tr.querySelectorAll(`td`);
          let item = {
            name: row[1].innerText,
            token: row[0].innerText
          };
          set((pre) => [...pre, item]);
        }
        if (trs.length == 12) {
          this.GetDataByPage(instance, set, page + 1);
        }
      });
    }
  }
  class QKS extends Action {
    constructor() {
      super("其卡斯的宝藏", /^https:\/\/chdact2\.web\.sdo\.com\/project\/Chicas.*/, [
        { field: "id", headerName: "ID", type: "number", width: 80 },
        { field: "dateTime", headerName: "获得时间", width: 300 },
        { field: "mapId", headerName: "地图编号", width: 200 },
        { field: "name", headerName: "道具名称", width: 400 },
        { field: "token", headerName: "道具编码", width: 400 },
        { field: "isNow", headerName: "当期宝物", type: "boolean", width: 100 }
      ], []);
    }
    GetData(set) {
      const instance = axios$1.create({
        baseURL: "https://chdact2.web.sdo.com",
        timeout: 1e3,
        method: "get",
        responseType: "text",
        responseEncoding: "utf-8"
      });
      this.GetDataByPage(instance, set, 1, 2);
      this.GetDataByPage(instance, set, 1, 1);
    }
    async GetDataByPage(instance, set, page, ctype) {
      instance.get("/project/Chicas/inc/getorder.asp", {
        params: {
          page,
          ctype
        }
      }).then((response) => {
        console.log(` --- 獲取第 ${page} 頁資料 --- `);
        let result = JSON.parse(response.data);
        result.datalist.forEach((item) => {
          set((pre) => [...pre, {
            dateTime: item.CreateTime,
            mapId: item.couponNum,
            name: item.ItemName,
            token: item.OrderId,
            isNow: 1 == ctype
          }]);
        });
        if (result.datalist.length == 7) {
          this.GetDataByPage(instance, set, page + 1, ctype);
        }
      });
    }
  }
  class LZ extends Action {
    constructor() {
      super(
        "礼赞 ",
        /^https:\/\/chdact2\.web\.sdo\.com\/project\/120629lz\/.*/,
        [
          { field: "id", headerName: "ID", type: "number", width: 80 },
          { field: "name", headerName: "道具名称", width: 400 },
          { field: "token", headerName: "道具编码", width: 400 }
        ],
        []
      );
    }
    GetData(set) {
      const instance = axios$1.create({
        baseURL: "https://chdact2.web.sdo.com",
        timeout: 1e3,
        method: "get",
        responseType: "text",
        responseEncoding: "utf-8"
      });
      this.GetDataByPage(instance, set, 1);
    }
    async GetDataByPage(instance, set, page) {
      instance.get("/project/120629lz/orderlist.asp", {
        params: {
          page,
          id: 2
        }
      }).then((response) => {
        console.log(` --- 獲取第 ${page} 頁資料 --- `);
        const parser = new DOMParser();
        const doc = parser.parseFromString(response.data, "text/html");
        const trs = doc.querySelectorAll("tr");
        for (let index = 1; index < trs.length; index++) {
          let tr = trs[index];
          let row = tr.querySelectorAll(`td`);
          let item = {
            name: row[1].innerText,
            token: row[0].innerText
          };
          set((pre) => [...pre, item]);
        }
        if (trs.length == 12) {
          this.GetDataByPage(instance, set, page + 1);
        }
      });
    }
  }
  function App() {
    const [open, setOpen] = React.useState(false);
    const [list, setList] = React.useState([]);
    const handleOpen = () => setOpen(true);
    React.useEffect(() => {
      setList([
        new ChdGrade(),
        new KWY(),
        new LZ(),
        new QKS()
      ]);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: list.filter((k2) => k2.MatchURL()).map((k2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Fab$1, { variant: "extended", size: "small", color: "primary", style: {
          position: "fixed",
          top: "16px",
          right: "16px"
        }, onClick: handleOpen, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, { sx: { mr: 1 } }),
          "查看"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MyModal, { open, setOpen, data: k2 })
      ] });
    }) });
  }
  client.createRoot(
    (() => {
      const app = document.createElement("div");
      document.body.append(app);
      return app;
    })()
  ).render(
    /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
  );

})(React, ReactDOM);
